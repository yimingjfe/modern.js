[{"id":284,"title":"命令","routePath":"/apis/app/commands","lang":"zh","toc":[{"text":"modern dev","id":"modern-dev","depth":2,"charIndex":93},{"text":"编译部分页面","id":"编译部分页面","depth":3,"charIndex":600},{"text":"通过参数指定页面","id":"通过参数指定页面","depth":3,"charIndex":840},{"text":"modern start","id":"modern-start","depth":2,"charIndex":979},{"text":"modern build","id":"modern-build","depth":2,"charIndex":1042},{"text":"分析构建产物体积","id":"分析构建产物体积","depth":3,"charIndex":1276},{"text":"modern new","id":"modern-new","depth":2,"charIndex":1729},{"text":"添加入口","id":"添加入口","depth":3,"charIndex":2120},{"text":"启用可选功能","id":"启用可选功能","depth":3,"charIndex":2228},{"text":"modern serve","id":"modern-serve","depth":2,"charIndex":2526},{"text":"modern upgrade","id":"modern-upgrade","depth":2,"charIndex":2880},{"text":"modern inspect","id":"modern-inspect","depth":2,"charIndex":3224},{"text":"指定环境","id":"指定环境","depth":3,"charIndex":3938},{"text":"完整内容","id":"完整内容","depth":3,"charIndex":4045},{"text":"SSR 构建配置","id":"ssr-构建配置","depth":3,"charIndex":4141},{"text":"modern lint","id":"modern-lint","depth":2,"charIndex":4530},{"text":"modern test","id":"modern-test","depth":2,"charIndex":4826}],"domain":"","content":"#\n\nModern.js 内置了一些命令，可以帮助你快速启动开发服务器、构建生产环境代码等。\n\n通过本章节，你可以了解到 Modern.js 内置的命令有哪些，以及如何使用这些命令。\n\n\nmodern dev#\n\nmodern dev 命令用于启动一个本地开发服务器，对源代码进行开发环境编译。\n\nUsage: modern dev [options]\n\nOptions:\n  -e --entry     指定入口，只编译特定的页面\n  -c --config   指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help            显示命令帮助\n  --analyze             分析构建产物体积，查看各个模块打包后的大小\n  --web-only            仅启动 Web 服务\n  --api-only            仅启动 API 接口服务\n\n\n运行 modern dev 后，Modern.js 会监听源文件变化并进行模块热更新。\n\n$ modern dev\n\ninfo    Starting dev server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n\n\n编译部分页面#\n\n在多页面（MPA）项目中，可以添加 --entry 参数来指定编译其中的一个或多个页面。这样可以只编译项目中的部分代码，从而提升 dev 启动速度。\n\n比如执行 modern dev --entry，在命令行界面中会展示入口选择框：\n\n$ modern dev --entry\n\n? 请选择需要构建的入口\n❯ ◯ foo\n  ◯ bar\n  ◯ baz\n\n\n比如选择 foo 入口，那么只有 foo 入口相关的代码会进行编译，其他页面的代码将不会参与构建。\n\n\n通过参数指定页面#\n\n你也可以在 --entry 后面通过参数来指定页面名称，多个页面的名称使用逗号分隔。\n\n# 编译 foo 页面\nmodern dev --entry foo\n\n# 编译 foo 和 bar 页面\nmodern dev --entry foo,bar\n\n\n\nmodern start#\n\nmodern start 是 modern dev 命令的别名，两者的功能和用法完全一致。\n\n\nmodern build#\n\nmodern build 命令默认会在 dist/ 目录下构建出可用于生产环境的产物。你可以通过修改配置 output.distPath 指定产物的输出目录。\n\nUsage: modern build [options]\n\nOptions:\n  -c --config   指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help  显示命令帮助\n  --analyze   分析构建产物体积，查看各个模块打包后的大小\n\n\n\n分析构建产物体积#\n\n执行 npx modern build --analyze 命令，可以在打包生产环境代码的同时，产出一个分析构建产物体积的 HTML 文件：\n\nBundle Analyzer saved report to /example/dist/report.html\nFile sizes after production build:\n\n  122.35 KB  dist/static/js/885.1d4fbe5a.js\n  2.3 KB     dist/static/js/main.4b8e8d64.js\n  761 B      dist/static/js/runtime-main.edb7cf35.js\n  645 B      dist/static/css/main.0dd3ecc1.css\n\n\n手动在浏览器中打开上述 HTML 文件，可以看到打包产物的瓦片图，并进行包体积分析和优化：\n\n> 该功能基于 webpack-bundle-analyzer 实现。\n\n\nmodern new#\n\nmodern new 命令用于在已有项目中添加项目元素。\n\n比如添加应用入口、启用一些可选功能如 Tailwind CSS、微前端开发模式等。\n\nUsage: modern new [options]\n\nOptions:\n  --lang           设置 new 命令执行语言(zh 或者 en)\n  -d, --debug            开启 Debug 模式，打印调试日志信息 (default: false)\n  -c, --config   生成器运行默认配置(JSON 字符串)\n  --dist-tag        生成器使用特殊的 npm Tag 版本\n  --registry             生成器运行过程中定制 npm Registry\n  -h, --help             显示命令帮助\n\n\n\n添加入口#\n\n在应用工程中，执行 new 命令添加入口如下：\n\n$ npx modern new\n? 请选择你想要的操作 创建工程元素\n? 请选择创建元素类型 新建「应用入口」\n? 请填写入口名称 entry\n\n\n\n启用可选功能#\n\n在应用工程中，执行 new 命令启用可选能力如下：\n\n$ npx modern new\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 (Use arrow keys)\n❯ 启用 「Tailwind CSS」 支持\n  启用「BFF」功能\n  启用「微前端」模式\n  启用「单元测试 / 集成测试」功能\n  启用「Visual Testing (Storybook)」模式\n\n\nTIP\n\n--config 参数对应参数值需要使用 JSON 字符串。\n\npnpm 暂不支持使用 JSON 字符串作为参数值，可使用 npm new 开启相关功能。【相关 Issue】\n\n\nmodern serve#\n\nmodern serve 命令用于在生产环境下启用应用工程, 注意需要提前执行 build 命令构建出对应产物。\n\nUsage: modern serve [options]\n\nOptions:\n  -c --config   指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help            显示命令帮助\n  --api-only            仅启动 API 接口服务\n\n\n默认情况下，应用将会在 localhost:8080 启动，可以通过 server.port 修改 Server 端口号：\n\nexport default defineConfig({\n  server: {\n    port: 8081,\n  },\n});\n\n\n\nmodern upgrade#\n\n在项目根目录下执行命令 npx modern upgrade，会默认将当前执行命令项目的 package.json 中的 Modern.js\n相关依赖更新至最新版本。\n\nUsage: modern upgrade [options]\n\nOptions:\n  --registry   定制 npm registry (default: \"\")\n  -d,--debug             开启 Debug 模式，打印调试日志信息 (default: false)\n  --cwd             项目路径 (default: \"\")\n  -h, --help             display help for command\n\n\n\nmodern inspect#\n\nmodern inspect 命令用于查看项目的 Modern.js Builder 配置 以及 webpack 配置。\n\nUsage: modern inspect [options]\n\nOptions:\n  --env            查看指定环境下的配置 (default: \"development\")\n  --output      指定在 dist 目录下输出的路径 (default: \"/\")\n  --verbose             在结果中展示函数的完整内容\n  -c --config   指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help            显示命令帮助\n\n\n在项目根目录下执行命令 npx modern inspect 后，会在项目的 dist 目录生成以下文件：\n\n * builder.config.js: 表示在构建时使用的 Modern.js Builder 配置。\n * webpack.config.web.js: 表示在构建时使用的 webpack 配置。\n\n➜ npx modern inspect\n\nInspect config succeed, open following files to view the content:\n\n  - Builder Config: /root/my-project/dist/builder.config.js\n  - Webpack Config (web): /root/my-project/dist/webpack.config.web.js\n\n\n\n指定环境#\n\n默认情况下，inspect 命令会输出开发环境的配置，你可以添加 --env production 选项来输出生产环境的配置：\n\nmodern inspect --env production\n\n\n\n完整内容#\n\n默认情况下，inspect 命令会省略配置对象中的函数内容，你可以添加 --verbose 选项来输出函数的完整内容：\n\nmodern inspect --verbose\n\n\n\nSSR 构建配置#\n\n如果项目开启了 SSR 能力，则在 dist 目录会另外生成一份 webpack.config.node.js 文件，对应 SSR 构建时的 webpack\n配置。\n\n➜ npx modern inspect\n\nInspect config succeed, open following files to view the content:\n\n  - Builder Config: /root/my-project/dist/builder.config.js\n  - Webpack Config (web): /root/my-project/dist/webpack.config.web.js\n  - Webpack Config (node): /root/my-project/dist/webpack.config.node.js\n\n\n\nmodern lint#\n\n运行 ESLint 进行代码语法检查。\n\nUsage: modern lint [options] [...files]\n\nlint and fix source files\n\nOptions:\n  --no-fix    disable auto fix source file\n  -h, --help  display help for command\n\n\n通常情况下，我们只需要在 git commit 阶段通过 lint-staged 检查本次提交修改的部分代码。\n\n * 设置 --no-fix 参数后可以关闭自动修复 lint 错误代码的能力。\n\n\nmodern test#\n\nmodern test 命令会自动运行项目下的测试用例。\n\nUsage: modern test [options]\n\nOptions:\n  -h, --help  显示命令帮助\n\n\nTIP\n\n在使用 modern test 命令前，需要先通过 new 命令启用「单元测试 / 集成测试」功能。\n\n效果如下：\n\n$ npx modern test\n PASS  src/tests/index.test.ts\n  The add method\n    ✓ should work fine. (2ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.994 s, estimated 1 s\n\n\nINFO\n\nsrc 和 api 目录下面的 *.test.(js|ts) 文件都会被识别为测试用例。","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/commands.mdx","_relativePath":"zh/apis/app/commands.mdx"},{"id":285,"title":"**/*.[tj]s","routePath":"/apis/app/hooks/api/api","lang":"zh","toc":[{"text":"该文件约定路由如下：","id":"该文件约定路由如下：","depth":2,"charIndex":153},{"text":"默认路由","id":"默认路由","depth":3,"charIndex":167},{"text":"嵌套路由","id":"嵌套路由","depth":3,"charIndex":277},{"text":"动态路由","id":"动态路由","depth":3,"charIndex":409},{"text":"白名单","id":"白名单","depth":3,"charIndex":689},{"text":"函数定义","id":"函数定义","depth":2,"charIndex":915}],"domain":"","content":"#\n\n在 BFF 函数写法下，声明 API 路由的文件。除了某些约定文件外，api 目录下的文件会被注册为接口的路由。\n\nINFO\n\n使用 api 目录需要开启 BFF 功能，需要在项目下执行 new 命令启用「BFF」功能。\n\n该文件支持使用 js 或 ts 语言，但必须使用 esm 语法导出函数。\n\n\n该文件约定路由如下：#\n\n\n默认路由#\n\n路由系统会将以 index 命名的文件会被映射到上一层目录。\n\n * api/index.ts -> $BASENAME/\n * api/user/index.ts -> $BASENAME/user\n\n\n嵌套路由#\n\n路由系统也支持解析嵌套的文件，如果创建嵌套文件夹结构，文件仍会以相同方式自动解析路由。\n\n * api/hello.ts -> $BASENAME/hello\n * api/user/list.ts -> $BASENAME/user/list\n\n\n动态路由#\n\n路由系统支持通过 [] 命名的文件目录生成动态路由。\n\n * api/user/[username]/info.ts -> $BASENAME/user/:username/info\n * api/user/[username]/delete.ts -> $BASENAME/user/:username/delete\n * api/article/[id]/info.ts -> $BASENAME/article/:id/info\n\n其中的 $BASENAME 可以在 modern.config.js 中进行配置，默认值为 /api。\n\n\n白名单#\n\n默认 api 目录下所有文件都会当作 BFF 函数文件去解析，但同样我们也设置了白名单，这些文件不被被解析：\n\n * 命名以 _ 开头的文件。例如：_utils.ts。\n * 命名以 _ 开头的文件夹下所有文件。例如：_utils/index.ts、_utils/cp.ts。\n * 测试文件。例如：foo.test.ts。\n * TypeScript 类型文件。例如：hello.d.ts。\n * node_module 下的文件。\n\n\n函数定义#\n\n除了上面的路由规则之外，代码中函数定义与导出也有相应的约定。\n\n函数通过具名导出，导出函数的名字为对应接口接受的 HTTP Method，即：\n\nexport const get = async () => {\n  return {\n    name: 'Modern.js',\n    desc: '现代 web 工程方案',\n  };\n};\n\n\n这样导出函数，则会得到一个 GET 接口。\n\n应用工程中支持了 9 个 Method\n定义，即：GET、POST、PUT、DELETE、CONNECT、TRACE、PATCH、OPTION、HEAD，即可以用这些 Method\n作为函数导出的名字。\n\n名字是大小不敏感的，就是说，如果是 GET，写成 get、Get、GEt、GET，都可以准确识别。而默认导出，即 export default xxx\n则会被映射为 Get。\n\n因为 delete 是 JavaScript 中的关键字，可以使用 del 或者 DELETE 代替。\n\n可以在一个文件中定义多个不同 Method 的函数，但如果定义多个相同 Method 的函数，则只有第一个会生效。\n\nINFO\n\n需要注意的是，定义的函数都应该是异步的，这个与函数调用时类型有关。","frontmatter":{"title":"**/*.[tj]s","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/api/api.mdx","_relativePath":"zh/apis/app/hooks/api/api.mdx"},{"id":286,"title":"_app.[tj]s","routePath":"/apis/app/hooks/api/app","lang":"zh","toc":[],"domain":"","content":"#\n\n在 BFF 函数写法下，该文件可以为 BFF 函数添加前置中间件。\n\nNOTE\n\n具体示例请参考 hook","frontmatter":{"title":"_app.[tj]s","sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/api/app.mdx","_relativePath":"zh/apis/app/hooks/api/app.mdx"},{"id":287,"title":"lambda/*.[tj]s","routePath":"/apis/app/hooks/api/lambda","lang":"zh","toc":[{"text":"路由规则","id":"路由规则","depth":2,"charIndex":162},{"text":"默认路由","id":"默认路由","depth":3,"charIndex":170},{"text":"多级路由","id":"多级路由","depth":3,"charIndex":294},{"text":"动态路由","id":"动态路由","depth":3,"charIndex":438},{"text":"白名单","id":"白名单","depth":3,"charIndex":739},{"text":"函数定义","id":"函数定义","depth":2,"charIndex":968}],"domain":"","content":"#\n\n在 BFF 框架写法下，声明 API 路由的文件。除了某些约定文件外，lambda/ 目录下的文件会被注册为接口的路由。\n\nINFO\n\n使用 api 目录需要开启 BFF 功能，需要在项目下执行 new 命令启用「BFF」功能。\n\nTIP\n\n该文件支持使用 js 或 ts 语言，但必须使用 esm 语法导出函数。\n\n\n路由规则#\n\n\n默认路由#\n\n路由系统会将以 index 命名的文件会被映射到上一层目录。\n\n * api/lambda/index.ts -> $BASENAME/\n * api/lambda/user/index.ts -> $BASENAME/user\n\n\n多级路由#\n\n路由系统也支持解析多级的文件，如果创建文件夹结构，文件仍会以相同方式自动解析路由。\n\n * api/lambda/hello.ts -> $BASENAME/hello\n * api/lambda/user/list.ts -> $BASENAME/user/list\n\n\n动态路由#\n\n路由系统支持通过 [] 命名的文件目录生成动态路由。\n\n * api/lambda/user/[username]/info.ts -> $BASENAME/user/:username/info\n * api/lambda/user/[username]/delete.ts -> $BASENAME/user/:username/delete\n * api/lambda/article/[id]/info.ts -> $BASENAME/article/:id/info\n\n其中的 $BASENAME 可以在 modern.config.js 中进行配置，默认值为 /api。\n\n\n白名单#\n\n默认 lambda 目录下所有文件都会当作 BFF 函数文件去解析，但同样我们也设置了白名单，这些文件不被被解析：\n\n * 命名以 _ 开头的文件。例如：_utils.ts。\n * 命名以 _ 开头的文件夹下所有文件。例如：_utils/index.ts、_utils/cp.ts。\n * 测试文件。例如：foo.test.ts。\n * TypeScript 类型文件。例如：hello.d.ts。\n * node_module 下的文件。\n\n\n函数定义#\n\n和函数写法下函数定义完全一致。","frontmatter":{"title":"lambda/*.[tj]s","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/api/lambda.mdx","_relativePath":"zh/apis/app/hooks/api/lambda.mdx"},{"id":288,"title":"test.[tj]s","routePath":"/apis/app/hooks/api/test","lang":"zh","toc":[],"domain":"","content":"#\n\nThe BFF test file of the application supports writing test cases in files with\nthe suffix .test.[tj]sx? under the api/ directory.\n\nINFO\n\nEnabling unit testing and integration testing requires running the new command\nto enable the \"Unit Testing/Integration Testing\" function under the project\nfirst.","frontmatter":{"title":"test.[tj]s","sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/api/test.mdx","_relativePath":"zh/apis/app/hooks/api/test.mdx"},{"id":289,"title":"html/","routePath":"/apis/app/hooks/config/html","lang":"zh","toc":[],"domain":"","content":"#\n\n通过 config/html 目录可以在内部默认 html 模板的不同位置注入自定义的 html 片段。\n\n具体使用方式请参考: 自定义 HTML","frontmatter":{"title":"html/","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/config/html.mdx","_relativePath":"zh/apis/app/hooks/config/html.mdx"},{"id":290,"title":"icon/","routePath":"/apis/app/hooks/config/icon","lang":"zh","toc":[{"text":"Favicon","id":"favicon","depth":2,"charIndex":3},{"text":"查找顺序","id":"查找顺序","depth":3,"charIndex":168},{"text":"Apple Touch Icon","id":"apple-touch-icon","depth":2,"charIndex":291},{"text":"查找顺序","id":"查找顺序-1","depth":3,"charIndex":474}],"domain":"","content":"#\n\n\nFavicon#\n\n当项目根目录的 config 目录下存在 favicon.* 文件时，Modern.js 会自动将该文件设置到 html.favicon\n配置项中，用于生成页面的 favicon 图标：\n\n./config\n└── favicon.ico\n\n\n构建完成后，可以看到 HTML 中自动生成了以下标签：\n\n\n\n\n\n查找顺序#\n\n在设置 app icon 时，Modern.js 会按以下顺序寻找文件：\n\n * favicon.png\n * favicon.jpg\n * favicon.jpeg\n * favicon.svg\n * favicon.ico\n\n\nApple Touch Icon#\n\n当项目根目录的 config 目录下存在 icon.* 文件时，Modern.js 会自动将该文件设置到 html.appIcon 配置项中，用于生成 iOS\n系统下的 Apple Touch Icon 图标。\n\n./config\n└── icon.png\n\n\n构建完成后，可以看到 HTML 中自动生成了以下标签：\n\n\n\n\n\n查找顺序#\n\n在设置 app icon 时，Modern.js 会按以下顺序寻找文件：\n\n * icon.png\n * icon.jpg\n * icon.jpeg\n * icon.svg\n * icon.ico","frontmatter":{"title":"icon/","sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/config/icon.mdx","_relativePath":"zh/apis/app/hooks/config/icon.mdx"},{"id":291,"title":"mock/","routePath":"/apis/app/hooks/config/mock","lang":"zh","toc":[],"domain":"","content":"#\n\n当项目目录下存在 config/mock/index.js 时，Modern.js 在开发环节将自动开启 Mock 服务。","frontmatter":{"title":"mock/","sidebar_position":5},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/config/mock.mdx","_relativePath":"zh/apis/app/hooks/config/mock.mdx"},{"id":292,"title":"public/","routePath":"/apis/app/hooks/config/public","lang":"zh","toc":[{"text":"说明","id":"说明","depth":2,"charIndex":51},{"text":"场景","id":"场景","depth":2,"charIndex":173},{"text":"代码压缩","id":"代码压缩","depth":2,"charIndex":331}],"domain":"","content":"#\n\npublic/ 目录中可以放置任意格式的静态资源文件，文件会被服务端部署到对应的应用域名下。\n\n\n说明#\n\n文件路由基于目录结构的约定，其中，public/ 为根目录，对应 Web 应用根路径。\n\n例如 config/public/sdk/index.js 文件，在部署后将会被部署在 ${domain}/sdk/index.js 下。\n\n\n场景#\n\n例如 robots.txt，auth.xml 等第三方系统需要的认证文件。\n\n或者是给其他业务方（要求路由不变）的 SDK，也可以是无需入口的 HTML 文件等。\n\nINFO\n\n对于需要在源码中通过 import 引用的静态资源（比如 SVG 图片），建议放到 src/assets 目录下进行管理。\n\n\n代码压缩#\n\n如果目录下的文件是一个 .js 文件，在生产环境构建时，会自动对其进行代码压缩。\n\n如果该文件以 .min.js 结尾，则不会经过代码压缩处理。","frontmatter":{"title":"public/","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/config/public.mdx","_relativePath":"zh/apis/app/hooks/config/public.mdx"},{"id":293,"title":"storybook/","routePath":"/apis/app/hooks/config/storybook","lang":"zh","toc":[],"domain":"","content":"#\n\nModern.js 支持使用 Storybook 进行调试，当需要对 Storybook 进行配置时，需要在项目 config/storybook\n目录进行配置。\n\nStorybook 配置请查看：Storybook 配置\n\nINFO\n\n使用 Storybook 进行调试需要提前在项目下执行 new 命令启用「Visual Testing (Storybook)」模式功能。","frontmatter":{"title":"storybook/","sidebar_position":7},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/config/storybook.mdx","_relativePath":"zh/apis/app/hooks/config/storybook.mdx"},{"id":294,"title":"upload/","routePath":"/apis/app/hooks/config/upload","lang":"zh","toc":[{"text":"说明","id":"说明","depth":2,"charIndex":32},{"text":"场景","id":"场景","depth":2,"charIndex":137},{"text":"代码压缩","id":"代码压缩","depth":2,"charIndex":211},{"text":"更多用法","id":"更多用法","depth":2,"charIndex":293}],"domain":"","content":"#\n\nupload/ 目录中可以放置任意格式的静态资源文件。\n\n\n说明#\n\n在开发环境下，该目录下的静态资源文件会被托管在 /upload 路径下。构建应用产物后，该目录下的文件会被复制到产物目录中。\n\n该文件约定主要用于开发者使用插件，主动上传静态资源文件到 CDN。\n\n\n场景#\n\n例如 google-analysis.js 等项目自用的 SDK（通常需要 HTTP 缓存）。\n\n图片、字体文件、通用 CSS 等。\n\n\n代码压缩#\n\n如果目录下的文件是一个 .js 文件，在生产环境构建时，会自动对其进行代码压缩。\n\n如果该文件以 .min.js 结尾，则不会经过代码压缩处理。\n\n\n更多用法#\n\n在 React 组件中，可以通过内置环境变量来添加该前缀：\n\nexport default () => {\n  return (\n    \n  );\n};\n\n\n另外，不论是在自定义 HTML 中，或是在 config/public/ 下的任意 HTML 文件中，都可以直接使用 HTML 标签引用\nconfig/upload/ 目录下的资源：\n\n\n\n\n如果设置了 dev.assetPrefix 或 output.assetPrefix 前缀，也可以直接使用模板语法添加该前缀：\n\n\n\n\nINFO\n\nModern.js 没有支持在 config/public/*.css（例如 background-image）中通过 URL 使用\nconfig/upload/ 下的文件。","frontmatter":{"title":"upload/","sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/config/upload.mdx","_relativePath":"zh/apis/app/hooks/config/upload.mdx"},{"id":295,"title":"modern.config.[tj]s","routePath":"/apis/app/hooks/modern-config","lang":"zh","toc":[],"domain":"","content":"#\n\nModern.js 配置文件, 通过该文件可以对当前项目的各个方面进行个性化配置。\n\n了解配置的具体用法，请参考配置使用。","frontmatter":{"title":"modern.config.[tj]s","sidebar_position":8},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/modern-config.mdx","_relativePath":"zh/apis/app/hooks/modern-config.mdx"},{"id":296,"title":"index.[tj]s","routePath":"/apis/app/hooks/server/index_","lang":"zh","toc":[],"domain":"","content":"#\n\n扩展 Modern.js Web Server 的文件，在此文件中可以给应用工程启动的 Web Server 添加 Hook 或 Middleware。\n\n可以对请求和响应进行拦截处理，鉴权与角色、请求预处理、异常兜底等。也可在内置处理逻辑（包括路由匹配、资源寻址、头部注入、页面渲染，静态 Web\n托管）插入特定的业务逻辑。","frontmatter":{"title":"index.[tj]s","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/server/index_.mdx","_relativePath":"zh/apis/app/hooks/server/index_.mdx"},{"id":297,"title":"test.[tj]s","routePath":"/apis/app/hooks/server/test","lang":"zh","toc":[],"domain":"","content":"#\n\n自定义 Web Server 测试目录。\n\n应用支持对自定义 Web Server 逻辑进行测试，可直接在项目 server/ 目录下创建后缀为 .test.[tj]s 文件进行编写测试用例。\n\nINFO\n\n使用单元测试、集成测试需要提前在项目下执行 new 命令启用「单元测试 / 集成测试」功能。","frontmatter":{"title":"test.[tj]s","sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/server/test.mdx","_relativePath":"zh/apis/app/hooks/server/test.mdx"},{"id":298,"title":"shared/","routePath":"/apis/app/hooks/shared","lang":"zh","toc":[],"domain":"","content":"#\n\n共享源码目录。当项目在 api/、server/、src/ 下有公共代码时，可将这些代码放到 shared 目录下，而不是直接引用。","frontmatter":{"title":"shared/","sidebar_position":5},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/shared.mdx","_relativePath":"zh/apis/app/hooks/shared.mdx"},{"id":299,"title":"App.[tj]sx","routePath":"/apis/app/hooks/src/app","lang":"zh","toc":[],"domain":"","content":"#\n\n应用使用自控路由时的入口标识符。\n\nApp.[tj]sx 并不是实际的应用入口，Modern.js 会自动生成真正的构建打包的入口文件, 内容大致如下：\n\n\n\n\n// App.[jt]sx\n\n// runtime plugin\n\n\nconst IS_BROWSER = typeof window !== 'undefined' && window.name !== 'nodejs';\nconst MOUNT_ID = 'root';\n\nlet AppWrapper = null;\n\nfunction render() {\n  AppWrapper = createApp({\n    plugins: [\n     router({...{\"serverBase\":[\"/\"]}, ...App.config?.router}),\n    ]\n  })(App)\n  if (IS_BROWSER) {\n    bootstrap(AppWrapper, MOUNT_ID, null, ReactDOM);\n  }\n  return AppWrapper\n}\n\nAppWrapper = render();\nexport default AppWrapper;\n\n\nNOTE\n\n在多入口的场景下，每个入口都可以拥有独立的 App.[jt]sx，详见入口。","frontmatter":{"title":"App.[tj]sx","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/src/app.mdx","_relativePath":"zh/apis/app/hooks/src/app.mdx"},{"id":300,"title":"index.[tj]s","routePath":"/apis/app/hooks/src/index_","lang":"zh","toc":[{"text":"在 bootstrap 之前添加自定义行为","id":"在-bootstrap-之前添加自定义行为","depth":2,"charIndex":155},{"text":"完全接管 webpack 入口","id":"完全接管-webpack-入口","depth":2,"charIndex":349}],"domain":"","content":"#\n\n应用使用自定义 bootstrap 时的入口标识。\n\n通常情况下 App.[tj]sx 钩子文件已经能满足我们的需求，当我们需要在 bootstrap 之前添加自定义行为或者完全接管 webpack\n打包入口时，可以在 src 或者入口目录下放置 index.[tj]s。 下面有分两种情况进行讨论：\n\n\n在 bootstrap 之前添加自定义行为#\n\n只需要 src/index.[tj]s 默认导出函数：\n\n\n\n\nexport default (App: React.ComponentType) => {\n  // do something before bootstrap...\n  bootstrap(App, 'root', undefined, ReactDOM);\n};\n\n\n\n完全接管 webpack 入口#\n\n当 src/index.[tj]sx? 下没有默认导出函数时，该文件即为真正的 webpack 打包入口文件, 可以直接像使用 create-react-app\n等脚手架一样组织代码：\n\n\n\n\n\nReactDOM.createRoot(document.getElementById('root')!).render();\n","frontmatter":{"title":"index.[tj]s","sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/src/index_.mdx","_relativePath":"zh/apis/app/hooks/src/index_.mdx"},{"id":301,"title":"pages/","routePath":"/apis/app/hooks/src/pages","lang":"zh","toc":[{"text":"动态路由","id":"动态路由","depth":3,"charIndex":629},{"text":"全局 layout","id":"全局-layout","depth":3,"charIndex":1236},{"text":"部分 layout","id":"部分-layout","depth":3,"charIndex":1813},{"text":"404 路由","id":"404-路由","depth":3,"charIndex":2325}],"domain":"","content":"#\n\n应用使用 Pages 入口时的入口标识。\n\nINFO\n\n兼容 Modern.js 1.0 Pages 入口，推荐使用约定式路由。\n\n当项目结构为 Pages 入口类型时， 会分析 src/pages 目录下的文件得到客户端路由配置。\n\n举例说明，例如以下目录结构：\n\n.\n└── src\n    └── pages\n        ├── about\n        │   └── index.jsx\n        ├── index.jsx\n        └── info.jsx\n\n\n对应生成的路由配置为：\n\n[\n  { path: '/', component: 'pages/index.jsx' },\n  { path: '/info' component: 'pages/info.jsx' },\n  { path: '/about', component: 'pages/about/index.jsx' }\n]\n\n\npages 目录下的文件满足以下条件的不会被当做路由文件\n\n * 后缀不是 .(j|t)sx? 的文件。\n * .d.ts 类型定义文件。\n * 以 .(test|spec|e2e).(j|t)sx? 结尾的测试文件。\n\n提示\n\n推荐 pages 目录下只写入口代码，把业务逻辑写到 pages 外面独立的 features 目录里。这样 pages\n目录下大部分文件都会是路由文件，也就不需要额外的过滤规则。\n\n\n动态路由#\n\n使用 [ ] 包裹的目录或文件会被视为动态路由\n\n例如以下目录结构:\n\n.\n└── src\n    └── pages\n        ├── [post]\n        │   ├── detail.jsx\n        │   └── index.js\n        ├── users\n        │   └── [id].jsx\n        ├── index.jsx\n        └── info.jsx\n\n\n对应生成的路由配置为:\n\n[\n  { path: '/', component: 'pages/index.jsx' },\n  { path: '/info', component: 'pages/info.jsx' },\n  { path: '/:post/', component: 'pages/[post]/index.js' },\n  { path: '/:post/detail' components: 'pages/[post]/detail.jsx'},\n  { path: '/users/:id', components: 'pages/users/[id].jsx'}\n]\n\n\n动态路由的基础上，支持添加特殊的路由后缀 (*、?、+)。\n\n例如：src/pages/users/[id]*.tsx 最终路由为 /users/:id*\n\n\n全局 layout#\n\n整个应用需要全局的 layout 时， 可以通过 pages/_app.tsx 实现，具体写法如下:\n\n\n\n\nexport const App = ({Component, ...pageProps}:{ Component: React.ComponentType}) => {\n  return (\n    \n      \n    \n  );\n}\n\n\n上述 Component 为访问具体路由匹配到的组件。\n\n例如以下目录结构:\n\n.\n└── pages\n    ├── a\n    │   ├── b\n    │   │   └── index.js\n    │   └── index.js\n    └── index.js\n\n\n * 访问 / 时，对应的 Component 组件为 pages/index.js。\n * 访问 /a 时，对应的 Component 组件为 pages/a/index.js。\n * 访问 /a/b 时，对应的 Component 组件为 pages/a/b/index.js。\n\n全局 layout 有以下优点\n * 页面变化时，保留全局布局的状态\n * 添加全局样式\n * ComponentDidCatch 错误处理\n * 使用 defineConfig 动态配置运行时配置。\n\n\n部分 layout#\n\n开发应用时，存在同一路由下的子路由共用 layout 的场景。\n\n针对这一场景，Modern.js 约定，当目录下存在 _layout.js ，就会有类似全局 layout 的效果。\n\n例如以下目录结构:\n\n└── pages\n    ├── a\n    │   ├── b\n    │   │   └── index.js\n    │   ├── _layout.js\n    │   └── index.js\n    └── index.js\n\n\n\n\nconst ALayout = ({ Component, ...pageProps }) => {\n  return ;\n};\nexport default ALayout;\n\n\nComponent 参数为访问具体路由对应的组件，例如\n\n * 访问 /a 时，对应的 Component 组件为 pages/a/index.js。\n * 访问 /a/b 时，对应的 Component 组件为 pages/a/b/index.js。\n\n这样就可以用 pages/a/_layout.js 满足 a 目录下路由共用 layout 的需求。\n\n\n404 路由#\n\n约定 pages/404.[tj]sx 为默认的 404 路由。\n\n例如以下目录结构:\n\n.\n└── src\n    └── pages\n        ├── user.js\n        ├── home.js\n        ├── 404.js\n\n\n生成路由配置如下:\n\n[\n { path: '/user', component: './pages/user.js'},\n { path: '/home', component: './pages/home.js' },\n { path: '*', component: './pages/404.js'}\n]\n\n\n所有未匹配的路由，都将匹配到 pages/404.[tj]s。","frontmatter":{"title":"pages/","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/src/pages.mdx","_relativePath":"zh/apis/app/hooks/src/pages.mdx"},{"id":302,"title":"routes/","routePath":"/apis/app/hooks/src/routes","lang":"zh","toc":[{"text":"基本示例","id":"基本示例","depth":2,"charIndex":243},{"text":"动态路由","id":"动态路由","depth":2,"charIndex":432},{"text":"布局组件","id":"布局组件","depth":2,"charIndex":756}],"domain":"","content":"#\n\n应用使用约定式路由时的入口标识。\n\n约定式路由以 routes/ 为约定的入口， 会分析 src/routes 目录下的文件得到客户端路由配置。\n\n任何在 src/routes 下的 layout.[tj]sx 和 page.[tj]sx 都会作为应用的路由：\n\n.\n└── routes\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n\n基本示例#\n\nroutes 目录下的目录名会作为路由 url 的映射，其中 layout.tsx 中作为布局组件，page.tsx\n作为内容组件，是整条路由的叶子节点，例如以下目录结构：\n\n.\n└── routes\n    ├── page.tsx\n    └── user\n        └── page.tsx\n\n\n会产出下面两条路由：\n\n * /\n * /user\n\n\n动态路由#\n\n如果路由文件的目录名以 [] 命名，生成的路由会作为动态路由。例如以下文件目录：\n\n└── routes\n    ├── [id]\n    │   └── page.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\nroutes/[id]/page.tsx 文件会转为 /:id 路由。除了可以确切匹配的 /blog 路由，其他所有 /xxx 都会匹配到该路由。\n\n在组件中，可以通过 useParams 获取对应命名的参数。\n\n在使用 loader 函数获取数据时，params 会作为 loader 函数的入参，通过 params 的属性可以获取到对应的参数。\n\n\n布局组件#\n\n如下面的例子，可以通过添加 layout.tsx，为所有路由组件添加公共的布局组件：\n\n.\n└── routes\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n在布局组件中可以通过使用 表示子组件：\n\n\n\nexport default () => {\n  return (\n    <>\n      \n    </>\n  );\n};\n\n\nNOTE\n\n是 React Router 6 中新的 API，详情可以查看 Outlet.","frontmatter":{"title":"routes/","sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/src/routes.mdx","_relativePath":"zh/apis/app/hooks/src/routes.mdx"},{"id":303,"title":"*.[server|node].[tj]sx","routePath":"/apis/app/hooks/src/server","lang":"zh","toc":[],"domain":"","content":"#\n\n应用项目中使用，用于放置服务端代码，当 *.tsx 和 *.[server|node].tsx 共存时，SSR 在服务端执行渲染时，会优先使用\n*.[server|node].tsx 文件，而不是 *.tsx 文件。","frontmatter":{"title":"*.[server|node].[tj]sx","sidebar_position":8},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/src/server.mdx","_relativePath":"zh/apis/app/hooks/src/server.mdx"},{"id":304,"title":"**/*.stories.[tj]sx","routePath":"/apis/app/hooks/src/stories","lang":"zh","toc":[],"domain":"","content":"#\n\n应用项目 Storybook 调试文件。\n\n可以在项目源码目录 src/ 下创建 *.stories.[tj]sx 格式的文件作为 Storybook 的调试文件。\n\n在项目下执行 npm run dev story 命令，支持使用这些文件在 Storybook 中对相关内容进行调试。\n\nINFO\n\n使用 Storybook 需要提前在项目下执行 new 命令启用「Visual Testing (Storybook)」模式。","frontmatter":{"title":"**/*.stories.[tj]sx","sidebar_position":7},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/src/stories.mdx","_relativePath":"zh/apis/app/hooks/src/stories.mdx"},{"id":305,"title":"**/*.test.[tj]sx?","routePath":"/apis/app/hooks/src/test","lang":"zh","toc":[],"domain":"","content":"#\n\n应用项目测试文件。\n\n应用项目支持在项目源码目录(src)下创建后缀为 .test.[tj]sx? 文件进行编写测试用例。\n\nINFO\n\n使用单元测试、集成测试需要提前在项目下执行 new 命令启用「单元测试 / 集成测试」功能。","frontmatter":{"title":"**/*.test.[tj]sx?","sidebar_position":6},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/hooks/src/test.mdx","_relativePath":"zh/apis/app/hooks/src/test.mdx"},{"id":306,"title":"defineConfig","routePath":"/apis/app/runtime/app/define-config","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":14},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":251},{"text":"参数","id":"参数","depth":3,"charIndex":308},{"text":"示例","id":"示例","depth":2,"charIndex":382}],"domain":"","content":"#\n\n用于动态配置应用。\n\n\n使用姿势#\n\n\n\n\nRuntime 配置通常可以在 modern.config.js 的 runtime 空间下配置，如 router 配置。\n\nmodern.config.js 中的配置是构建时确定的，如果一些配置参数是运行时获取的，或者配置参数是来自于源码中的一个模块（如组件），就需要使用\ndefineConfig API 进行运行时配置。\n\nINFO\n\n@modern-js/app-tools 拥有同名 API，用于为配置提供 TS 类型，请开发者加以区分。\n\n\n函数签名#\n\nfunction defineConfig(Component, config): any;\n\n\n\n参数#\n\n * Component：React.ComponentType，App 根组件。\n * config：Record，运行时的配置。\n\n\n示例#\n\nfunction App () {\n  ...\n}\n\ndefineConfig(App, {\n  router: {\n    supportHtml5History: false\n  }\n})\n\n\n 1. defineConfig 里可配置 runtime.state、runtime.router 等运行时配置。\n\n 2. defineConfig 在配置某个属性之前，如 router，需要确保 modern.config.js 已经配置开启了该功能。\n\n 3. defineConfig 传入的配置会和 modern.config.js 中的配置浅 merge，以 router 为例，最终应用的配置如下：\n\n{\n  // 来自 `modern.config.js` 配置\n  ...runtime.router\n  // 来自 `defineConfig` 配置\n  ...config.router\n}\n","frontmatter":{"sidebar_position":1,"title":"defineConfig"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/app/define-config.mdx","_relativePath":"zh/apis/app/runtime/app/define-config.mdx"},{"id":307,"title":"hook","routePath":"/apis/app/runtime/bff/hook","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":52},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":89},{"text":"参数","id":"参数","depth":3,"charIndex":203},{"text":"示例","id":"示例","depth":2,"charIndex":277}],"domain":"","content":"#\n\n用于在 BFF 函数写法下添加框架中间件，添加的中间件的执行会在 BFF 函数定义的路由之前。\n\n\n使用姿势#\n\n根据使用的框架拓展插件，从对应的命名空间中导出：\n\n\n\n\n\n函数签名#\n\ntype HookOptions = {\n  addMiddleware: string | function;\n};\n\nfunction hook(options: HookOptions): void;\n\n\n\n参数#\n\n * options: Modern.js 提供的一系列钩子。\n   * addMiddleware: 添加 BFF 中间件的钩子。\n\n\n示例#\n\n使用不同的框架，应添加不同框架的中间件（示例为使用 koa 框架时）：\n\n\n\nexport default hook(({ addMiddleware }) => {\n  addMiddleware(async (ctx, next) => {\n    ctx.req.query.id = 'koa';\n    await next();\n  });\n});\n","frontmatter":{"title":"hook"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/bff/hook.mdx","_relativePath":"zh/apis/app/runtime/bff/hook.mdx"},{"id":308,"title":"useContext","routePath":"/apis/app/runtime/bff/use-context","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":27},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":64},{"text":"示例","id":"示例","depth":2,"charIndex":100}],"domain":"","content":"#\n\n用于在一体化 BFF 函数中获取请求上下文。\n\n\n使用姿势#\n\n根据使用的框架拓展插件，从对应的命名空间中导出：\n\n\n\n\n\n函数签名#\n\nfunction useContext(): any\n\n\n示例#\n\n开发者可以通过 context 获取更多的请求信息，例如获取请求 UA（示例为使用 koa 框架时）：\n\n\n\nexport async function get() {\n  const ctx = useContext();\n  return ctx.req.headers['user-agent'];\n}\n\n\n注意\n\n只有在一体化 BFF 函数中，你才可以使用 useContext API 。\n\n使用不同的运行时框架时，虽然均支持 useContext API，但它们的返回值的类型是不同的。","frontmatter":{"title":"useContext"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/bff/use-context.mdx","_relativePath":"zh/apis/app/runtime/bff/use-context.mdx"},{"id":309,"title":"bootstrap","routePath":"/apis/app/runtime/core/bootstrap","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":59},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":117},{"text":"参数","id":"参数","depth":3,"charIndex":388},{"text":"示例","id":"示例","depth":2,"charIndex":599}],"domain":"","content":"#\n\n用于启动和挂载应用，通常情况下不做手动调用。只有在使用自定义 Bootstrap 时，才需要使用该 API。\n\n\n使用姿势#\n\n\n\n\nbootstrap(App, 'root', undefined, ReactDOM);\n\n\n\n函数签名#\n\ntype BootStrap = (\n  App: React.ComponentType,\n  id: string | HTMLElement | RuntimeContext,\n  root?: any,\n  ReactDOM?: {\n    render?: Renderer;\n    hydrate?: Renderer;\n    createRoot?: typeof createRoot;\n    hydrateRoot?: typeof hydrateRoot;\n  },\n) => Promise;\n\n\n\n参数#\n\n * AppComponent：通过 createApp 创建的 ReactElement 实例。\n * id：要挂载的 DOM 根元素 id，如 \"root\"。\n * root: ReactDOM.createRoot 的返回值，用于 bootstrap 函数外需要 root 销毁组件的场景。\n * ReactDOM: ReactDOM 对象，用于区分 React 18 和 React 17 API。\n\n\n示例#\n\n\n\n\nfunction App() {\n  return \nHello Modern.js;\n}\n\nconst WrappedApp = createApp({\n  // 传入自定义插件\n  plugins: [customPlugin()],\n})(App);\n\nbootstrap(WrappedApp, 'root', undefined, ReactDOM);\n\n\nINFO\n\n由于 @modern-js/runtime/plugins 是别名处理的，在 ts 项目中使用时需要声明其类型， 只需要在\nsrc/modern-app-env.d.ts 添加以下类型声明即可：\n\ndeclare module '@modern-js/runtime/plugins';\n\n\nWARNING\n\nbootstrap 只支持在 CSR 场景下使用。","frontmatter":{"title":"bootstrap"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/core/bootstrap.mdx","_relativePath":"zh/apis/app/runtime/core/bootstrap.mdx"},{"id":310,"title":"createApp","routePath":"/apis/app/runtime/core/create-app","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":49},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":60},{"text":"参数","id":"参数","depth":3,"charIndex":145},{"text":"示例","id":"示例","depth":2,"charIndex":194},{"text":"创建自定义入口","id":"创建自定义入口","depth":3,"charIndex":200}],"domain":"","content":"#\n\n用于创建自定义入口，定制运行时插件。只有在使用自定义 App 时，才需要使用该 API。\n\n\n使用姿势#\n\n\n\n\n\n函数签名#\n\n\n\nfunction createApp(options: { plugins: Plugin[] }): React.ComponentType;\n\n\n\n参数#\n\n * options: 可选的参数。\n   * plugins：自定义的插件扩展。\n\n\n示例#\n\n\n创建自定义入口#\n\n详见 bootstrap。","frontmatter":{"title":"createApp"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/core/create-app.mdx","_relativePath":"zh/apis/app/runtime/core/create-app.mdx"},{"id":311,"title":"useLoader","routePath":"/apis/app/runtime/core/use-loader","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":121},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":132},{"text":"参数","id":"参数","depth":3,"charIndex":633},{"text":"返回值","id":"返回值","depth":3,"charIndex":929},{"text":"示例","id":"示例","depth":2,"charIndex":1135}],"domain":"","content":"#\n\n一个同构的 API，通常会用来做异步请求。当 SSR 的时候，服务端使用 useLoader 预加载数据，同时浏览器端也会复用这部分数据。\n\nTIP\n\n在使用 Rspack 作为打包工具时，暂不支持使用 useLoader API。\n\n\n使用姿势#\n\n\n\n\n\n函数签名#\n\ntype LoaderFn = (context: runtimeContext) => Promise;\ntype Options = {\n  onSuccess: (data: Record) => void;\n  onError: (error: Error) => void;\n  initialData: Record;\n  skip: boolean;\n  params: Record;\n  static: boolean;\n};\ntype ReturnData = {\n  data: Record;\n  loading: boolean;\n  error: Error;\n  reload: (params?: Record) => Promise | undefined;\n  reloading: boolean;\n};\n\nfunction useLoader(loaderFn: LoaderFn, options: Options): ReturnData;\n\n\nINFO\n\nruntimeContext 类型可以参考 useRuntimeContext。\n\n\n参数#\n\n * loaderFn：用于加载数据的函数，返回 Promise。\n * options：可选配置项。\n   * onSuccess：执行成功的回调。\n   * onError：执行失败的回调。\n   * initialData：首次执行前的初始数据，对应返回值中的 data 字段。\n   * skip：当值为 true 时，函数不执行。\n   * params：当 params 序列化结果发生改变时，函数会重新执行。同时，params 也会作为函数的第二个参数被传入。\n   * static：当值为 true 时，useLoader 用于 SSG 编译阶段数据的获取。\n\n\n返回值#\n\n * data：执行成功时的返回数据。\n * loading：表示函数是否处于执行过程中。\n * error：函数执行失败时的错误信息。\n * reload：调用后可以重新执行函数。\n   * params：当值为 undefined 时，函数执行时将复用上次的值；否则会使用新的值重新执行函数。\n * reloading：调用 reload 的执行过程中，reloading 值为 true。\n\n\n示例#\n\nfunction Container() {\n  const { data, error, loading } = useLoader(\n    async (context, params) => {\n      console.log(params) // nicole\n      return fetch(user);\n    },\n    {\n      onSuccess: data => {\n        console.log('I did success:(',  data);\n      },\n      onError: error => {\n        console.log('I met error:)',  error);\n      },\n      initialData: { name: 'nicole', gender: 'female' },\n      params: 'nicole'\n    }\n  );\n\n  return ...;\n}\n","frontmatter":{"title":"useLoader"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/core/use-loader.mdx","_relativePath":"zh/apis/app/runtime/core/use-loader.mdx"},{"id":312,"title":"useModuleApps","routePath":"/apis/app/runtime/core/use-module-apps","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":36},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":47},{"text":"示例","id":"示例","depth":2,"charIndex":115},{"text":"集中式路由","id":"集中式路由","depth":3,"charIndex":1365},{"text":"加载动画","id":"加载动画","depth":2,"charIndex":2265}],"domain":"","content":"#\n\n返回所有微前端子应用的 React 组件，用于可自由控制路由。\n\n\n使用姿势#\n\n\n\n\n\n函数签名#\n\nfunction useModuleApps(): Record>\n\n分别返回包裹每个子应用后的 React 组件。\n\n\n示例#\n\n需要先配置微前端子应用信息。\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n这里演示主应用为自控式路由的场景，全部场景参考 体验微前端\n\nfunction App() {\n  const { apps, MApp, Table, Dashboard } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      }>\n        } />\n        } />\n      \n    )\n  );\n\n  return (\n    // 方法一：使用 MApp 自动根据配置的 activeWhen 参数加载子应用(本项目配置在 modern.config.ts 中)\n    // \n    //   \n    // \n\n    // 方法二：手动写 Route 组件方式加载子应用，方便于需要鉴权等需要前置操作的场景\n    <>\n      \n    </>\n  );\n}\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [\n      {\n        // name 区分大小写，name 提供的是什么 useModuleApps 返回的就是什么\n        name: 'Table',\n        entry: 'http://127.0.0.1:8081/',\n      },\n      {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082',\n      },\n    ],\n  },\n});\n\n\n通过 useModuleApps() 获取到 Table 和 Dashboard 子应用组件（名称和配置里的 name 字段对应），之后就可以像使用普通的\nReact 组件一样去加载子应用。\n\n\n集中式路由#\n\n集中式路由 是将子应用的激活路由集中配置的方式。我们给子应用列表信息添加 activeWhen 字段来启用 集中式路由。\n\n\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [{\n      name: 'Table',\n      entry: 'http://localhost:8001',\n      // activeWhen: '/table'\n    }, {\n      name: 'Dashboard',\n      entry: 'http://localhost:8002'\n      // activeWhen: '/dashboard'\n    }]\n  },\n});\n\n\n然后在主应用中使用 useModuleApp 方法获取 MApp 组件, 并在主应用渲染 MApp。\n\n\n\nfunction App() {\n  const { MApp } = useModuleApps();\n\n  return (\n    \n\n      \n    \n  );\n}\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [\n      {\n        // name 区分大小写，name 提供的是什么 useModuleApps 返回的就是什么\n        name: 'Table',\n        activeWhen: '/table',\n        entry: 'http://127.0.0.1:8081/',\n      },\n      {\n        name: 'Dashboard',\n        activeWhen: '/dashboard',\n        entry: 'http://localhost:8082',\n      },\n    ],\n  },\n});\n\n\n这样启动应用后，访问 /dashboard 路由，会渲染 Dashboard 子应用，访问 /table 路由，会渲染 Table 子应用。\n\n\n加载动画#\n\n可以通过以下方式，自定义组件加载过程的过渡动画。\n\n\n\n\n\nconst AppLayout = () => (\n  <>\n    \n加载约定式路由子应用\n    \n加载自控式路由子应用\n    \n卸载子应用\n    \n  </>\n)\n\nexport default () => {\n  const { apps } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      }>\n        {apps.map(app => {\n          const { Component } = app;\n          // 模糊匹配，path 需要写成类似 abc/* 的模式\n          return (\n             {\n                    if (error) {\n                      return \nerror: {error?.message};\n                    } else if (pastDelay) {\n                      return \nloading;\n                    } else {\n                      return null;\n                    }\n                  },\n                }}\n              />\n              }\n            />\n          )\n        })}\n      \n    )\n  );\n\n  return (\n    <>\n      \n    </>\n  );\n};\n","frontmatter":{"title":"useModuleApps"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/core/use-module-apps.mdx","_relativePath":"zh/apis/app/runtime/core/use-module-apps.mdx"},{"id":313,"title":"useRuntimeContext","routePath":"/apis/app/runtime/core/use-runtime-context","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":38},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":145},{"text":"返回值","id":"返回值","depth":3,"charIndex":407},{"text":"示例","id":"示例","depth":2,"charIndex":724}],"domain":"","content":"#\n\n该函数主要用于获取 Runtime 上下文，只能在函数组件中使用。\n\n\n使用姿势#\n\n\n\nexport function App() {\n  const runtimeContext = useRuntimeContext();\n  return \nHello World;\n}\n\n\n\n函数签名#\n\ntype RuntimeContext = {\n  request: {\n    params: Record;\n    pathname: string;\n    query: Record;\n    headers: IncomingHttpHeaders;\n    cookie: string;\n  };\n  store: ReduckStore;\n  router: RemixRouter;\n};\n\nfunction useRuntimeContext(): RuntimeContext;\n\n\n\n返回值#\n\n * request：请求上下文中的附加信息。\n   * params：请求路径中的动态参数。\n   * pathname：请求的 pathname。\n   * query：请求的查询字符串对象。\n   * headers：请求头信息。\n   * cookie：请求的 cookie 信息。\n * store：在开启了 state 插件的时候，该值为 Reduck 全局 store。\n * router：在开启 router 插件的时候存在。\n   * location：当前路由对应的位置信息。同 useLocation 返回值。\n   * navigate：导航到给定路径。同 useNavigate 返回值。\n\n\n示例#\n\n\n\n\nfunction App() {\n  const { store } = useRuntimeContext();\n\n  const [state, actions] = store.use(fooModel);\n\n  return \nstate: {state};\n}\n","frontmatter":{"title":"useRuntimeContext"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/core/use-runtime-context.mdx","_relativePath":"zh/apis/app/runtime/core/use-runtime-context.mdx"},{"id":314,"title":"Provider","routePath":"/apis/app/runtime/model/Provider","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":212},{"text":"参数","id":"参数","depth":3,"charIndex":295},{"text":"示例","id":"示例","depth":2,"charIndex":392}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nProvider 是一个组件，它将 Reduck 的 Store 注入到应用的组件树中，使组件树内部的组件可以访问 Model。一般情况下，Provider\n会定义在组件树的最顶层。\n\n\n函数签名#\n\ninterface ProviderProps {\n  store?: ReduckStore;\n  config?: AppConfig;\n}\n\n\n\n参数#\n\n * store：createStore 创建的 Store 对象。\n * config：创建 Reduck Store 的配置，同 createApp 的 config 参数。\n\n\n示例#\n\nReactDOM.render(\n  \n    \n  ,\n  document.getElementById('root'),\n);\n","frontmatter":{"sidebar_position":8,"title":"Provider"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/Provider.mdx","_relativePath":"zh/apis/app/runtime/model/Provider.mdx"},{"id":315,"title":"Auto actions","routePath":"/apis/app/runtime/model/auto-actions","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":229},{"text":"基础数据类型","id":"基础数据类型","depth":3,"charIndex":235},{"text":"数组 Array","id":"数组-array","depth":3,"charIndex":602},{"text":"简单对象 PlainObject","id":"简单对象-plainobject","depth":3,"charIndex":1500}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nReduck 可以根据 State 的类型，自动生成相应的 Actions，为修改 State 提供便利。\n\n提示\n\n可通过 runtime.state.autoActions 关闭 auto actions 功能。\n\n\n示例#\n\n\n基础数据类型#\n\nState 类型为 string、number、boolean、null 时，生成 setState Action。\n\nconst fooModel = model('foo').define({\n  state: 1,\n});\n\nfunction App() {\n  const [state, actions] = useModel(fooModel);\n\n  return (\n    \n\n      \nState: {state}\n       {\n          // 调用自动生成的 setState Action\n          actions.setState(state + 1);\n        }}\n      >\n        add\n      \n    \n  );\n}\n\n\n\n数组 Array#\n\nState 类型为 Array 时，生成下列 Actions：\n\n * push：将一个或多个元素添加到数组的末尾。\n * pop：从数组中删除最后一个元素。\n * shift：从数组中删除第一个元素。\n * unshift：将一个或多个元素添加到数组的开头。\n   * 语法：arr.unshift(element1, ..., elementN)\n   * elementN：要添加到数组开头的元素或多个元素。\n * filter：过滤元素。\n\n * concat：拼接数组。\n\n * splice：通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回修改后的数组（注意和原生 splice 返回值不同）。\n   * 语法：splice(start[, deleteCount[, item1[, item2[, ...]]]])\n   * start：指定修改的开始位置（从 0 计数）。\n   * deleteCount：可选，整数，表示要移除的数组元素的个数。\n   * item, item2, ...：可选，要添加进数组的元素，从 start 位置开始。如果不指定，则 splice 将只删除数组元素。\n\nconst fooModel = model('foo').define({\n  state: [1, 2, 3],\n});\n\nfunction App() {\n  const [state, actions] = useModel(fooModel);\n\n  useEffect(() => {\n    actions.push(4);\n    actions.pop();\n    actions.shift(0);\n    actions.unshift();\n    actions.filter(val => val <= 2);\n    actions.splice(0, 1, 1, 2);\n  }, []);\n\n  return (\n    \n\n      \nState: {state}\n    \n  );\n}\n\n\n\n简单对象 PlainObject#\n\nState 类型为 PlainObject 时，根据 State 包含的属性名，生成 set${key}（小驼峰命名）Actions。\n\nconst fooModel = model('foo').define({\n  state: {\n    a: 1,\n    b: { value: 1 },\n    c: 'c',\n  },\n});\n\nfunction App() {\n  const [state, actions] = useModel(fooModel);\n\n  useEffect(() => {\n    actions.setA(2);\n    actions.setB({ value: 2 });\n    actions.setC('d');\n  }, []);\n\n  return (\n    \n\n      \nState: {state}\n    \n  );\n}\n","frontmatter":{"sidebar_position":6,"title":"Auto actions"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/auto-actions.mdx","_relativePath":"zh/apis/app/runtime/model/auto-actions.mdx"},{"id":316,"title":"connect","routePath":"/apis/app/runtime/model/connect","lang":"zh","toc":[{"text":"类型","id":"类型","depth":2,"charIndex":249},{"text":"参数","id":"参数","depth":2,"charIndex":621},{"text":"返回值","id":"返回值","depth":2,"charIndex":1335},{"text":"示例","id":"示例","depth":2,"charIndex":1402},{"text":"简单用法","id":"简单用法","depth":3,"charIndex":1408},{"text":"筛选 State 和 Actions","id":"筛选-state-和-actions","depth":3,"charIndex":2000},{"text":"转发组件的 ref","id":"转发组件的-ref","depth":3,"charIndex":2411}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n提示\n\nReduck 原始类型较为复杂，以下涉及类型定义的地方，展示的是简化后的类型信息。原始类型见 connect。\n\nconnect 功能上同 useModel 一致，是对应的 HOC 风格的 API。建议优先使用 Hook 风格的 useModel。\n\n\n类型#\n\ntype SelectStateToProps = (\n  ...modelStates: State[],\n  ownProps?: any,\n) => PlainObject;\ntype SelectActionsToProps = (\n  ...modelActions: Actions[],\n  ownProps?: any,\n) => PlainObject;\n\nfunction connect(models: Model, options?: ConnectOptions);\nfunction connect(\n  models: [...Model[], SelectStateToProps?, SelectActionsToProps?],\n  options?: ConnectOptions,\n);\n\n\n\n参数#\n\n * models：传入的 1 个或多个 Model，当 models 为数组类型参数时，最后两项元素可以是用于筛选 State 的函数（\n   SelectStateToProps 类型）和用于筛选 Actions 的函数（ SelectActionsToProps 类型）。\n   \n   * SelectStateToProps： modelStates 是传入的 Model 对象的 State 组成的数组，ownProps\n     是当前组件接收外部传递的 props，SelectStateToProps 返回的数据会传递到组件的 props 上。当 models 中没有传入\n     SelectStateToProps 参数时，所有 Model 的 State 进行合并后传递到组件的 props 上。\n   * SelectActionsToProps： modelActions 是传入的 Model 对象的 Actions 组成的数组，ownProps\n     是当前组件接收外部传递的 props，SelectActionsToProps 返回的数据也会传递到组件的 props 上。当 models\n     中没有传入 SelectActionsToProps 参数时，所有 Model 的 Actions 进行合并后传递到组件的 props 上。\n\n * options：可选参数，用于辅助配置。目前支持设置 forwardRef，用于控制是否转发组件的 ref，默认值为 false，表示不转发\n   ref。设置为 {forwardRef: true}，表示转发 ref。\n\n\n返回值#\n\n返回一个高阶组件：接收一个传入的组件，返回一个在 props 上注入了额外 State 和 Actions 的组件。\n\n\n示例#\n\n\n简单用法#\n\nconst modelA = model('modelA').define({\n  state: {\n    a: 1,\n  },\n  actions: {\n    incA(state) {\n      return {\n        ...state,\n        a: state.a + 1,\n      };\n    },\n  },\n});\n\nconst modelB = model('modelB').define({\n  state: {\n    b: 10,\n  },\n  actions: {\n    incB(state) {\n      return {\n        ...state,\n        b: state.b + 1,\n      };\n    },\n  },\n});\n\nfunction Test(props) {\n  props.incA(); // 调用 modelA 的 action\n  props.incB(); // 调用 modelB 的 action\n\n  props.a; // 获取 modelA 的 state: a\n  props.b; // 获取 modelB 的 state: b\n}\n\nexport default connect([modelA, modelB])(Test);\n\n\n\n筛选 State 和 Actions#\n\nfunction Test(props) {\n  props.incAll();\n  props.c;\n}\n\nconst stateSelector = (stateA, stateB) => ({\n  ...stateA,\n  ...stateB,\n  c: stateA.a + stateA.b,\n});\nconst actionsSelector = (actionsA, actionsB) => ({\n  ...actionsA,\n  ...actionsB,\n  incAll: () => {\n    actionsA.incA();\n    actionsB.incB();\n  },\n});\n\nexport default connect([modelA, modelB, stateSelector, actionsSelector])(Test);\n\n\n\n转发组件的 ref#\n\n\n\nfunction Test(props, ref) {\n  const { a, b } = props;\n\n  return (\n    \n\n      {a}\n      {b}\n    \n  );\n}\n\nconst TestWrapper = connect([modelA, modelB], { forwardRef: true })(\n  forwardRef(Test),\n);\n\nfunction App() {\n  const testRef = useRef();\n\n  return ;\n}\n","frontmatter":{"sidebar_position":5,"title":"connect"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/connect.mdx","_relativePath":"zh/apis/app/runtime/model/connect.mdx"},{"id":317,"title":"createApp","routePath":"/apis/app/runtime/model/create-app","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":348},{"text":"参数","id":"参数","depth":3,"charIndex":515},{"text":"返回值","id":"返回值","depth":3,"charIndex":706},{"text":"示例","id":"示例","depth":2,"charIndex":1008}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nReduck 内部默认会使用 createApp 创建一个全局应用，如果整个应用只需要共享一个 Store，那么是不需要使用 createApp\n的。只有当需要在应用局部创建共享 Store 时，才需要使用 createApp。\n\n注意\n\n注意 @modern-js/runtime/model 中导出的 createApp 用于管理状态，而 @modern-js/runtime 导出的\ncreateApp 用于管理整个应用的运行时环境，两者功能不同。\n\n\n函数签名#\n\ninterface AppConfig extends StoreConfig {\n  devTools?: boolean | DevToolsOptions;\n  autoActions?: boolean;\n}\n\nfunction createApp(config: AppConfig): object;\n\n\n\n参数#\n\n * config：Record\n   * StoreConfig：同 createStore 的参数。\n   * devTools：默认值为 true。是否开启 Redux DevTools，当为对象类型时，支持配置 Redux DevTools 的\n     Options。\n   * autoActions：默认值为 true。是否自动生成 Actions。\n\n\n返回值#\n\nReduck App，有以下属性组成：\n\n * Provider：为应用局部的组件树注入共享 Store 的组件。用法同 Provider。\n * useModel：获取应用局部 Store 挂载的 Model 对象。用法同 useModel。\n * useStaticModel：获取应用局部 Store 挂载的 Model 对象。用法同 useStaticModel。\n * useLocalModel：获取应用局部 Store 挂载的 Model 对象。用法同 useLocalModel。\n * useStore：获取应用局部使用的 Store 对象。用法同 useStore。\n\n\n示例#\n\n通过 createApp 可以创建局部状态，将不同 Reduck 应用间的状态隔离。\n\nconst { Provider: LocalFooProvider, useModel: useLocalFooModel } = createApp();\nconst { Provider: LocalBarProvider, useModel: useLocalBarModel } = createApp();\n\nfunction Foo() {\n  const [fooState] = useLocalFooModel(fooModel);\n  const [barState] = useLocalBarModel(fooModel);\n\n  return (\n    \n\n      \nFoo: {fooState}\n      \nBar: {barState}\n    \n  );\n}\n\nfunction Container() {\n  return (\n    \n      \n        \n      \n    \n  );\n}\n","frontmatter":{"sidebar_position":11,"title":"createApp"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/create-app.mdx","_relativePath":"zh/apis/app/runtime/model/create-app.mdx"},{"id":318,"title":"createStore","routePath":"/apis/app/runtime/model/create-store","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":301},{"text":"参数","id":"参数","depth":3,"charIndex":627},{"text":"返回值","id":"返回值","depth":3,"charIndex":873},{"text":"示例","id":"示例","depth":2,"charIndex":1046}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\ncreateStore 用于创建一个 Store 对象。Reduck 的 Store 基于 Redux 的 Store\n实现，用于存储应用的状态，同时提供一组用于管理状态和 Model 的方法。\n\n一般情况下，不需要使用这个 API，只有需要完全掌控 Store 的创建时，才会使用这个 API。例如，自定义一个 Store，传入 Provider\n组件使用。\n\n\n函数签名#\n\ninterface StoreConfig {\n  initialState?: Record;\n  middlewares?: Middleware[];\n  models?: Model[];\n  plugins?: Plugin[];\n  enhancers?: StoreEnhancer[];\n}\n\ninterface ReduckStore extends ReduxStore {\n  use: typeof useModel;\n  unmount: (model: Model) => void;\n}\n\nfunction createStore(config: StoreConfig): ReduckStore;\n\n\n\n参数#\n\n * config?：store 配置选项\n   * initialState?: 设置全局 Store 的初始状态。\n   * models?: 设置提前（Store 创建后）挂载到 Store 的 Model。（正常使用无需提前挂载）\n   * middlewares?: 设置 Redux 中间件。\n   * enhancers?: 设置 Redux 的 Store enhancer 。\n   * plugins?: 设置 Reduck 插件。试验性配置，不推荐使用。\n\n\n返回值#\n\nReduck Store 对象：\n\n * use：动态挂载和获取 Model 对象。用法与 useModel 相同，但可以在 React 组件外使用。\n * unmount：卸载 Model 对象，Model 的 State 会从 Store 中清除。\n * ReduxStore：Redux Store 对象具有的方法，详见。\n\n\n示例#\n\nconst store = createStore();\n\nfunction load() {\n  const [, actions] = store.use(fooModel);\n\n  actions.load();\n}\n","frontmatter":{"sidebar_position":10,"title":"createStore"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/create-store.mdx","_relativePath":"zh/apis/app/runtime/model/create-store.mdx"},{"id":319,"title":"handleEffect","routePath":"/apis/app/runtime/model/handle-effect","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":441},{"text":"参数","id":"参数","depth":3,"charIndex":782},{"text":"返回值","id":"返回值","depth":3,"charIndex":1979}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n一个异步函数类型的 Effect，通常有三种需要处理的状态: 请求中、请求成功、请求处理失败。这些状态处理的方式，就是编写对应的 Action\n函数(pending、fulfilled、rejected)。\n\n借助 handleEffect API，我们可以生成默认的 Action 函数来处理异步请求各个阶段的不同结果。handleEffect 生成的 Action\n返回的 State 的结构如下：\n\ninterface State {\n  result: any; // 存储 fulfilled 状态的返回结果\n  pending: boolean; // 请求是否结束\n  error: string; // 请求失败的结果\n}\n\n\n\n函数签名#\n\ninterface EffectActions {\n  pending: Action;\n  fulfilled: Action;\n  rejected: Action;\n}\n\ninterface Config {\n  ns?: string;\n  result?: string | false;\n  error?: string | false;\n  pending?: string | false;\n  combineMode?: 'merge' | 'replace';\n  omitResultNamespace?: boolean;\n}\n\nfunction handleEffect(config: Config): EffectActions;\n\n\n\n参数#\n\n * ns：默认返回的 State 结构扁平地挂载到 Model 的 State 上，通过设置该参数可以将返回的 State 挂载到 ns\n   值命名的字段下。例如，ns 设置为 data，返回的 State 结构为：\n\ninterface State {\n  data: {\n    pending: boolean;\n    result: any;\n    error: string;\n  };\n}\n\n\n * result：默认值为 \"result\"。该参数对应存储异步请求 fulfilled 状态结果的字段名称。例如，设置 result 为\n   \"items\"，返回的 State 结构为：\n\ninterface State {\n  items: any; // 默认的 result -> items\n  pending: boolean;\n  error: string;\n}\n\n\nresult 为 false，返回的 State 结构中不存在 result：\n\ninterface State {\n  pending: boolean;\n  error: string;\n}\n\n\n * pending：默认值为 \"pending\"。改变返回 State 中的 pending 字段名。用法同上。\n\n * error： 默认值为 \"error\"。改变返回 State 中的 error 字段名。用法同上。\n\n * combineMode：默认值为 \"merge\"。获取 fulfilled 状态的返回数据后，对 result 的处理方式：merge（合并）和\n   replace（替换）。这里能自动处理的数据类型也仅限为简单的对象或者数组类型。\n   \n   * merge：前一次的数据与当前的数据合并。数据为数组类型，内部操作类似于 [].concat(lastData,\n     currentData)；数据为对象类型，内部操作类似于 {...lastData, ...curData}。\n   * replace：当前的数据直接替换之前的数据。\n\n * omitResultNamespace：默认值为 \"false\"。当异步请求的结果为对象类型，希望把该结果直接挂载到 Model 的 State\n   上，而不是挂载到 \"result\" 上，可以设置为 true。例如：\n\n// 一个异步请求得到的数据为一个对象：{user: 'xx', email: 'xx'}，\n// 配置 handleEffect({ omitResultNamespace: true })\n// 则得到的 State 结构如下：\n{\n  user: 'xx',\n  email: 'xx',\n  pending: false,\n  error: null,\n}\n\n\n\n返回值#\n\n分别处理 pending、fulfilled、rejected 三种状态的 Action 组成的对象。\n\n更多参考\n\n副作用管理","frontmatter":{"sidebar_position":7,"title":"handleEffect"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/handle-effect.mdx","_relativePath":"zh/apis/app/runtime/model/handle-effect.mdx"},{"id":320,"title":"model","routePath":"/apis/app/runtime/model/model_","lang":"zh","toc":[{"text":"model","id":"model-1","depth":2,"charIndex":-1},{"text":"define","id":"define","depth":2,"charIndex":308},{"text":"对象类型","id":"对象类型","depth":3,"charIndex":356},{"text":"函数类型","id":"函数类型","depth":3,"charIndex":756},{"text":"参数","id":"参数","depth":3,"charIndex":1691},{"text":"ModelDesc.state","id":"modeldescstate","depth":4,"charIndex":1696},{"text":"ModelDesc.actions","id":"modeldescactions","depth":4,"charIndex":1812},{"text":"ModelDesc.computed","id":"modeldesccomputed","depth":4,"charIndex":2064},{"text":"ModelDesc.effects","id":"modeldesceffects","depth":4,"charIndex":2618}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n提示\n\nReduck 原始类型较为复杂，以下涉及类型定义的地方，展示的是简化后的类型信息。原始类型见 model。\n\n\nmodel#\n\n用于创建管理应用状态的 Model。\n\nfunction model(name: string): { define: function }\n\n * name：string，创建的 Model 的唯一标识。\n\nmodel('foo');\n\n\n\ndefine#\n\n用于定义 Model 的详细结构，支持传入一个对象类型或函数类型的参数。\n\n\n对象类型#\n\nfunction define(modelDesc: ModelDesc): Model;\n\n * modelDesc: ModelDesc，对 Model 结构的定义，包含 state、computed、actions、effects 等属性。\n\nconst fooModel = model('foo').define({\n  state: 'foo',\n  computed: {\n    cFoo: state => `c${state}`,\n  },\n  actions: {\n    setState: (state, value) => {\n      return value;\n    },\n  },\n  effects: {\n    loadState: async () => {\n      // 从服务端获取 state\n    },\n  },\n});\n\n\n\n函数类型#\n\nfunction define((context: Context, utils: Utils) => ModelDesc): Model;\n\n * context: Context，Reduck 上下文对象，可以获取底层的 store 对象。store 除支持 Redux Store 的所有 API\n   以外，还挂载了用于消费 Model 的 use 的方法，和用于卸载 Model 的 unmount 方法。\n * utils: Utils，定义 Model 时，常用的工具函数：use、onMount。use 作用同 store 对象上的 use，onMount 是\n   Model 挂载后的钩子函数。\n\ninterface Utils {\n  use: UseModel;\n  onMount: OnMountHook;\n}\n\ninterface Context {\n  store: ReduxStore & {\n    use: UseModel;\n    unmount: (model: Model) => void;\n  };\n}\n\n\n如通过 use，可以获取 Model 自身及其它 Model 的 state，actions。\n\nconst fooModel = model('foo').define(() => {\n  return {\n    state: 'foo',\n    actions: {\n      setState: (state, value) => {\n        return value;\n      },\n    },\n  };\n});\n\nconst barModel = model('bar').define((_, { use }) => {\n  return {\n    state: 'bar',\n    effects: {\n      syncFoo() {\n        const [state, actions] = use(fooModel);\n        actions.setState(state);\n      },\n    },\n  };\n});\n\n\n\n参数#\n\nModelDesc.state#\n\n定义 Model 的状态。技术上，支持任意类型的 State，但是实践中建议使用可进行 JSON 序列化的类型。\n\ninterface ModelDesc {\n  state: any;\n}\n\n\nModelDesc.actions#\n\n定义 Model 的 Actions。Actions 的函数类型为：\n\ninterface ModelDesc {\n  actions: {\n    [actionKey: string]: (state: State, payload: any) => State | void;\n  };\n}\n\n\nReduck 内部集成了 immer，可以直接原始的 state，当 Action 没有显式返回值时，Reduck 内部会返回修改过的新的 State 对象。\n\nModelDesc.computed#\n\n定义 Model 的衍生状态。衍生状态的定义支持两种类型：\n\n 1. 只依赖 Model 自身的状态\n\ninterface ModelDesc {\n  computed: {\n    [computedKey: string]: (state: State) => any;\n  };\n}\n\n\n 2. 依赖其他 Model 的状态\n\ninterface ModelDesc {\n  computed: {\n    [computedKey: string]: [\n      ...models: Model[],\n      (state: State, ...args: ModelState[]) => any,\n    ];\n  };\n}\n\n\nconst fooModel = model('foo').define({\n  state: 'foo',\n});\n\nconst barModel = model('bar').define({\n  state: 'bar',\n  computed: {\n    combineFoo: [fooModel, (state, fooState) => state + fooState],\n  },\n});\n\n\nModelDesc.effects#\n\n定义 Model 的 Effects。Effects 中定义的函数类型为：\n\ninterface ModelDesc {\n  effects: {\n    [effectKey: string]: (...args: any[]) => any;\n  };\n}\n\n\nconst fooModel = model('foo').define((context, { use }) => ({\n  state: 'foo',\n  effects: {\n    persist() {\n      const [state] = use(fooModel);\n      localStorage.setItem('state', state);\n    },\n  },\n}));\n\n\n更多参考\n\n创建 Model","frontmatter":{"sidebar_position":1,"title":"model"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/model_.mdx","_relativePath":"zh/apis/app/runtime/model/model_.mdx"},{"id":321,"title":"useLocalModel","routePath":"/apis/app/runtime/model/use-local-model","lang":"zh","toc":[{"text":"示例","id":"示例","depth":4,"charIndex":224}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n用于把 Model 中的 State 作为局部状态使用，效果类似 React 的 useState。useLocalModel API 形式上与\nuseModel 完全一致。具体使用请参考 useModel。\n\n示例#\n\nfunction Container() {\n  const [state, actions] = useLocalModel(modelA);\n  const [state1, actions1] = useLocalModel(modelA);\n\n  // ...\n}\n\n\n上面通过 useLocalModel 加载了两次 modelA，因为 useLocalModel 消费的是局部状态，所以 state 和 state1\n也是完全隔离的。\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":4,"title":"useLocalModel"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/use-local-model.mdx","_relativePath":"zh/apis/app/runtime/model/use-local-model.mdx"},{"id":322,"title":"useModel","routePath":"/apis/app/runtime/model/use-model","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":178},{"text":"参数","id":"参数","depth":3,"charIndex":494},{"text":"返回值","id":"返回值","depth":3,"charIndex":761},{"text":"示例","id":"示例","depth":2,"charIndex":1190},{"text":"基本用法","id":"基本用法","depth":3,"charIndex":1196},{"text":"selector 用法","id":"selector-用法","depth":3,"charIndex":1513}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n提示\n\nReduck 原始类型较为复杂，以下涉及类型定义的地方，展示的是简化后的类型信息。原始类型见 model。\n\n\n函数签名#\n\nfunction useModel(\n  models: Models[],\n  stateSelector?: StateSelector,\n  actionSelector?: ActionSelector,\n): [state, actions, subscribe];\nfunction useModel(\n  ...models: Models[],\n  stateSelector?: (...args: State[]) => any,\n  actionSelector?: (...args: Actions[]) => any,\n): [state, actions, subscribe];\n\n\n\n参数#\n\n * models：Model 对象数组，可以作为一个数组类型的参数传入，也可以所有 Model 逐个作为参数传入。\n * stateSelector：可选参数，用于筛选 State 计算。前 n 个参数为 n 个 Model 对应的 State，返回的数据作为\n   useModel 返回值数组的第一个元素。\n * actionSelector：可选参数，用于筛选 Actions 计算。前 n 个参数为 n 个 Model 对应的 Actions，返回的数据作为\n   useModel 返回值数组的第二个元素。\n\n\n返回值#\n\n返回一个数组，每一项元素分别为：\n\n * state：stateSelector 的返回值。如果未传 stateSelector，会把传入的所有 Model 的 State\n   (包含衍生状态)合并后返回。如果不同 Model 的 State 中存在同名属性，后面的 State 会覆盖前面的 State。当 state\n   发生变化时，调用 useModel 的组件会重新渲染。\n * actions：第二个元素为 actionSelector 的返回值。如果未传 actionSelector，会把传入的所有 Model 的\n   Actions (包含 Effects) 合并后返回。如果不同 Model 的 Actions 中存在同名属性，后面的 Actions 会覆盖前面的\n   Actions。\n * subscribe：订阅 State 变化的函数。当传入的任意 Model 的 State 发生改变时，该函数会被调用。\n\n\n示例#\n\n\n基本用法#\n\n\n\n\nfunction Test(props) {\n  const [state, actions] = useModel([todoModel, filterModel]);\n  actions.add(); // 调用 todoModel add action\n  actions.setVisibleStatus(); // 调用 filterModel filterModel action\n\n  state.items; // 获取 todoModel state items\n  state.visibleStatus; // 获取 filterModel state visibleStatus\n}\n\n\n\nselector 用法#\n\nfunction Test(props) {\n  const [state, actions] = useModel(\n    [todoModel, filterModel],\n    (todoState, filterState) => ({\n      items: todoState.items,\n      visibleStatus: `${props.prefix}-${filterState.visibleStatus}`,\n    }),\n    (todoActions, filterActions) => ({\n      ...todoActions,\n      ...filterActions,\n    }),\n  );\n  actions.add(); // 调用 todoModel add action\n  actions.setVisibleStatus(); // 调用 filterModel filterModel action\n\n  state.items; // 获取 todoModel state items\n  state.visibleStatus; // 获取 filterModel state visibleStatus\n}\n\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":2,"title":"useModel"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/use-model.mdx","_relativePath":"zh/apis/app/runtime/model/use-model.mdx"},{"id":323,"title":"useStaticModel","routePath":"/apis/app/runtime/model/use-static-model","lang":"zh","toc":[{"text":"示例","id":"示例","depth":4,"charIndex":554}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n如果想在组件里以 React Hook 的形式消费某个 Model，并能随时获取到当前最新的状态，但又不希望 Model\n状态更新的时候，引起组件的重新渲染，可以使用 useStaticModel。useStaticModel API 形式上与 useModel\n完全一致。具体使用请参考 useModel。\n\n为了保证总是能获取到最新状态，注意不要对返回的 state 解构。\n\nfunction App() {\n  // ❌ 不能解构 state，但可以解构 actions。\n  const [{ username }, { logout }] = useStaticModel(userModel);\n\n  // ✅ 这才是正确使用姿势。\n  const [state, { logout }] = useStaticModel(userModel);\n\n  useEffect(() => {\n    state.username;\n  }, []);\n}\n\n\n示例#\n\n如下 App 组件消费了 userModel 的状态，但没有直接在 JSX 里使用。可以发现，userModel\n状态的改变没有必要引起组件重新渲染，这种情况可以使用 useStaticModel 进行优化。\n\nfunction App() {\n  const [state] = useStaticModel(userModel);\n\n  useEffect(() => {\n    // 统计 UV 数据\n    send('pageview', { user: state.user });\n  }, [state]);\n\n  return \nHello;\n}\n\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":3,"title":"useStaticModel"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/use-static-model.mdx","_relativePath":"zh/apis/app/runtime/model/use-static-model.mdx"},{"id":324,"title":"useStore","routePath":"/apis/app/runtime/model/use-store","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":205},{"text":"返回值","id":"返回值","depth":3,"charIndex":249}],"domain":"","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nuseStore 用于获取当前组件树共享的 Store。常用于在组件外访问 Model 的场景。注意，useStore 是一个 React\nHook，只能在组件内使用。\n\n\n函数签名#\n\nfunction useStore(): ReduckStore;\n\n\n\n返回值#\n\n * ReduckStore：Reduck Store，类型参考 createStore 返回值。\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":9,"title":"useStore"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/model/use-store.mdx","_relativePath":"zh/apis/app/runtime/model/use-store.mdx"},{"id":325,"title":"router","routePath":"/apis/app/runtime/router/router","lang":"zh","toc":[{"text":"hooks","id":"hooks","depth":2,"charIndex":35},{"text":"useNavigate","id":"usenavigate","depth":3,"charIndex":44},{"text":"useLocation","id":"uselocation","depth":3,"charIndex":497},{"text":"useParams","id":"useparams","depth":3,"charIndex":911},{"text":"useRouteError","id":"userouteerror","depth":3,"charIndex":1183},{"text":"组件","id":"组件","depth":2,"charIndex":1475},{"text":"Link","id":"link","depth":3,"charIndex":1481},{"text":"NavLink","id":"navlink","depth":3,"charIndex":1733},{"text":"Outlet","id":"outlet","depth":3,"charIndex":2220},{"text":"Route","id":"route","depth":3,"charIndex":2690},{"text":"更多 API","id":"更多-api","depth":2,"charIndex":4166}],"domain":"","content":"#\n\n补充信息\n\n基于 react-router 的路由解决方案。\n\n\nhooks#\n\n\nuseNavigate#\n\ndeclare function useNavigate(): NavigateFunction;\n\ninterface NavigateFunction {\n  (\n    to: To,\n    options?: {\n      replace?: boolean;\n      state?: any;\n      relative?: RelativeRoutingType;\n    },\n  ): void;\n  (delta: number): void;\n}\n\n\nuseNavigate 返回一个可以用于执行导航操作的函数。\n\n\n\nexport function HomeButton() {\n  let navigate = useNavigate();\n\n  function handleClick() {\n    navigate('/home');\n  }\n\n  return (\n    \n      Go home\n    \n  );\n}\n\n\n\nuseLocation#\n\ndeclare function useLocation(): Location;\n\ninterface Location extends Path {\n  state: unknown;\n  key: Key;\n}\n\n\nuseLocation 返回当前 url 对应的 location 对象。每当路由更新的时候，都会拿到一个新的 location 对象。\n\n\n\nfunction usePageViews() {\n  let location = useLocation();\n  React.useEffect(() => {\n    ga.send([\"pageview\", location.pathname]);\n  }, [location]);\n}\n\nfunction App() {\n  usePageViews();\n  return (\n    //...\n  );\n}\n\n\n\nuseParams#\n\ndeclare function useParams(): Readonly>;\n\n\nuseParams 返回一个 key/value 的键值对，表示当前匹配的路由 中的参数信息。\n\n\n\nfunction BlogPost() {\n  const { slug } = useParams();\n  return \nNow showing post {slug};\n}\n\nfunction App() {\n  return (\n    \n      home} />\n      } />\n    \n  );\n}\n\n\n\nuseRouteError#\n\nexport declare function useRouteError(): unknown;\n\n\nuseRouteError 返回离 ErrorBoundary 定义最近的路由渲染错误信息。\n\n\nconst ErrorBoundary = () => {\n  const error = useRouteError();\n  return (\n    \n\n      \n\n\n{error.status}\n      \n\n\n{error.message}\n    \n  );\n};\nexport default ErrorBoundary;\n\n\n\n组件#\n\n\nLink#\n\ndeclare function Link(props: LinkProps): React.ReactElement;\n\ninterface LinkProps\n  extends Omit, 'href'> {\n  replace?: boolean;\n  state?: any;\n  to: To;\n  reloadDocument?: boolean;\n}\n\ntype To = string | Partial;\n\n\n可以使用 Link 组件进行路由跳转。\n\nAbout\n\n\n\nNavLink#\n\ndeclare function NavLink(props: NavLinkProps): React.ReactElement;\n\ninterface NavLinkProps\n  extends Omit {\n  caseSensitive?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { isActive: boolean }) => React.ReactNode);\n  className?: string | ((props: { isActive: boolean }) => string | undefined);\n  end?: boolean;\n  style?:\n    | React.CSSProperties\n    | ((props: { isActive: boolean }) => React.CSSProperties);\n}\n\n\n是一种特殊的 ，当 对应的链接和当前 URL 匹配时，会给 所渲染的元素添加“激活”态样式。\n\n\nOutlet#\n\ninterface OutletProps {\n  context?: unknown;\n}\ndeclare function Outlet(props: OutletProps): React.ReactElement | null;\n\n\n用于嵌套路由场景。在父路由的元素中使用，代表待渲染的子路由的元素在父组件中的位置。\n\nfunction Dashboard() {\n  return (\n    \n\n      \n\n\nDashboard\n\n      {/* This element will render either  when the URL is\n          \"/messages\",  at \"/tasks\", or null if it is \"/\"\n      */}\n      \n    \n  );\n}\n\nfunction App() {\n  return (\n    \n      }>\n        } />\n        } />\n      \n    \n  );\n}\n\n\n\nRoute#\n\ninterface RouteObject {\n  path?: string;\n  index?: boolean;\n  children?: React.ReactNode;\n  caseSensitive?: boolean;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n  handle?: RouteObject['handle'];\n  shouldRevalidate?: ShouldRevalidateFunction;\n}\n\n\nRoute 用于定义路由。一个 Route 对象，将 URL 片段和组件、数据获取关联起来。\n\nRoute 可以作为普通对象，传给创建 router 的函数的参数：\n\nconst router = createBrowserRouter([\n  {\n    // it renders this element\n    element: ,\n\n    // when the URL matches this segment\n    path: 'teams/:teamId',\n\n    // with this data loaded before rendering\n    loader: async ({ request, params }) => {\n      return fetch(`/fake/api/teams/${params.teamId}.json`, {\n        signal: request.signal,\n      });\n    },\n\n    // performing this mutation when data is submitted to it\n    action: async ({ request }) => {\n      return updateFakeTeam(await request.formData());\n    },\n\n    // and renders this element in case something went wrong\n    errorElement: ,\n  },\n]);\n\n\nRoute 还可以作为组件使用，通过 createRoutesFromElements 转换后，再传给创建 router 的函数的参数：\n\nconst router = createBrowserRouter(\n  createRoutesFromElements(\n    }\n      path=\"teams/:teamId\"\n      loader={async ({ params }) => {\n        return fetch(`/fake/api/teams/${params.teamId}.json`);\n      }}\n      action={async ({ request }) => {\n        return updateFakeTeam(await request.formData());\n      }}\n      errorElement={}\n    />,\n  ),\n);\n\n\n\n更多 API#\n\n若想要了解完整的路由 API 信息，可至 react-router 官网 查看。","frontmatter":{"title":"router","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/router/router.mdx","_relativePath":"zh/apis/app/runtime/router/router.mdx"},{"id":326,"title":"NoSSR","routePath":"/apis/app/runtime/ssr/no-ssr","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":71},{"text":"示例","id":"示例","depth":2,"charIndex":109},{"text":"使用场景","id":"使用场景","depth":2,"charIndex":284}],"domain":"","content":"#\n\n被 NoSSR 包裹的内容在服务端不会进行渲染，在客户端 hydrate 阶段也不会渲染，等到整个 App 渲染完成后便会立即渲染。\n\n\n使用姿势#\n\n\n\nexport default () => ...;\n\n\n\n示例#\n\n下列代码中，Time 组件用于展示当前的时间，由于服务端渲染和客户端 hydrate 时获取到的时间是不一致的，React 就会抛出异常。针对这种情况可以使用\nNoSSR 进行优化：\n\n\n\nfunction Time() {\n  return (\n    \n      \nTime: {Date.now()}\n    \n  );\n}\n\n\n\n使用场景#\n\n在 CSR 中，常常需要根据当前浏览器 UA，或是当前页面 URL 的某个参数的不同，来渲染不同的内容。如果此时应用直接切换到\nSSR，很有可能出现不符合预期的结果。\n\nModern.js 在 SSR 上下文中提供了完整的浏览器端信息，可以利用上下文信息来决定组件在服务端的渲染结果。\n\n即便如此，如果应用里有太多的判断，开发者希望以后再使用上下文，或者不希望某些内容在服务端被渲染，可以使用 NoSSR 组件将这一部分剔除在服务端渲染外。","frontmatter":{"title":"NoSSR"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/ssr/no-ssr.mdx","_relativePath":"zh/apis/app/runtime/ssr/no-ssr.mdx"},{"id":327,"title":"PreRender","routePath":"/apis/app/runtime/ssr/pre-render","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":52},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":106},{"text":"参数","id":"参数","depth":3,"charIndex":388},{"text":"示例","id":"示例","depth":2,"charIndex":760}],"domain":"","content":"#\n\n无展示内容的高阶组件，通过类似 Helmet 的方式实现 SPA 路由级的缓存，无需额外配置。\n\n\n使用姿势#\n\n\n\nexport default () => (\n  <>\n    \n  </>\n);\n\n\n\n函数签名#\n\nPreRender 组件提供了一套常用的配置参数，用于控制缓存的规则、过期时间、缓存算法等。\n\ntype Props {\n  interval: number;\n  staleLimit: number;\n  level: number;\n  include: { header?: string[], query?: string[] };\n  matches: { header?: Record, query?: Record }\n}\n\nfunction PreRender(props: Props): React.Component\n\n\n\n参数#\n\n * interval：设置缓存保持新鲜的时间，单位秒。在该时间内，将直接使用缓存，并且不做异步渲染。\n * staleLimit：设置缓存完全过期的时间，单位秒。在该时间内，缓存可以被返回，并且会做一步渲染，否则必须使用重新渲染的结果。\n * level：设置缓存标识的计算规则等级，通常配合 includes 与 matches 使用。默认值为 0。\n\n0：路由路径\n1：路由路径 + 查询字符串\n2：路由路径 + 请求头\n3：路由路径 + 查询字符串 + 请求头\n\n\n * includes：设置需要被纳入缓存标识的内容，在 level 非 0 时使用。默认值为 null。\n * matches：设置 query 或 header 的值在缓存标识计算中的重写规则，通常用在缓存分类时，支持正则表达式。默认值为 null。\n\n\n示例#\n\n\n\nexport default function App() {\n  return (\n    <>\n      \n      \nHello Modern\n    </>\n  );\n}\n\n\n下面例子展示了如何将 query、header 中指定的参数纳入缓存计算中：\n\n/* 使用 query 中的 channel 和 header 中的 language 计算缓存标识 */\n\n\n\n下面例子展示了如何不让测试频道影响线上缓存：\n\n/* 将 query 中 channel 值为 test_ 开头的重写为 testChannel，否则重写为 otherChannel */\n\n","frontmatter":{"title":"PreRender"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/ssr/pre-render.mdx","_relativePath":"zh/apis/app/runtime/ssr/pre-render.mdx"},{"id":328,"title":"act","routePath":"/apis/app/runtime/testing/act","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":34},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":45},{"text":"示例","id":"示例","depth":2,"charIndex":94}],"domain":"","content":"#\n\n用于确保渲染、事件、数据获取等行为已经应用在 DOM 上。\n\n\n使用姿势#\n\n\n\n\n\n函数签名#\n\nact 和 react-dom/test-utils act 函数 是一致的。\n\n\n示例#\n\n\n\n\n\ndescribe('test act', () => {\n  it('it should be foo', () => {\n    const el = document.createElement('div');\n    act(() => {\n      ReactDOM.render(, el);\n    });\n\n    expect(el.innerHTML).toBe('\nFoo');\n  });\n});\n","frontmatter":{"title":"act"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/testing/act.mdx","_relativePath":"zh/apis/app/runtime/testing/act.mdx"},{"id":329,"title":"cleanup","routePath":"/apis/app/runtime/testing/cleanup","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":21},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":32},{"text":"示例","id":"示例","depth":2,"charIndex":66}],"domain":"","content":"#\n\n用于卸载掉当前已渲染的所有组件。\n\n\n使用姿势#\n\n\n\n\n\n函数签名#\n\nfunction cleanup(): void\n\n\n示例#\n\nINFO\n\n请注意，如果你使用的测试框架支持 afterEach，并且它被注入到你的测试环境中（如 mocha、Jest 和 Jasmine），会默认在 afterEach\n钩子里执行 cleanup。否则，你将需要在每次测试后进行手动清理。\n\n例如，如果你使用ava测试框架，那么你需要像这样使用 test.afterEach 钩子。\n\n\n\n\ntest.afterEach(cleanup);\n\ntest('renders into document', () => {\n  render(\n);\n  // ...\n});\n\n// ... more tests ...\n","frontmatter":{"title":"cleanup","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/testing/cleanup.mdx","_relativePath":"zh/apis/app/runtime/testing/cleanup.mdx"},{"id":330,"title":"render","routePath":"/apis/app/runtime/testing/render","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":23},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":34},{"text":"参数","id":"参数","depth":3,"charIndex":465},{"text":"返回值","id":"返回值","depth":3,"charIndex":912},{"text":"示例","id":"示例","depth":2,"charIndex":1224}],"domain":"","content":"#\n\n用于在测试用例中渲染组件，完成测试。\n\n\n使用姿势#\n\n\n\n\n\n函数签名#\n\ntype Options = {\n  container: DOMElement;\n  baseElement: DOMElement;\n  hydrate: boolean;\n  warpper: React.ComponentType<{children: ReactNode}>;\n  queries: any;\n};\n\ntype RenderResult = {\n  {...queries}: any;\n  container: DOMElement;\n  baseElement: DOMElement;\n  debug: function;\n  rerender: function;\n  unmount: function;\n  asFragment: function;\n}\n\nfunction render(ui: React.ReactElement, options: Options): RenderResult;\n\n\n\n参数#\n\n * ui：需要被渲染的 React 组件。\n * options：render 可选配置。\n   * container：表示组件所要挂载到的 DOM 节点，默认是会创建一个 div 元素，并自动添加到 document.body 上。这个 div\n     元素就是组件要挂载的节点。默认值是 document.body.append(document.createElement('div'))。\n   * baseElement：用于指定 queries 中使用到的 basename。如果指定了 container, 则默认值为 container\n     的值，否则就是 document.body。\n   * hydrate：如果设置为 true，则会使用 ReactDOM.hydrate 渲染组件。默认值为 false。\n   * wrapper：是一个 react 组件，可用于自定义渲染逻辑。\n   * queries：自定义一些自己的 queries。\n\n\n返回值#\n\n * {...queries}：所有可用的 queries。\n * container：挂载 React 组件的 DOM 节点。\n * baseElement\n * debug\n * rerender：如果想测试一个已渲染的组件在其 props 更新时的一些场景，可以使用 rerender 来现实。\n * unmount：会卸载掉已渲染的组件。如果想测试组件卸载后的情况（如，绑定的事件是否在 unmount 阶段被卸载掉），那么这个 API 是很帮助的。\n * asFragment：返回当前渲染的组件的 DocumentFragment 对象。可用于测试 react 事件触发后 DOM 结构的响应。\n\n\n示例#\n\n\n\n\ntest('renders a message', () => {\n  const { container, getByText } = render();\n  expect(getByText('Hello, world!')).toBeInTheDocument();\n  expect(container.firstChild).toMatchInlineSnapshot(`\n    \n\n\nHello, World!\n  `);\n});\n","frontmatter":{"title":"render"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/testing/render.mdx","_relativePath":"zh/apis/app/runtime/testing/render.mdx"},{"id":331,"title":"renderApp","routePath":"/apis/app/runtime/testing/renderApp","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":44},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":186},{"text":"示例","id":"示例","depth":2,"charIndex":220}],"domain":"","content":"#\n\nrender 函数用于测试普通组件，renderApp 函数用于测试应用组件。\n\n\n使用姿势#\n\n\n\n\n应用组件指包含一些 Modern.js 上下文的组件，如 App 根组件，使用了 Model 的 Container 等。对于这类组件的测试，可以使用\nrenderApp 函数，会自动按照当前 modern.config.js 配置，包裹上对应的上下文信息。\n\n\n函数签名#\n\nrenderApp 和 render 完全一致。\n\n\n示例#\n\n\n\n\ndescribe('test', () => {\n  it('test App', () => {\n    const { getByText } = renderApp();\n    expect(getByText('Hello Modern!')).toBeInTheDocument();\n  });\n});\n","frontmatter":{"title":"renderApp"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/testing/renderApp.mdx","_relativePath":"zh/apis/app/runtime/testing/renderApp.mdx"},{"id":332,"title":"CSS-In-JS API","routePath":"/apis/app/runtime/utility/css-in-js","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":34},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":45},{"text":"示例","id":"示例","depth":2,"charIndex":79}],"domain":"","content":"#\n\n使用 Style Component 来编写组件 CSS。\n\n\n使用姿势#\n\n\n\n\n\n函数签名#\n\n请看 styled-component API。\n\n\n示例#\n\n\n\nconst Button = styled.button`\n  background: palevioletred;\n  border-radius: 3px;\n  border: none;\n  color: white;\n`;\n\nconst TomatoButton = styled(Button)`\n  background: tomato;\n`;\n\nfunction ButtonExample() {\n  return (\n    <>\n      I'm purple.\n      \n\n      I'm red.\n    </>\n  );\n}\n","frontmatter":{"title":"CSS-In-JS API"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/utility/css-in-js.mdx","_relativePath":"zh/apis/app/runtime/utility/css-in-js.mdx"},{"id":333,"title":"Head","routePath":"/apis/app/runtime/utility/head","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":53},{"text":"示例","id":"示例","depth":2,"charIndex":91},{"text":"更多用法","id":"更多用法","depth":2,"charIndex":250}],"domain":"","content":"#\n\n用于给 元素内添加 html 元素（如 title、meta、script 等），支持 SSR。\n\n\n使用姿势#\n\n\n\nexport default () => ...;\n\n\n\n示例#\n\n\n\nfunction IndexPage() {\n  return (\n    \n\n      \n        My page title\n        \n      \n      \n\nHello Modern.js!\n    \n  );\n}\n\nexport default IndexPage;\n\n\n\n更多用法#\n\n详见 react-helmet。","frontmatter":{"title":"Head"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/utility/head.mdx","_relativePath":"zh/apis/app/runtime/utility/head.mdx"},{"id":334,"title":"loadable","routePath":"/apis/app/runtime/utility/loadable","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":23},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":34},{"text":"参数","id":"参数","depth":3,"charIndex":272},{"text":"loadFn","id":"loadfn","depth":4,"charIndex":277},{"text":"options.resolveComponent","id":"optionsresolvecomponent","depth":4,"charIndex":366},{"text":"options.fallback","id":"optionsfallback","depth":4,"charIndex":1093},{"text":"options.ssr","id":"optionsssr","depth":4,"charIndex":1143},{"text":"返回值","id":"返回值","depth":3,"charIndex":1179},{"text":"LoadableComponent","id":"loadablecomponent","depth":4,"charIndex":1185}],"domain":"","content":"#\n\n用于创建 Loadable 的组件。\n\n\n使用姿势#\n\n\n\n\n\n函数签名#\n\ntype Options = {\n  resolveComponent?: (\n    module: Module,\n    props: Props,\n  ) => React.ComponentType,\n  fallback?: JSX.Element;\n  ssr?: boolean;\n}\n\nfunction loadable(loadFn: Function, options?: Options) => LoadableComponent\n\n\n\n参数#\n\nloadFn#\n\n用于加载组件。\n\n\n\nconst OtherComponent = loadable(() => import('./OtherComponent'));\n\n\noptions.resolveComponent#\n\n类型：(module: Module, props: Props) => React.ComponentType\n\nmodule 为 loadFn 返回的组件，props 是 loadable 返回的组件接受的 props 参数。默认的话，我们认为 import\n的文件都是默认导出 react 组件，这时候直接渲染该组件即可。但当组件是具名导出的，或者我们需要根据具体的 props\n动态判断需要渲染哪个组件的时候，可以使用 resolveComponent 来实现。下面是一个示例：\n\nexport const Apple = () => 'Apple!';\nexport const Orange = () => 'Orange!';\n\n\nconst LoadableApple = loadable(() => import('./components'), {\n  resolveComponent: components => components.Apple,\n});\nconst LoadableOrange = loadable(() => import('./components'), {\n  resolveComponent: components => components.Orange,\n});\nconst LoadableFruit = loadable(() => import('./components'), {\n  resolveComponent: (components, props) => components[props.fruit],\n});\n\n\noptions.fallback#\n\n是否在 loading 阶段显示 fallback 内容。\n\noptions.ssr#\n\n是否支持 SSR，默认值是 true。\n\n\n返回值#\n\nLoadableComponent#\n\ntype LoadableComponent = React.ComponentType<\n  Props & { fallback?: JSX.Element }\n> & {\n  preload(props?: Props): void;\n  load(props?: Props): Promise>;\n};\n","frontmatter":{"title":"loadable"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/utility/loadable.mdx","_relativePath":"zh/apis/app/runtime/utility/loadable.mdx"},{"id":335,"title":"Hook","routePath":"/apis/app/runtime/web-server/hook","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":83},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":354},{"text":"参数","id":"参数","depth":3,"charIndex":1504},{"text":"示例","id":"示例","depth":2,"charIndex":1684},{"text":"Redirect","id":"redirect","depth":3,"charIndex":1690},{"text":"Rewrite","id":"rewrite","depth":3,"charIndex":1854},{"text":"HTML 内容注入","id":"html-内容注入","depth":3,"charIndex":2007}],"domain":"","content":"#\n\n用于拓展 Modern.js 内置的 Web Server，所有的页面请求都会经过 Hook。\n\nNOTE\n\n更多内容可以查看自定义 Web Server。\n\n\n使用姿势#\n\n\n\nexport const afterMatch: AfterMatchHook = (context, next) => {};\nexport const afterRender: AfterRenderHook = (context, next) => {};\n\n\n自定义 Web Server\n\n使用该 API 前，请先执行 pnpm run new 新建「自定义 Web Serve」源码目录。\n\npnpm run new\n? 请选择你想要的操作 创建工程元素\n? 新建「自定义 Web Server」源码目录\n\n\n\n函数签名#\n\ntype HookContext = {\n  response: {\n    set: (key: string, value: string) => void;\n    status: (code: number) => void;\n    cookies: {\n      set: (key: string, value: string, options?: any) => void;\n      clear: () => void;\n    };\n    raw: (\n      body: string,\n      { status, headers }: { status: number; headers: Record },\n    ) => void;\n  };\n  request: {\n    url: string;\n    host: string;\n    pathname: string;\n    query: Record;\n    cookie: string;\n    cookies: {\n      get: (key: string) => string;\n    };\n    headers: IncomingHttpHeaders;\n  };\n};\n\nfunction Hook(context: HookContext, next: NextFunction): Promsie | void;\n\n\n另外，不同 Hook 额外提供了不同的上下文。目前 Modern.js 支持 AfterMatch 和 AfterRender 两个 Hook。\n\ntype AfterMatchContext = HookContext & {\n  router: {\n    redirect: (url: string, status: number) => void;\n    rewrite: (entry: string) => void;\n  };\n};\n\ntype AfterRenderContext = {\n  template: {\n    get: () => string;\n    set: (html: string) => void;\n    prependHead: (fragment: string) => void;\n    appendHead: (fragment: string) => void;\n    prependBody: (fragment: string) => void;\n    appendBody: (fragment: string) => void;\n  };\n};\n\n\n\n参数#\n\n * context：提供当前 Hook 上下文。\n   * response：提供一系列处理响应的操作\n   * request：提供一系列获取请求信息的操作\n   * router：提供对响应路由的快捷操作\n   * template：提供对响应内容的快捷操作\n * next：执行当前 Hook 的下一个监听函数（不影响整体服务端流程）。\n\n\n示例#\n\n\nRedirect#\n\n将页面重定向到站点外的页面，例如跳转到统一登录页：\n\n\n\nexport const afterMatch: AfterMatch = async (ctx, next) => {\n  ctx.router.redirect('https://website.com/login', 302);\n};\n\n\n\nRewrite#\n\n将页面重写到当前站点的其他页面，例如同一个路由根据 UA 返回适配不同端的页面：\n\n\n\nexport const afterMatch: AfterMatch = async (ctx, next) => {\n  ctx.router.rewrite('mobile');\n};\n\n\n\nHTML 内容注入#\n\n为页面注入某些与渲染主体无关的 HTML 内容，如脚本、页面骨架等：\n\n\n\nexport const afterRender: AfterRenderHook = (context, next) => {\n  ctx.template.prependBody('\nFooter');\n};\n","frontmatter":{"title":"Hook"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/web-server/hook.mdx","_relativePath":"zh/apis/app/runtime/web-server/hook.mdx"},{"id":336,"title":"Middleware","routePath":"/apis/app/runtime/web-server/middleware","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":123},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":437},{"text":"参数","id":"参数","depth":3,"charIndex":1188},{"text":"示例","id":"示例","depth":2,"charIndex":1423},{"text":"服务端耗时打点","id":"服务端耗时打点","depth":3,"charIndex":1429},{"text":"注入服务端工具 & 数据","id":"注入服务端工具-&-数据","depth":3,"charIndex":1604},{"text":"框架拓展","id":"框架拓展","depth":3,"charIndex":1802}],"domain":"","content":"#\n\n用于拓展 Modern.js 内置的 Web Server，与 Hook 不同的是，Middleware 可以直接操作 Node\n原生的请求、响应对象，并且可以使用框架拓展。\n\nNOTE\n\n更多内容可以查看自定义 Web Server。\n\n\n使用姿势#\n\n\n\nexport const middleware: Middleware = async (context, next) => {};\nexport const middleware: Middleware[] = [\n  async (context, next) => {},\n  async (context, next) => {},\n];\n\n\n自定义 Web Server\n\n使用该 API 前，请先执行 pnpm run new 新建「自定义 Web Server」源码目录。\n\npnpm run new\n? 请选择你想要的操作 创建工程元素\n? 新建「自定义 Web Server」源码目录\n\n\n\n函数签名#\n\ntype Middleware = (\n  context: MiddlewareContext,\n  next: NextFunction,\n) => Promise | void;\n\ntype MiddlewareContext = {\n  response: {\n    set: (key: string, value: string) => void;\n    status: (code: number) => void;\n    cookies: {\n      set: (key: string, value: string, options?: any) => void;\n      clear: () => void;\n    };\n    raw: (\n      body: string,\n      { status, headers }: { status: number; headers: Record },\n    ) => void;\n    locals: Record;\n  };\n  request: {\n    url: string;\n    host: string;\n    pathname: string;\n    query: Record;\n    cookie: string;\n    cookies: {\n      get: (key: string) => string;\n    };\n    headers: IncomingHttpHeaders;\n  };\n  source: {\n    req: IncomingMessage;\n    res: ServerResponse;\n  };\n};\n\n\n\n参数#\n\n * context：提供当前 Hook 上下文。\n   * response：提供一系列处理响应的操作\n   * request：提供一系列获取请求信息的操作\n   * source：提供 Node.js 原生的 req 与 res 对象。\n * next：执行当前 Hook 的下一个监听函数（不影响整体服务端流程）。\n\nWARNING\n\nnext 函数的执行不影响后续内置流程，只控制下一个中间件是否执行。只有当响应被写入时，后续渲染流程才会中断。\n\n\n示例#\n\n\n服务端耗时打点#\n\nexport const Middleware = () => async (ctx, next) => {\n  const start = Date.now();\n  ctx.res.once('finish', () => {\n    console.log(Date.now() - start);\n  });\n};\n\n\n\n注入服务端工具 & 数据#\n\nModern.js 提供了 res.locals 属性用来存放当前请求的局部变量。\n\nexport const Middleware = () => async (ctx, next) => {\n  ctx.res.locals.id = 'Modern.js';\n  ctx.res.locals.rpc = createRpcInstance();\n};\n\n\n\n框架拓展#\n\nMiddleware 还可以和 BFF 一样，使用运行时框架拓展。Modern.js 约定，当使用框架运行时拓展时，类型信息从\n@modern-js/runtime/{namespace} 下导出，Middleware 可以使用框架语法，例如框架中间件写法，以下是伪代码：\n\n\n\nexport const middleware: SomeType = (ctx, next) => {\n  console.log(ctx.url);\n  next();\n};\n\n\n默认情况下，在安装框架拓展插件后，Web Server 的框架拓展能力是关闭的。如果希望使用框架拓展，可以通过\nserver.enableFrameworkExt 开启。\n\nINFO\n\n框架拓展导出的类型名不一定为 Middleware，命名由框架拓展插件。","frontmatter":{"title":"Middleware"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/app/runtime/web-server/middleware.mdx","_relativePath":"zh/apis/app/runtime/web-server/middleware.mdx"},{"id":337,"title":"","routePath":"/apis/monorepo/commands/bump","lang":"zh","toc":[],"domain":"","content":"Usage: modern bump [options]\n\n使用变更集自动更新发布版本和变更日志\n\nOptions:\n  --canary       创建一个预发布版本进行测试 (default: false)\n  --preid   在对预发布版本进行版本控制时指定标识符 (default: \"next\")\n  --snapshot     创建一个特殊版本进行测试 (default: false)\n  -h, --help     display help for command\n\n\nINFO\n\nbump 命令执行之前需要提前执行 change 命令添加 changeset。\n\n按 changeset 记录修改 package.json 中的版本号， 同时生成 CHANGELOG.md：\n\nnpx modern bump\n🦋  All files have been updated. Review them and commit at your leisure\n\n\nCHANGELOG.md 示例内容如下：\n\n# package-a\n\n## 0.1.1\n\n### Patch Changes\n\n- test publish\n","frontmatter":{"sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/bump.mdx","_relativePath":"zh/apis/monorepo/commands/bump.mdx"},{"id":338,"title":"change","routePath":"/apis/monorepo/commands/change","lang":"zh","toc":[],"domain":"","content":"#\n\nUsage: modern change [options]\n\n创建变更集\n\nOptions:\n  --empty     创建空变更集 (default: false)\n  --open      使用编辑器中打开创建的变更集 (default: false)\n  -h, --help  display help for command\n\n\nINFO\n\nchange、pre、bump、release 命令集成了工具 changesets 管理版本变更和 Changelog。\n\nmodern change 命令添加 changeset：\n\n$ npx modern change\n🦋  Which packages would you like to include? · package-a, package-b\n🦋  Which packages should have a major bump? · No items were selected\n🦋  Which packages should have a minor bump? · No items were selected\n🦋  The following packages will be patch bumped:\n🦋  package-a@0.1.0\n🦋  package-b@0.1.0\n🦋  Please enter a summary for this change (this will be in the changelogs). Submit empty line to open external editor\n🦋  Summary · test publish\n🦋  === Releasing the following packages ===\n🦋  [Patch]\n🦋    package-a, package-b\n🦋  ╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗\n🦋  ║                                                      ========= NOTE ========                                                       ║\n🦋  ║All dependents of these packages that will be incompatible with the new version will be patch bumped when this changeset is applied.║\n🦋  ╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝\n🦋  Is this your desired changeset? (Y/n) · true\n🦋  Changeset added! - you can now commit it\n🦋\n🦋  If you want to modify or expand on the changeset summary, you can find it here\n🦋  info /xxxx/monorepo/.changeset/long-lizards-talk.md\n\n\n上面我们给 package-a 和 package-b 都选择了 patch 变更，具体的变更信息在 monorepo 根目录下的\n.changeset/long-lizards-talk.md 中:\n\n---\n'package-a': patch\n'package-b': patch\n---\n\ntest publish\n","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/change.mdx","_relativePath":"zh/apis/monorepo/commands/change.mdx"},{"id":339,"title":"clear","routePath":"/apis/monorepo/commands/clear","lang":"zh","toc":[],"domain":"","content":"#\n\nUsage: modern clear [options]\n\nclear project dirs\n\nOptions:\n  --remove-dirs [dirs...]  remove dirs, default is node_modules\n  -h, --help               display help for command\n\n\n默认对 Monorepo 以及 Monorepo 子项目的 node_modules 进行清理。\n\n可以通过参数 --remove-dirs 来指定要删除的目录，例如执行：\n\n$ npx modern clear --remove-dirs dist\n\n\n则会清理所有 Monorepo 子项目的 dist 目录。","frontmatter":{"sidebar_position":8},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/clear.mdx","_relativePath":"zh/apis/monorepo/commands/clear.mdx"},{"id":340,"title":"deploy","routePath":"/apis/monorepo/commands/deploy","lang":"zh","toc":[],"domain":"","content":"#\n\nUsage: modern deploy [options]\n\ndeploy project\n\nOptions:\n  -p, --path [path]  Specify the path of the product output (default: \"output\")\n  -h, --help         display help for command\n\n\n对指定的项目进行部署，会通过指定项目分析其依赖的 Monorepo 下的子项目。\n\n在执行命令之后，会首先生成 output 目录，在目录当中包含了指定部署的项目以及其依赖的子项目，形成一个最小集合的 Monorepo。\n\n补充信息\n\noutput 目录是默认目录，可以通过 -p 参数进行自定义。\n\n然后会在 output 目录下进行依赖的安装以及必要文件的复制。\n\n最后当依赖安装完成后，便完成了对指定项目的部署任务。\n\n例如部署项目名称为 app 的应用，则可以执行：\n\npnpm deploy app\n\n\n补充信息\n\n其中 app 为项目的 package.json 的 name 值。","frontmatter":{"sidebar_position":7},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/deploy.mdx","_relativePath":"zh/apis/monorepo/commands/deploy.mdx"},{"id":341,"title":"gen-release-note","routePath":"/apis/monorepo/commands/gen-release-note","lang":"zh","toc":[],"domain":"","content":"#\n\nUsage: modern gen-release-note [options]\n\n根据当前仓库 changeset 文件生成 Release Note\n\nOptions:\n  --repo       仓库名称，用于生成 Pull Request 链接， 例如： web-infra-dev/modern.js\n  --custom   自定义 Release Note 生成函数\n  -h, --help         display help for command\n\n\n根据当前仓库的 changeset 信息自动生成 Release Note。\n\n注意\n\n需要在 bump 命令之前执行。\n\n## Features:\n\n[[#1160](https://github.com/web-infra-dev/modern.js/pull/1160)] export ExecaError type\n\n## Bug Fix:\n\n[[#1264](https://github.com/web-infra-dev/modern.js/pull/1264)] fix: conventional router app use App.init not work\n","frontmatter":{"sidebar_position":9},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/gen-release-note.mdx","_relativePath":"zh/apis/monorepo/commands/gen-release-note.mdx"},{"id":342,"title":"命令","routePath":"/apis/monorepo/commands/","lang":"zh","toc":[],"domain":"","content":"#\n\n本节涵盖了使用 Monorepo 工程的所有命令。","frontmatter":{"type":"ref"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/index.mdx","_relativePath":"zh/apis/monorepo/commands/index.mdx"},{"id":343,"title":"lint","routePath":"/apis/monorepo/commands/lint","lang":"zh","toc":[],"domain":"","content":"#\n\nUsage: modern lint [options] [...files]\n\nlint and fix source files\n\nOptions:\n  --no-fix    disable auto fix source file\n  -h, --help  display help for command\n\n\n运行 ESLint 检查 monorepo 中代码语法情况， 通长情况下，我们只需要在 git commit 阶段通过 lint-staged\n检查本次提交修改的部分代码。\n\n * --no-fix 参数设置后可以关闭自动修复 lint 错误代码的能力。","frontmatter":{"sidebar_position":6},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/lint.mdx","_relativePath":"zh/apis/monorepo/commands/lint.mdx"},{"id":344,"title":"new","routePath":"/apis/monorepo/commands/new","lang":"zh","toc":[],"domain":"","content":"#\n\nUsage: modern new [options]\n\nMonorepo 创建子项目\n\nOptions:\n  -d, --debug            开启 Debug 模式，打印调试日志信息 (default: false)\n  -c, --config   生成器运行默认配置(JSON 字符串)\n  --dist-tag        生成器使用特殊的 npm Tag 版本\n  --registry             生成器运行过程中定制 npm Registry\n  -h, --help             display help for command\n\n\nmodern new 命令在 monorepo 中可以用来添加应用工程和可复用的模块：\n\n$ modern new\n? 请选择你想创建的工程类型 (Use arrow keys)\n❯ Web 应用\n  Web 应用（测试）\n  Npm 模块\n  Npm 模块（内部）\n\n\n应用工程默认会添加到 apps 目录， 测试应用会添加到 examples 目录，公共模块默认会添加到 packages 目录， 内部模块默认会添加到\nfeatures 目录。\n\n内部模块在 monorepo 的应用里面使用时，可以无需构建直接使用源码。\n\n注意\n\n--config 参数对应参数值需要使用 JSON 字符串。\n\npnpm 暂不支持使用 JSON 字符串作为参数值，可使用 npm new 开启相关功能。【相关 Issue】","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/new.mdx","_relativePath":"zh/apis/monorepo/commands/new.mdx"},{"id":345,"title":"pre","routePath":"/apis/monorepo/commands/pre","lang":"zh","toc":[],"domain":"","content":"#\n\nUsage: modern pre [options]  [tag]\n\n进入和退出预发布模式\n\nOptions:\n  -h, --help  display help for command\n\n\n可以使用 modern pre 命令在正式发布前预发布一个版本。\n\n首先 modern pre enter 进入预发布模式:\n\n$ npx modern pre enter next\n🦋  success Entered pre mode with tag next\n🦋  info Run `changeset version` to version packages with prerelease versions\n\n\n之后通过 modern change 命令添加 changeset:\n\n$ npx modern change\n🦋  Which packages would you like to include? · package-a, package-b\n🦋  Which packages should have a major bump? · No items were selected\n🦋  Which packages should have a minor bump? · No items were selected\n🦋  The following packages will be patch bumped:\n🦋  package-a@0.1.1\n🦋  package-b@0.1.1\n🦋  Please enter a summary for this change (this will be in the changelogs). Submit empty line to open external editor\n🦋  Summary · test pre publish\n🦋  === Releasing the following packages ===\n🦋  [Patch]\n🦋    package-a, package-b\n🦋  ╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗\n🦋  ║                                                      ========= NOTE ========                                                       ║\n🦋  ║All dependents of these packages that will be incompatible with the new version will be patch bumped when this changeset is applied.║\n🦋  ╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝\n🦋  Is this your desired changeset? (Y/n) · true\n🦋  Changeset added! - you can now commit it\n🦋\n🦋  If you want to modify or expand on the changeset summary, you can find it here\n🦋  info /xxxxxx/monorepo/.changeset/beige-paws-rule.md\n\n\n接着可以使用 modern bump 命令更新具体的版本号：\n\n$ npx modern bump\n🦋  warn ===============================IMPORTANT!===============================\n🦋  warn You are in prerelease mode\n🦋  warn If you meant to do a normal release you should revert these changes and run `changeset pre exit`\n🦋  warn You can then run `changeset version` again to do a normal release\n🦋  warn ----------------------------------------------------------------------\n🦋  All files have been updated. Review them and commit at your leisure\n\n\n可以看到 package-a 和 package-b 的 package.json 中版本号均已更新到 0.1.2-next.0。\n\n提交完变更之后，我们可以通过 modern pre exit 命令退出预发布模式。","frontmatter":{"sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/pre.mdx","_relativePath":"zh/apis/monorepo/commands/pre.mdx"},{"id":346,"title":"release","routePath":"/apis/monorepo/commands/release","lang":"zh","toc":[],"domain":"","content":"#\n\nUsage: modern release [options]\n\npublish changes to npm\n\nOptions:\n  --tag   publish use special tag (default: \"\")\n  -h, --help   display help for command\n\n\n发布当前仓库的 Packages 至 NPM。","frontmatter":{"sidebar_position":5},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/release.mdx","_relativePath":"zh/apis/monorepo/commands/release.mdx"},{"id":347,"title":"upgrade","routePath":"/apis/monorepo/commands/upgrade","lang":"zh","toc":[],"domain":"","content":"#\n\nUsage: modern upgrade [options]\n\n升级 Modern.js 到最新版本\n\nOptions:\n  --registry   定制 npm registry (default: \"\")\n  -d,--debug             开启 Debug 模式，打印调试日志信息 (default: false)\n  --cwd             项目路径 (default: \"\")\n  -h, --help             display help for command\n\n\nmodern upgrade 命令，用于升级项目 Modern.js 相关依赖至最新版本。\n\n在项目根目录下执行命令 npx modern upgrade，会默认将当前执行命令项目的 package.json 中的 Modern.js\n相关依赖更新至最新版本。","frontmatter":{"sidebar_position":11},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/commands/upgrade.mdx","_relativePath":"zh/apis/monorepo/commands/upgrade.mdx"},{"id":348,"title":"apps/*","routePath":"/apis/monorepo/hooks/apps","lang":"zh","toc":[],"domain":"","content":"#\n\nMonorepo 工程方案应用类型项目目录。\n\nModern.js Monorepo 工程方案约定将应用类型子项目放置在 apps 目录下进行统一管理，apps 目录下每一个文件夹都是一个完整的应用项目。\n\nINFO\n\n可直接在项目下执行 new 命令创建应用类型子项目。","frontmatter":{"title":"apps/*","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/hooks/apps.mdx","_relativePath":"zh/apis/monorepo/hooks/apps.mdx"},{"id":349,"title":"monorepo.code-workspace","routePath":"/apis/monorepo/hooks/code-workspace","lang":"zh","toc":[],"domain":"","content":"#\n\nMonorepo 工程方案 VS Code 配置文件。\n\nMonorepo 工程方案支持 VS Code Workspace 配置，可以通过该配置文件打开的一个或多个文件夹的集合。\n\nVS Code workspace 协议详情可查看: VS Code Workspace","frontmatter":{"title":"monorepo.code-workspace","sidebar_position":7},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/hooks/code-workspace.mdx","_relativePath":"zh/apis/monorepo/hooks/code-workspace.mdx"},{"id":350,"title":"examples/*","routePath":"/apis/monorepo/hooks/examples","lang":"zh","toc":[],"domain":"","content":"#\n\nMonorepo 工程方案测试应用类型项目目录。\n\nModern.js Monorepo 工程方案约定将测试的应用类型子项目放置在 examples 目录下进行统一管理，examples\n目录下每一个文件夹都是一个完整的应用项目。\n\n测试类型的应用项目不包含部署相关的 scripts 命令，用于开发过程中进行测试项目、测试案例的编写。\n\nINFO\n\n可直接在项目下执行 new 命令创建测试应用类型子项目。","frontmatter":{"title":"examples/*","sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/hooks/examples.mdx","_relativePath":"zh/apis/monorepo/hooks/examples.mdx"},{"id":351,"title":"features/","routePath":"/apis/monorepo/hooks/features","lang":"zh","toc":[],"domain":"","content":"#\n\nMonorepo 工程方案内部模块类型项目目录。\n\nModern.js Monorepo 工程方案约定将内部模块类型子项目放置在 features 目录下进行统一管理，features\n目录下每一个文件夹都是一个完整的模块项目。\n\n内部模块项目用于一些不需要编译的公共的组件和工具的编写，这类型的项目不包含编译、发布命令，在应用类型项目中引用时，应用类型项目会默认对其进行编译。\n\nINFO\n\n可直接在项目下执行 new 命令内部模块类型子项目。","frontmatter":{"title":"features/","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/hooks/features.mdx","_relativePath":"zh/apis/monorepo/hooks/features.mdx"},{"id":352,"title":"命令","routePath":"/apis/monorepo/hooks/","lang":"zh","toc":[],"domain":"","content":"#\n\n本节涵盖了使用 Monorepo 工程所有的文件约定","frontmatter":{"type":"ref"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/hooks/index.mdx","_relativePath":"zh/apis/monorepo/hooks/index.mdx"},{"id":353,"title":"packages/","routePath":"/apis/monorepo/hooks/packages","lang":"zh","toc":[],"domain":"","content":"#\n\nMonorepo 工程方案公共模块类型项目目录。\n\nModern.js Monorepo 工程方案约定将公共模块类型子项目放置在 packages 目录下进行统一管理，packages\n目录下每一个文件夹都是一个完整的模块项目。\n\n公共模块项目用户一些公共的组件和工具的编写，这些公共包可自行进行编译和发布，也可在应用类型项目中引用。\n\nINFO\n\n可直接在项目下执行 new 命令创建模块类型子项目。","frontmatter":{"title":"packages/","sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/hooks/packages.mdx","_relativePath":"zh/apis/monorepo/hooks/packages.mdx"},{"id":354,"title":"pnpm-workspace.yaml","routePath":"/apis/monorepo/hooks/pnpm-workspace","lang":"zh","toc":[],"domain":"","content":"#\n\nMonorepo 工程方案 pnpm workspace 配置文件。\n\nMonorepo 工程方案支持使用 pnpm 作为包管理工具对项目进行管理，支持 pnpm 的 workspace 协议。\n\npnpm workspace 配置详情可查看: pnpm workspace","frontmatter":{"title":"pnpm-workspace.yaml","sidebar_position":5},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/hooks/pnpm-workspace.mdx","_relativePath":"zh/apis/monorepo/hooks/pnpm-workspace.mdx"},{"id":355,"title":".pnpmfile.cjs","routePath":"/apis/monorepo/hooks/pnpmfile","lang":"zh","toc":[],"domain":"","content":"#\n\nMonorepo 工程方案 pnpm 钩子文件。\n\nMonorepo 工程方案支持使用 pnpm 作为包管理工具对项目进行管理，支持使用 pnpm 的钩子文件对安装过程进行自定义。\n\npnpm .pnpmfile.cjs 使用详情可查看: pnpmfile","frontmatter":{"title":".pnpmfile.cjs","sidebar_position":6},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/apis/monorepo/hooks/pnpmfile.mdx","_relativePath":"zh/apis/monorepo/hooks/pnpmfile.mdx"},{"id":356,"title":"2022 年 7 ~ 8 月更新内容","routePath":"/community/blog/2022-0708-updates","lang":"zh","toc":[{"text":"支持 React 18","id":"支持-react-18","depth":2,"charIndex":233},{"text":"Modern.js 包版本统一","id":"modernjs-包版本统一","depth":2,"charIndex":485},{"text":"模块工程支持 bundle 构建","id":"模块工程支持-bundle-构建","depth":2,"charIndex":880},{"text":"Reduck v1.1","id":"reduck-v11","depth":2,"charIndex":1277},{"text":"其他更新","id":"其他更新","depth":2,"charIndex":1741},{"text":"命令和配置","id":"命令和配置","depth":3,"charIndex":1749},{"text":"BFF","id":"bff","depth":3,"charIndex":2022},{"text":"SSR","id":"ssr","depth":3,"charIndex":2182},{"text":"Web Server","id":"web-server","depth":3,"charIndex":2231}],"domain":"","content":"#\n\n> 发表于 2022.09.05\n\nModern.js 7 ~ 8 月的最新版本为 v1.17.0，本双月的主要更新有：\n\n * 支持 React 18：完成框架和插件对 React 18 的适配。\n * 包版本统一：Modern.js 所有组成包的版本号进行统一，提供升级命令。\n * 模块工程支持 bundle 构建：模块工程类型的项目，支持对产物做 bundle 构建。\n * Reduck v1.1：发布 Reduck v1.1，使用文档全面更新。\n\n\n支持 React 18#\n\nModern.js 框架和相关插件完成对 React 18 的适配。现在，只需要将项目中的 react、react-dom 两个包的版本，升级到最新的\nReact 18 大版本，就可以使用 React 18 的新功能。\n\n注意，使用 @modern-js/create 命令默认创建的项目，安装的依赖 react、react-dom 的版本仍然为 17，如果希望使用 React\n18，请手动升级这两个包的版本。\n\n另外，SSR 流式渲染功能，目前尚在开发中，暂不支持。\n\n\nModern.js 包版本统一#\n\n之前，组成 Modern.js 的各个包的版本号并不统一，Modern.js\n自身的版本和这些包的版本缺少明确的对应关系。这不仅增加了我们的维护成本，而且给用户的使用和升级带来了很多困扰。\n\n从 v1.15.0 版本开始，Modern.js 自身的版本号和所有组成包的版本号，进行了统一。例如，Modern.js\nv1.15.0，意味着所有组成包的版本号也是 v1.15.0。 每次发布新版本，Modern.js 所有包都会使用统一的版本号执行发布。 Github 上仓库的\ntag 编号和 Modern.js 所有组成包的版本号是一一对应的。\n\n我们提供了专门的升级工具： @modern-js/upgrade，可以自动升级 Modern.js 到当前的最新版本。使用方式为，在项目根路径下执行：\n\nnpx @modern-js/upgrade\n\n\n\n模块工程支持 bundle 构建#\n\n模块工程（ @modern-js/module-tools ）对底层实现进行重构，新增 output.buildConfig 配置，用于提供更加丰富的构建功能。\n\n新的模块工程项目，不仅支持对产物做 bundless 构建，也支持 bundle 构建。通过配置 buildConfig 下的 buildType ，即可进行\nbundle 构建：\n\n\n\nexport default defineConfig({\n  output: {\n    buildConfig: {\n      buildType: 'bundle', // 采用 bundle 构建\n    },\n  },\n});\n\n\nbuildConfig 下还支持 bundleOptions 配置，可以对构建行为做更多的自定义：如设置产物文件名、是否进行代码分片、设置代码压缩方式等。\n\n\nReduck v1.1#\n\nReduck 作为 Modern.js 的第一方状态管理方案，发布 v1.1 版本，增加对 React 18 Concurrent Rendering\n的支持，并对开发体验和功能稳定性做了大量优化。\n\n新增 API：\n\n * useStore ：可以在组件内获取当前组件树共享的 Store，满足在组件外访问 Model 的场景需求。\n * handleEffect：一个工具函数，可以极大地简化异步数据获取的逻辑代码。\n * connect： HOC 风格的 API，用于访问 Model。\n\n开发体验方面，优化 Reduck 组成包的组织结构，减少用户侧依赖数量，现在只需要引入 @modern-js-reduck/react\n一个包（Modern.js 中 Reduck 功能已内置，无需手动引入包）；优化 API 的 TS 类型定义，改进类型信息的自动推导，整体达到 TS\n支持开箱即用。\n\n此外，对 Reduck 使用文档 和 API 文档 做了全面更新，提供了更加丰富和详尽的内容。\n\n\n其他更新#\n\n\n命令和配置#\n\n新增命令\n\n * upgrade：自动升级 Modern.js 版本。功能同执行 npx @modern-js/upgrade 命令。\n * inspect：通过该命令可以输出当前项目使用的完整 webpack 配置。\n * gen-release-note：自动根据当前仓库的 changesets 信息生成发布日志。此外，我们提供了包版本管理专题文档，方便大家更好的认识和使用\n   changesets 及相关功能。\n\n新增配置\n\n * source.preEntry：用于配置全局脚本，这段脚本会早于页面的代码执行。\n\n\nBFF#\n\n * 新增 afterLambdaRegisted hook。用于使用 Express 框架时，在 BFF\n   函数注册路由之后执行。可以用来添加错误处理逻辑，新增路由等。\n * 优化使用 Express 框架开发场景下的热更新性能。在比较大的项目中，BFF 函数更改，热更新也可以在几十毫秒内完成。\n\n\nSSR#\n\n * SSR 产物添加 Sourcemap，优化服务端调试 SSR 代码的体验。\n\n\nWeb Server#\n\n * 支持按入口设置响应头，使用方式请参考文档。","frontmatter":{"sidebar_position":99},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/community/blog/2022-0708-updates.md","_relativePath":"zh/community/blog/2022-0708-updates.md"},{"id":357,"title":"2022 年 9 ~ 10 月更新内容","routePath":"/community/blog/2022-0910-updates","lang":"zh","toc":[{"text":"支持 pnpm v7","id":"支持-pnpm-v7","depth":2,"charIndex":133},{"text":"服务端增加 Typescript 作为 ts 文件编译器","id":"服务端增加-typescript-作为-ts-文件编译器","depth":2,"charIndex":710},{"text":"其他更新","id":"其他更新","depth":2,"charIndex":1161},{"text":"配置更新","id":"配置更新","depth":3,"charIndex":1169},{"text":"底层依赖升级","id":"底层依赖升级","depth":3,"charIndex":1240},{"text":"功能预告","id":"功能预告","depth":2,"charIndex":1485}],"domain":"","content":"#\n\n> 发表于 2022.11.01\n\nModern.js 9 ~ 10 月的最新版本为 v1.21.0，本双月的主要更新有：\n\n * 支持 pnpm v7：完成框架对 pnpm v7 的支持。\n * 服务端增加 Typescript 作为 ts 文件编译器。\n\n\n支持 pnpm v7#\n\nModern.js 框架完成了对 pnpm v7 的变更适配。\n\n使用 npx @modern-js/create@modern-1 创建项目时会根据用户当前环境的 pnpm 版本进行安装依赖操作，并且在初始化项目中会在\n.npmrc 中添加 strict-peer-dependencies=false 配置，避免安装时由于 peerDependencies\n缺失导致安装依赖失败问题。 同时适配 release、deploy 命令对 pnpm v7 的支持。\n\npnpm v7 在命令传参方面姿势发生了变化，需注意：\n\n在使用 pnpm 调用 package.json 中的命令时，如果需要传递参数至 pnpm，需要将参数放到命令前。\n\n例如使用 pnpm --filter 参数执行 prepare 命令：\n\npnpm run --filter \"./packages/**\" prepare\n\n\n如果需要传递参数至命令，需要将参数放到命令后。\n\n例如，在如下 package.json 配置中：\n\n{\n  \"scripts\": {\n    \"command\": \"modern command\"\n  }\n}\n\n\n执行 command 命令时携带参数方式为：\n\npnpm run command --options\n\n\n\n服务端增加 Typescript 作为 ts 文件编译器#\n\n在 Modernjs 之前的版本中，我们为了保证前后端编译器的统一，使用了 Babel\n作为前后端默认的编译器，并保持相同的编译逻辑，但随着使用的项目增多，我们发现在一些服务端常用的语法场景下，Babel 编译 ts 有一些问题。\n\n因此，我们将服务端编译 ts 的编译器由 Babel 改为了 Typescript，在别名解析逻辑上与 Babel 版本保持一致，同样支持使用\ntsconfig.json 或者插件设置别名。\n\n在执行 build 命令时，已默认使用 Typescript 编译，并默认开启了类型校验，很多项目在 9、10 双月已经在使用。\n\n执行 dev 命令时，如果希望使用 Typescript 编译，需要安装 ts-node，tsconfig-paths 到\ndevDependencies，否则默认仍然使用 Babel 编译。在 Modern.js 2.0 中，我们将使用 ts-node 作为默认的编译器。\n\n\n其他更新#\n\n\n配置更新#\n\n * 支持在 tools.webpackChain 中获取 HtmlWebpackPlugin 对象，使用方式请参考文档。\n\n\n底层依赖升级#\n\n * husky 升级至 v8\n\n使用 npx @modern-js/create@modern-1 创建项目时，husky 会默认安装 v8 版本，并移除 package.json 中\nhusky 的配置，使用 .husky 文件夹的形式管理 husky 配置。\n\n在初次安装依赖时需要执行 npx husky install 进行 husky 初始化，默认项目会在 prepare 命令中完成，如果 husky\n配置未生效，可通过手动执行完成 husky 配置。\n\n\n功能预告#\n\nModern.js 团队目前除了正常开发维护 Modern 1.0 外，正在全力打造 Modern.js 2.0。\n\nModern.js 2.0 将带来新的构建体系，除了支持使用稳定的 webpack 进行构建，还即将支持将底层构建工具切换为自研的 Rust\nbundler，提供更流畅的编译速度。\n\nModern.js 2.0 将基于 React-Router v6 推荐嵌套路由作为新的路由方式；将默认支持 React 18 并提供 Streaming\nSSR 的支持，使用户体验更加流畅。","frontmatter":{"sidebar_position":98},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/community/blog/2022-0910-updates.md","_relativePath":"zh/community/blog/2022-0910-updates.md"},{"id":358,"title":"总览","routePath":"/community/blog/overview","lang":"zh","toc":[{"text":"Modern.js v2 发布：支持 Rspack 构建","id":"modernjs-v2-发布：支持-rspack-构建","depth":2,"charIndex":141},{"text":"React Streaming SSR 原理解析","id":"react-streaming-ssr-原理解析","depth":2,"charIndex":509},{"text":"React Server Component 介绍","id":"react-server-component-介绍","depth":2,"charIndex":1006},{"text":"2022 年 9 ~ 10 月更新内容","id":"2022-年-9-~-10-月更新内容","depth":2,"charIndex":1298},{"text":"2022 年 7 ~ 8 月更新内容","id":"2022-年-7-~-8-月更新内容","depth":2,"charIndex":1541}],"domain":"","content":"#\n\n欢迎来到 Modern.js 博客频道！\n\n在这里，你可以了解到 Modern.js 的最新进展和技术分享。\n\n--------------------------------------------------------------------------------\n\n\nModern.js v2 发布：支持 Rspack 构建#\n\n> 发表于 2023.03.16\n\n大家好，很高兴地向大家宣布，Modern.js v2 版本已经正式发布了！\n\nModern.js 是字节跳动 Web Infra 团队开源的一套 Web 工程体系。在开源以来的一年多时间里，Modern.js\n保持稳定的迭代节奏，数十位贡献者参与了开发，累计提交 2000+ 个 Pull Request，并支持了 Rspack 构建、嵌套路由、流式渲染等新特性。\n\n在这篇文章里，我们会和大家一起聊一聊 Modern.js 在过去一年多时间里的变化。\n\n了解更多 →\n\n--------------------------------------------------------------------------------\n\n\nReact Streaming SSR 原理解析#\n\n> 发表于 2022.12.16\n\nReact 18 提供了一种新的 SSR 渲染模式： Streaming SSR。通过 Streaming SSR，我们可以实现以下两个功能：\n\n * Streaming HTML：服务端可以分段传输 HTML 到浏览器，而不是像 React 18\n   以前一样，需要等待服务端渲染完成整个页面后才返回给浏览器。这样，浏览器可以更快的启动 HTML 的渲染，提高 FP、FCP 等性能指标。\n * Selective Hydration：在浏览器端 hydration 阶段，可以只对已经完成渲染的区域做\n   hydration，而不需要等待整个页面渲染完成、所有组件的 JS bundle 加载完成，才能开始\n   hydration。这样可以更早的对已经完成渲染的区域做事件绑定，从而让页面获得更好的可交互性。\n\n了解更多 →\n\n--------------------------------------------------------------------------------\n\n\nReact Server Component 介绍#\n\n> 发表于 2022.12.01\n\nReact 官方对 Server Component 是这样介绍的: zero-bundle-size React Server Components。\n\n这是一种实验性探索，但相信该探索是个未来 React 发展的方向，与 React Server Component 相关的周边生态正在积极的建设当中。\n\n了解更多 →\n\n--------------------------------------------------------------------------------\n\n\n2022 年 9 ~ 10 月更新内容#\n\n> 发表于 2022.11.01\n\nModern.js 9 ~ 10 月的最新版本为 v1.21.0，本双月的主要更新有：\n\n * 支持 pnpm v7：完成框架对 pnpm v7 的支持。\n * 服务端增加 Typescript 作为 ts 文件编译器。\n\n了解更多 →\n\n--------------------------------------------------------------------------------\n\n\n2022 年 7 ~ 8 月更新内容#\n\n> 发表于 2022.09.05\n\nModern.js 7 ~ 8 月的最新版本为 v1.17.0，本双月的主要更新有：\n\n * 支持 React 18：完成框架和插件对 React 18 的适配。\n * 包版本统一：Modern.js 所有组成包的版本号进行统一，提供升级命令。\n * 模块工程支持 bundle 构建：模块工程类型的项目，支持对产物做 bundle 构建。\n * Reduck v1.1：发布 Reduck v1.1，使用文档全面更新。\n\n了解更多 →","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/community/blog/overview.md","_relativePath":"zh/community/blog/overview.md"},{"id":359,"title":"Modern.js v2 发布：支持 Rspack 构建","routePath":"/community/blog/v2-release-note","lang":"zh","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":251},{"text":"定位","id":"定位","depth":2,"charIndex":672},{"text":"Modern.js 框架","id":"modernjs-框架","depth":2,"charIndex":1036},{"text":"Rspack 构建模式","id":"rspack-构建模式","depth":3,"charIndex":1423},{"text":"渐进式设计","id":"渐进式设计","depth":3,"charIndex":2149},{"text":"插件系统","id":"插件系统","depth":3,"charIndex":2706},{"text":"嵌套路由","id":"嵌套路由","depth":3,"charIndex":3346},{"text":"流式渲染","id":"流式渲染","depth":3,"charIndex":3861},{"text":"Modern.js Module","id":"modernjs-module","depth":2,"charIndex":4282},{"text":"基于 esbuild 构建","id":"基于-esbuild-构建","depth":3,"charIndex":4643},{"text":"Modern.js Doc","id":"modernjs-doc","depth":2,"charIndex":5221},{"text":"致谢","id":"致谢","depth":2,"charIndex":5783},{"text":"最后","id":"最后","depth":2,"charIndex":6264}],"domain":"","content":"#\n\n> 发表于 2023.03.16\n\n大家好，很高兴地向大家宣布，Modern.js v2 版本已经正式发布了！\n\nModern.js 是字节跳动 Web Infra 团队开源的一套 Web 工程体系。在开源以来的一年多时间里，Modern.js\n保持稳定的迭代节奏，数十位贡献者参与了开发，累计提交 2000+ 个 Pull Request，并支持了 Rspack 构建、嵌套路由、流式渲染等新特性。\n\n在这篇文章里，我们会和大家一起聊一聊 Modern.js 在过去一年多时间里的变化。\n\n\n\n\n背景#\n\n首先介绍一下我们为什么要做 Modern.js v2 版本，主要有以下几个原因：\n\n 1. 下沉更多能力：在字节跳动内部，Web Infra 团队整合了多个 Web 开发框架和解决方案，收敛技术栈，将通用能力下沉到底层的 Modern.js\n    工程体系中。\n 2. 拥抱 Rust 生态：随着社区中更多的前端工具链基于 Rust 重写，Modern.js 正在积极拥抱这一变化，将底层工具逐步替换为 Rust 实现。\n 3. 底层依赖升级：为了对 Modern.js 的底层依赖进行大版本升级，包括 React v18、React Router v6\n    等，从而引入流式渲染、嵌套路由等新能力。\n 4. 定位调整：从 2021 年开源以来，社区中的伙伴们给予我们很多有价值的反馈，这帮助我们对 Modern.js 的定位和架构进行更多地思考（详见下文）。\n\n以上因素促使我们完成了 Modern.js v2 版本。\n\n\n定位#\n\n在 v2 版本中，我们重新明确了 Modern.js 的定位：Modern.js 是字节跳动 Web\n工程体系的开源版本，它提供多个解决方案，来帮助开发者解决不同研发场景下的问题。\n\n目前我们开源了三个解决方案，分别面向 Web 应用开发场景、npm 包开发场景和文档站开发场景：\n\n\n\n作为 Modern.js 工程体系的一部分，以上每个解决方案都可以被单独使用，并且各自部署了独立的文档站点。开发者可以按需选择其中的一个或多个解决方案来使用。\n\n在代码层面，这三个解决方案按照统一的研发规范迭代，并复用同一套插件机制，因此，它们提供的研发体验也较为一致。大家如果对内部实现感兴趣，可以在 GitHub 上的\nModern.js 仓库 中找到它们的源代码。\n\n下面让我们来了解一下这三个解决方案提供的最新能力。\n\n\nModern.js 框架#\n\nModern.js 框架是一个基于 React 的渐进式 Web 开发框架。在字节跳动内部，我们将 Modern.js 封装为上层框架，并支撑了数千个 Web\n应用的研发。\n\n> 由于 Modern.js 框架的使用最为广泛，在下文中，我们会省略「框架」，直接称其为 Modern.js。\n\n在 Modern.js\n落地的过程中，我们收到很多业务同学提出的诉求，包括构建性能、框架的灵活性和可扩展性、页面加载性能等方面，相信社区中的开发者也会面临相似的问题。\n\n为了更好地满足这些诉求，Modern.js v2 提供了以下特性：\n\n * 通过引入 Rust 构建工具 —— Rspack 来提升构建性能。\n * 通过渐进式设计来保证框架的灵活性。\n * 通过插件系统来提供更好的可扩展性。\n * 通过嵌套路由来改善开发效率、优化加载性能。\n\n\nRspack 构建模式#\n\nModern.js v2 提供开箱即用的双构建工具支持，开发者可以在成熟的 Webpack 和更快的 Rspack 之间进行切换。大家对 Rspack\n可能还不太了解，Rspack 是由字节跳动开源的 Web 构建工具，基于 Rust 语言开发，具有高性能、可定制、兼容 Webpack 生态等特性。\n\n\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。经过 benchmark\n验证，Rspack 可以给 Modern.js 项目带来 5 ～ 10 倍编译性能的提升。\n\n\n\nModern.js 已支持在 Rspack 模式下使用框架的 70% 功能和配置项，包括服务器端渲染（SSR），静态站点生成（SSG）、嵌套路由、CSS\nModules 和 Tailwind CSS 等功能。除了功能，Modern.js 在 Rspack 模式下的配置项也与 Webpack\n模式基本一致，在我们的实际验证中，一个小型项目花几分钟就可以平滑切换到 Rspack 模式。\n\n目前，Rspack 项目以及 Modern.js 的 Rspack 模式仍在快速迭代中。在未来几个月内，我们将逐步对齐 Webpack 模式和 Rspack\n模式的绝大多数功能和配置，使更多项目能从 Webpack 平滑地过渡到 Rspack。\n\n> Rspack 已于 2023.03.10 号正式开源，你也可以在非 Modern.js 的项目中直接使用 Rspack 进行构建。如果你对 Rspack\n> 感兴趣，请阅读 「Rspack 正式发布了」来了解更多。\n\n\n渐进式设计#\n\n大家对 Modern.js 框架的第一印象可能是「一个大而全的框架」，但事实上，为了避免变得臃肿，Modern.js\n采取了渐进式设计，将所有功能建立在灵活的插件系统之上，因此具备按需启用和可插拔的能力。\n\nModern.js 期望能支持不同规模的项目研发，考虑到中大型项目和小型项目对功能的诉求存在差异，Modern.js\n的大多数功能都是按需启用的。在创建项目时，Modern.js 默认只安装核心模块，使 npm 依赖保持轻量；当需要用到额外功能时，你可以通过 modern\nnew 命令一键开启，并自动安装相关依赖。\n\n\n\n比如：\n\n * 对于基础的开发场景，项目中只需安装 Modern.js 的 CLI 工具 @modern-js/app-tools，即具备了开发调试、生产构建的能力。\n * 当你需要在应用中增加一些 BFF 接口时，可以执行 modern new 命令来启用 BFF 功能。启用后，Modern.js 会自动安装所需的 BFF\n   插件，以及某个 Node.js 框架对应的插件（如 Koa / Express）：\n\n\n\n目前，你可以通过 modern new 命令来按需开启以下功能，未来我们也会将更多功能加入到 new 命令中，使其能够被便捷地集成。\n\n\n\n\n插件系统#\n\n开发者在实际项目中使用 Web 研发框架时，除了使用开箱即用的能力，也会有很强的定制化诉求。因此，Modern.js 设计了一套灵活的插件系统来满足这一点。\n\nModern.js 可以划分为三个核心部分：CLI 工具、服务端和运行时。其中，CLI 工具负责提供 CLI 命令和打包构建能力；服务端提供 SSR、BFF\n等能力；运行时提供状态管理、路由等能力。\n\n\n\n我们为这三者分别设计了插件：\n\n * CLI 插件：对应 CLI 工具，负责控制 CLI 命令、打包构建流程。\n * Server 插件：对应服务端，用于处理服务端的生命周期以及客户端请求。\n * Runtime 插件：对应运行时，用于处理 React 组件渲染逻辑。\n\n这三种插件使用统一的 Hook 模型，并提供丰富的插件 API。比如，你可以使用插件做到：\n\n * 注册自定义的 CLI 命令\n * 修改 Rspack、PostCSS、Less、Sass 等基础工具的配置\n * 修改运行时需要渲染的 React 组件\n * 自定义控制台日志\n * 自定义 Node.js 服务器框架\n * ...\n\n在字节跳动内部，我们借助这些插件 API，结合公司内的基建和平台，封装出内部的企业级框架。如果你需要对 Modern.js 框架进行深度定制，也可以借助这些插件\nAPI 来完成。\n\n> 如果你对 Modern.js 的插件系统感兴趣，请阅读 「Modern.js - 自定义插件」文档。\n\n\n嵌套路由#\n\nModern.js v2 基于 React Router v6 提供了新的路由方式 —— 嵌套路由（Nested Routes）。\n\n如果大家了解过 Remix 或 Next.js 13，应该对嵌套路由不陌生了。嵌套路由与 Modern.js v1\n提供的约定式路由相似，也是一种基于文件系统的路由。\n\n在 Modern.js v2 中，我们约定在 src/routes\n目录下的文件，在应用启动时会自动生成对应的路由结构，页面的路由与文件结构是相呼应的，并且可以为资源加载带来一些性能优化。\n\nModern.js 的嵌套路由包含以下功能：\n\n * 资源加载：基于路由结构，并行加载多级路由资源，子组件资源加载不再受父组件渲染影响。并且将路由资源进一步细分，保证路由跳转时的最小资源加载。\n * 共享布局：在路由之间轻松共享 UI，同时保持状态，并避免多余的重新渲染。\n * 数据获取：基于路由结构完成多级路由的数据并行获取。\n\n在 Modern.js v2 中，只需要配置 runtime.router，即可开启嵌套路由：\n\n\n\n> 如果你对嵌套路由的细节感兴趣，请阅读「Modern.js - 路由」文档。\n\n\n流式渲染#\n\nModern.js v2 基于 React v18 的全新 API 支持了流式渲染（Streaming SSR）。\n\n如果大家关注去年 React v18 的版本更新，可能会注意到它提供了新的 Server Side APIs，并对 Suspense 做了完整支持。在\nModern.js v2 中，我们通过 React Router v6 暴露的能力，在框架层面支持了流式渲染。\n\n\n\n流式渲染利用 HTTP 的能力，允许将页面的 HTML\n分割成较小的块，并逐步将这些块从服务器发送到客户端。页面无需等待所有数据加载完成，即可呈现完整用户界面，因此与数据无关的局部内容能够更早地显示出来。\n\n在 Modern.js v2 中，只需要配置 server.ssr.mode，即可开启流式渲染：\n\n\n\n> 如果你想在 Modern.js 中使用 SSR 和流式渲染，请阅读「 Modern.js 服务端渲染（SSR）」文档。\n\n\nModern.js Module#\n\nModern.js Module 是我们针对 npm 包开发场景提供的解决方案，它为开发者提供了专业的 npm 包开发工具，能够更轻松地构建、调试和发布一个\nnpm 包。\n\n\n\nModern.js Module 的核心能力包括：\n\n * 构建能力：基于 esbuild 实现的构建工具，提供类型生成能力，能够高度定制构建产物。\n * 调试能力：基于 Storybook 调试项目，可以测试代码功能、验证构建产物可用性。\n * 测试能力：集成 Jest 测试能力，能够开箱即用地编写你的测试代码。\n * 版本管理能力：基于 Changeset 提供版本管理命令，涵盖从开发到发布的过程。\n * 扩展能力：提供包含丰富 Hooks 的插件机制，支持扩展调试能力，或对流程进行自定义。\n\n\n基于 esbuild 构建#\n\n在 v2 版本中，我们以 esbuild 为核心，扩展其插件机制，并结合 SWC 实现了一个通用的模块构建工具，它的特性包括：\n\n * 支持 bundle 和 bundleless 两种模式的构建。你可以选择构建产物的形式 —— 是打包处理后的 bundle 产物，还是直接通过\n   transform 处理的 bundleless 产物。\n * 相较于 esbuild，提供更丰富的构建能力和插件 Hook。例如，在样式方面，默认支持 Less、Sass、PostCSS 和 CSS\n   Modules，并支持静态资源处理、SVGR 等常用能力。这些能力在 bundle 和 bundleless 模式下均可使用。\n\n在生成 TS 类型文件上，Modern.js Module v2 也支持新的方式：\n\n * 类型文件的 bundle 处理：对生成的类型文件进行打包处理，生成一个单独的类型文件。\n * 类型文件里的别名处理：对生成的类型文件里包含的别名路径进行转换。\n\n总的来说，相较于 v1 版本，Modern.js Module v2 提供了更完整的构建能力，同时构建效率也有明显提升。\n\n> 如果你对 Modern.js Module 感兴趣，请移步「Modern.js Module 文档」来了解更多。\n\n\nModern.js Doc#\n\nModern.js Doc 是一个面向文档站场景的框架，它的目标是给开发者提供一个简单、高效、可扩展的文档站解决方案。\n\n\n\n目前，Modern.js Doc 包含如下能力：\n\n * 基于 Rspack 构建：项目构建和 HMR 速度飞快，提供愉悦的开发和生产部署体验。\n * 支持 MDX 语法：在普通 Markdown 语法的基础上可以嵌入 React 组件和 JSX 语法。\n * 全文搜索：内置开箱即用的全文搜索能力，基于 FlexSearch 实现。\n * 支持国际化：提供多语言文档切换功能，且支持多语言内容搜索。\n * 自定义主题：内置一套默认主题，你可以基于这套主题进行扩展，也可以从零定制一套自定义主题。\n * 插件机制：提供丰富的插件钩子能力，让你能够充分自定义扩展框架功能。\n\n我们做 Modern.js Doc 的初心，是为了解决我们团队内的文档站搭建需求。随着 Modern.js Doc\n的功能逐渐完整，我们也将它开放给社区使用，使它能发挥更大的价值。\n\n目前，Modern.js Doc 仍处于 beta 测试状态，相关源代码已经开放在 Modern.js 仓库 中，并提供了基础的\n使用文档。在未来，我们将继续投入，使之成为一个完成度更高的文档解决方案。\n\n\n致谢#\n\nModern.js 中的部分代码实现参考了社区中的开源项目，我们对这些项目表示衷心的感谢：\n\n * @modern-js/bundle-require: 修改自 bundle-require。\n * @modern-js/plugin: hook API 的实现参考了 farrow-pipeline。\n * @modern-js/builder: moduleScope 和 fileSize 插件参考了\n   create-react-app，TsConfigPathsPlugin 参考了\n   tsconfig-paths-webpack-plugin，generateMetaTags 函数参考了 html-webpack-plugin。\n * @modern-js/plugin-testing: jest runner 参考了 jest-cli。\n * @modern-js/doc-tools: 部分样式参考了 vitepress。\n * @modern-js/plugin-data-loader: 部分实现参考了 remix。\n\n\n最后#\n\n现阶段 Modern.js 仍是一个很年轻的开源项目，在未来，我们将继续拥抱长期主义，持续打磨功能和文档，并以更透明的方式与社区共同协作。\n\n如果你有兴趣尝试一下 Modern.js，欢迎试用并留下你的反馈意见~\n\n * 官网：modernjs.dev\n * GitHub 仓库：github.com/web-infra-dev/modern.js","frontmatter":{"sidebar_label":"Modern.js v2 发布","sidebar_position":97},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/community/blog/v2-release-note.mdx","_relativePath":"zh/community/blog/v2-release-note.mdx"},{"id":360,"title":"贡献指南","routePath":"/community/contributing-guide","lang":"zh","toc":[{"text":"设置开发环境","id":"设置开发环境","depth":2,"charIndex":133},{"text":"Fork 仓库","id":"fork-仓库","depth":3,"charIndex":143},{"text":"安装 Node.js","id":"安装-nodejs","depth":3,"charIndex":202},{"text":"安装 pnpm","id":"安装-pnpm","depth":3,"charIndex":498},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":578},{"text":"设置 Git 邮箱","id":"设置-git-邮箱","depth":3,"charIndex":795},{"text":"代码变更和构建","id":"代码变更和构建","depth":2,"charIndex":1114},{"text":"创建一个新分支","id":"创建一个新分支","depth":3,"charIndex":1162},{"text":"构建 Package","id":"构建-package","depth":3,"charIndex":1243},{"text":"测试","id":"测试","depth":2,"charIndex":1647},{"text":"添加新测试","id":"添加新测试","depth":3,"charIndex":1653},{"text":"运行单元测试","id":"运行单元测试","depth":3,"charIndex":1749},{"text":"运行 E2E 测试","id":"运行-e2e-测试","depth":3,"charIndex":1910},{"text":"Linting","id":"linting","depth":2,"charIndex":2186},{"text":"文档","id":"文档","depth":2,"charIndex":2358},{"text":"提交变更","id":"提交变更","depth":2,"charIndex":2879},{"text":"添加 Changeset","id":"添加-changeset","depth":3,"charIndex":2887},{"text":"提交你的变更","id":"提交你的变更","depth":3,"charIndex":3031},{"text":"PR 标题格式","id":"pr-标题格式","depth":3,"charIndex":3077},{"text":"发布","id":"发布","depth":2,"charIndex":3292}],"domain":"","content":"#\n\n感谢你有兴趣为 Modern.js 做贡献！在开始你的贡献之前，请花几分钟时间阅读以下指南。\n\n--------------------------------------------------------------------------------\n\n\n设置开发环境#\n\n\nFork 仓库#\n\nFork Modern.js 仓库到你的 GitHub 账户，然后 clone 到你的本地。\n\n\n安装 Node.js#\n\n我们推荐使用 Node.js 16 或 18。你可以通过以下命令查看当前使用的 Node.js 版本：\n\nnode -v\n#v16.18.0\n\n\n如果你当前环境没有安装 Node.js，可以使用 nvm或者 fnm 来安装它。\n\n以下是如何通过 nvm 安装 Node.js 16 LTS 版本的示例：\n\n# 安装 Node.js 16 的 LTS 版本\nnvm install 16 --lts\n\n# 将新安装的 Node.js 16 设为默认版本\nnvm alias default 16\n\n# 切换到新安装的 Node.js 16\nnvm use 16\n\n\n\n安装 pnpm#\n\n# 使用 corepack 启用 pnpm，仅在 Node.js >= `v14.19.0` 上可用\ncorepack enable\n\n\n\n安装依赖#\n\npnpm install\n\n\n这将完成：\n\n * 安装所有依赖项\n * 在 monorepo 中的 packages 之间创建 symlinks\n * 运行 prepare 脚本来构建所有包（这将需要一些时间，但可以保证所有包都被正确构建）\n\n> 在此之后，你通常不需要一次性构建所有 packages。如果你正在开发的新功能依赖另一个 package 的最新代码，通常只构建指定的 package\n> 就足够了。\n\n\n设置 Git 邮箱#\n\n请确保在 中设置了电子邮件，当你提交 Pull Request 时将需要它。\n\n检查你的 git 客户端是否已配置邮箱：\n\ngit config --list | grep email\n\n\n全局设置邮箱：\n\ngit config --global user.email \"SOME_EMAIL@example.com\"\n\n\n针对本地仓库设置邮箱：\n\ngit config user.email \"SOME_EMAIL@example.com\"\n\n\n--------------------------------------------------------------------------------\n\n\n代码变更和构建#\n\n当你在 fork 的仓库中设置完本地开发环境后，我们就可以开始开发了。\n\n\n创建一个新分支#\n\n建议在一个新的分支上开发，这样便于后续提交 pull request：\n\ngit checkout -b MY_BRANCH_NAME\n\n\n\n构建 Package#\n\n要构建你要更改的 package，首先打开 package 目录，然后执行 build 命令：\n\n# 将 some-path 替换为你要构建的 package 的路径\ncd ./packages/some-package\npnpm run build\n\n\n此外，你可以使用 --filter 选项从仓库根目录来构建指定的 package：\n\npnpm run --filter @modern-js/some-package build\n\n\n构建所有包：\n\npnpm run prepare\n\n\n如果你需要清理项目中的所有 node_modules/*，执行 reset 命令：\n\npnpm run reset\n\n\n--------------------------------------------------------------------------------\n\n\n测试#\n\n\n添加新测试#\n\n如果你进行了 bugfix，或者添加了需要测试的代码，请添加一些测试代码。\n\n你可以在 /tests 文件夹中添加单元测试用例。测试语法基于 Jest 和 Vitest。\n\n\n运行单元测试#\n\n在提交 pull request 之前，为了确保本次变更没有引入缺陷，你可以通过执行以下命令运行单元测试：\n\npnpm run test\n\n\n你也可以使用 --filter 选项运行单个包的单元测试：\n\npnpm run --filter @modern-js/some-package test\n\n\n\n运行 E2E 测试#\n\n除了单元测试之外，Modern.js 仓库还包括端到端 (E2E) 测试，用于检查整个应用程序的功能。\n\n你可以执行 test:e2e 命令来运行 E2E 测试：\n\npnpm run test:e2e\n\n\n如果需要运行指定的测试，可以添加关键字进行过滤：\n\n# 只运行带有 copy-assets 关键词的测试用例\nnpx jest copy-assets\n\n\n--------------------------------------------------------------------------------\n\n\nLinting#\n\n为了帮助保持代码风格的一致性和可读性，我们使用 ESLint 对代码进行校验。\n\n你可以执行以下命令来运行 Linter：\n\npnpm run lint\n\n\n--------------------------------------------------------------------------------\n\n\n文档#\n\n目前 Modern.js 提供英文和中文文档。如果你熟悉中文，请同时更新中英文文档。否则，只需更新英文文档即可。\n\n你可以在 packages/document 文件夹中找到所有文档：\n\nroot\n└─ packages\n   └─ document\n       ├─ builder-doc    # Modern.js Builder 文档\n       ├─ doc-tools-doc  # Modern.js Doc 文档\n       ├─ main-doc       # Modern.js Framework 文档\n       └─ module-doc     # Modern.js Module 文档\n\n\n文档站使用 Modern.js Doc 构建，文档内容可以使用 markdown 或 mdx 语法编写。详细使用方法可以参考 Modern.js Doc 文档。\n\nModern.js Doc 的源代码可以在 这个文件夹 中找到。\n\n--------------------------------------------------------------------------------\n\n\n提交变更#\n\n\n添加 Changeset#\n\nModern.js 使用 Changesets 来管理版本和 Changelog。\n\n如果你修改了一些包，则需要为本次变更添加一个新的变更集。请运行 change 命令来选择更改的包并添加 changeset 信息。\n\npnpm run change\n\n\n\n提交你的变更#\n\n提交变更到 fork 后的仓库，并 创建 pull request。\n\n\nPR 标题格式#\n\nPR 标题的格式遵循 Conventional Commits。\n\n一个例子：\n\nfeat(plugin-swc): 添加 `xxx` 配置项\n^ ^ ^\n| | |__ 主题\n| |_______ 范围\n|____________ 类型\n\n\n--------------------------------------------------------------------------------\n\n\n发布#\n\nModern.js 使用 Changesets 来管理版本和 changelog。\n\n仓库的维护者可以将所有包的新版本发布到 npm。\n\n以下是发布的步骤（我们通常使用 CI 进行发布，并避免在本地发布 npm 包）：\n\n 1. 拉取 main 分支的最新代码。\n 2. 安装依赖：\n\npnpm i\n\n\n 3. 构建 packages：\n\npnpm prepare\n\n\n 4. 升级版本：\n\npnpm run bump\n\n\n 5. 提交版本变更。\n\ngit add .\ngit commit -m \"Release va.b.c\"\n","frontmatter":{"sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/community/contributing-guide.mdx","_relativePath":"zh/community/contributing-guide.mdx"},{"id":361,"title":"版本发布","routePath":"/community/releases","lang":"zh","toc":[{"text":"更新日志","id":"更新日志","depth":2,"charIndex":3},{"text":"版本规范","id":"版本规范","depth":2,"charIndex":58},{"text":"发版周期","id":"发版周期","depth":2,"charIndex":175},{"text":"版本升级","id":"版本升级","depth":2,"charIndex":295}],"domain":"","content":"#\n\n\n更新日志#\n\n请访问 GitHub - Release 来了解 Modern.js 每个版本的变更内容。\n\n\n版本规范#\n\nModern.js 遵循 Semantic Versioning 语义化版本规范。\n\n * 主版本号：包含不兼容的 API 变更。\n * 次版本号：包含向下兼容的功能性变更。\n * 修订号：包含向下兼容的问题修正。\n\n\n发版周期#\n\n * Modern.js 通常在每周四发布一个正式版本。\n * 当出现较为严重的问题时，我们会在当天发布修订版本。\n * 我们期望保持 Modern.js v2 的稳定和兼容，目前没有发布下一个 Major 版本的计划。\n\n\n版本升级#\n\n当你需要升级项目中的 Modern.js 版本时，可以使用 modern upgrade 命令，参考 升级。\n\nnpx modern upgrade\n","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/community/releases.mdx","_relativePath":"zh/community/releases.mdx"},{"id":362,"title":"案例展示","routePath":"/community/showcase","lang":"zh","toc":[{"text":"案例","id":"案例","depth":2,"charIndex":-1}],"domain":"","content":"#\n\n欢迎来到 Modern.js 的案例展示页面！在这里，我们展示了一些基于 Modern.js 所实现的网站。\n\n如果你使用 Modern.js 构建了一个网站，欢迎你与社区分享它。只需回复 GitHub 讨论贴\n并附上你网站的链接即可。我们会定期收集内容，并将它们展示在当前页面。\n\n\n案例#","frontmatter":{"sidebar_position":0},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/community/showcase.mdx","_relativePath":"zh/community/showcase.mdx"},{"id":363,"title":"团队","routePath":"/community/team","lang":"zh","toc":[{"text":"核心团队成员","id":"核心团队成员","depth":2,"charIndex":46},{"text":"所有贡献者","id":"所有贡献者","depth":2,"charIndex":80}],"domain":"","content":"#\n\nModern.js 的开发由字节跳动的 Modern.js 团队和社区贡献者驱动。\n\n\n核心团队成员#\n\n以下是 Modern.js 团队的核心成员：\n\n\n所有贡献者#\n\n感谢以下伙伴们为 Modern.js 做出的贡献：","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/community/team.mdx","_relativePath":"zh/community/team.mdx"},{"id":364,"title":"autoLoadPlugins (自动注册插件)","routePath":"/configure/app/auto-load-plugin","lang":"zh","toc":[{"text":"手动注册插件","id":"手动注册插件","depth":3,"charIndex":61},{"text":"自动注册插件","id":"自动注册插件","depth":3,"charIndex":195}],"domain":"","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n用于配置 Modern.js 是否开启自动注册插件。\n\n\n手动注册插件#\n\n默认情况下，安装插件后，你需要在 modern.config.ts 文件中手动注册插件。\n\n\n\n\nexport default defineConfig({\n  plugins: [appTools(), i18nPlugin()],\n});\n\n\n\n自动注册插件#\n\n除了手段注册，Modern.js 还提供自动注册插件的方式: 将 autoLoadPlugin 配置项置为 true。\n\n\n\nexport default defineConfig({\n  autoLoadPlugins: true,\n});\n\n\nModern.js 将通过以下几个步骤帮你自动注册插件\n\n 1. Modern.js 在内部维护一份官方插件列表。\n\nconst InternalPlugins = ['@modern-js/app-tools', '@modern-js/plugin-i18n', ...];\n\n\n 2. Modern.js 将读取你的 package.json 文件，收集依赖信息。\n\n\"dependencies\": {\n  \"@modern-js/plugin-i18n\": \"x.x.x\"\n  ...\n},\n\"devDependencies\": {\n  \"@modern-js/app-tools\": \"x.x.x\"\n  ...\n}\n\n\n 3. Modern.js 观察到你安装了 @modern-js/plugin-i18n 和 @modern-js/app-tools\n    等依赖后，将会引入插件自动注册。\n\n可以注意到这种方式相对黑盒，你甚至对加载插件的过程是无感知的。我们希望更多的细节暴露给开发者，能让开发者去控制这一过程。\n\n因此我们更加推荐你手动注册插件。","frontmatter":{"title":"autoLoadPlugins (自动注册插件)","sidebar_position":11},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/auto-load-plugin.mdx","_relativePath":"zh/configure/app/auto-load-plugin.mdx"},{"id":365,"title":"enableHandleWeb","routePath":"/configure/app/bff/enable-handle-web","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： boolean\n\n * 默认值： false\n\n注意\n\n请先在当前应用项目根目录使用【new】 启用 BFF 功能。\n\n默认情况下，BFF 服务只能处理 BFF API 的请求。\n\n当该值设置为 true 时，页面请求流量也会经过 BFF，并且 Modern.js 内置的页面渲染的逻辑默认会作为 BFF 服务的最后一个中间件运行。\n\nexport default defineConfig({\n  bff: {\n    enableHandleWeb: true,\n  },\n});\n","frontmatter":{"title":"enableHandleWeb"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/bff/enable-handle-web.mdx","_relativePath":"zh/configure/app/bff/enable-handle-web.mdx"},{"id":366,"title":"bff.prefix","routePath":"/configure/app/bff/prefix","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： string\n\n * 默认值： /api\n\n注意\n\n请先在当前应用项目根目录使用【new】 启用 BFF 功能。\n\n默认情况下，BFF API 目录下的路由访问前缀是 /api, 如下目录结构：\n\napi\n└── hello.ts\n\n\napi/hello.ts 访问时对应的路由为 localhost:8080/api/hello。\n\n该配置选项可以修改默认的路由前缀：\n\nexport default defineConfig({\n  bff: {\n    prefix: '/api-demo',\n  },\n});\n\n\n对应的 api/hello.ts 访问路由为 localhost:8080/api-demo/hello。","frontmatter":{"sidebar_label":"prefix"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/bff/prefix.mdx","_relativePath":"zh/configure/app/bff/prefix.mdx"},{"id":367,"title":"bff.proxy","routePath":"/configure/app/bff/proxy","lang":"zh","toc":[{"text":"常见用法","id":"常见用法","depth":2,"charIndex":891},{"text":"解决接口跨域问题","id":"解决接口跨域问题","depth":3,"charIndex":899}],"domain":"","content":"#\n\n * 类型： Record\n\n * 默认值： {}\n\n注意\n\n请先在当前应用项目根目录使用【new】 启用 BFF 功能。\n\n通过简单配置，Modern.js 可以将发送给 BFF server 的请求，自动代理到指定的服务上。\n\n在 modern.server-runtime.config.js 中加入以下配置；即可开启代理：\n\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api': 'https://cnodejs.org',\n    },\n  },\n});\n\n\n假设 Modern.js BFF server 的地址是 localhost:8080，所有以 api 开头的请求都会被代理到\nhttps://cnodejs.org，如 localhost:8080/api/v1/topics 的请求会被代理到\nhttps://cnodejs.org/api/v1/topics。\n\n这里还可以进行路径重写，如将发送到 localhost:8080/api/topics 的请求代理到\nhttps://cnodejs.org/api/v1/topics。\n\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api': {\n        target: 'https://cnodejs.org',\n        pathRewrite: { '/api/topics': '/api/v1/topics' },\n        changeOrigin: true,\n      },\n    },\n  },\n});\n\n\n与 dev.proxy 不同，本节所介绍的代理只作用于进入 BFF/API 服务的请求；同时，这一配置不但可以在开发环境中使用，在生产环境中也会代理相应的请求。\n\nBFF Proxy 使用了强大的 http-proxy-middleware，如果需要更多高级的用法， 可以查看它的文档。\n\n\n常见用法#\n\n\n解决接口跨域问题#\n\n在项目开发过程中，因为 web 页面和接口服务不是部署在同一个域名下，常常会遇到跨域问题。 解决跨域问题的方式有很多，在这里我们使用 bff.proxy\n可以轻松解决跨域问题。\n\nINFO\n\nBFF proxy 模式下，如果不需要写 BFF 的接口， API 目录可以删除；此时 BFF proxy 仍会开启。\n\n如下所示，在 modern.server-runtime.config.ts 中，写入如下配置；我们将所有 web 页面发送到同域的以 /api\n开头的请求代理到另一个域名的服务上。\n\nexport default defineServerConfig({\n  bff: {\n    proxy: {\n      '/api': 'https://cnodejs.org',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"proxy"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/bff/proxy.mdx","_relativePath":"zh/configure/app/bff/proxy.mdx"},{"id":368,"title":"builderPlugins (构建插件)","routePath":"/configure/app/builder-plugins","lang":"zh","toc":[{"text":"注意事项","id":"注意事项","depth":2,"charIndex":179},{"text":"何时使用","id":"何时使用","depth":2,"charIndex":382},{"text":"示例","id":"示例","depth":2,"charIndex":599},{"text":"使用 npm 上的插件","id":"使用-npm-上的插件","depth":3,"charIndex":627},{"text":"使用本地插件","id":"使用本地插件","depth":3,"charIndex":760},{"text":"插件配置项","id":"插件配置项","depth":3,"charIndex":883}],"domain":"","content":"#\n\n * 类型： BuilderPlugin[]\n * 默认值： []\n\n用于配置 Modern.js Builder 构建插件。\n\nModern.js Builder 是 Modern.js 底层的构建引擎，请阅读 构建能力 了解相关背景。\n\n如果你想了解 Builder 插件的编写方式，可以参考 Modern.js Builder - 插件系统。\n\n\n注意事项#\n\n该选项用于配置 Modern.js Builder 构建插件，如果你需要配置其他类型的插件，请选择对应的配置方式：\n\n * 配置 Modern.js 框架插件，请使用 plugins 配置项。\n * 配置 webpack 插件，请使用 tools.webpack 或 tools.webpackChain 配置项。\n * 配置 Babel 插件，请使用 tools.babel 配置项。\n\n\n何时使用#\n\n大部分场景下，我们推荐你使用 Modern.js 框架插件，框架插件可以通过 plugins 字段进行注册。因为框架插件提供的 API 更丰富、能力更强，而\nBuilder 插件提供的 API 只能用于构建场景。\n\n当你需要引用一些现有的 Builder 插件（并且在 Modern.js 中没有相关能力），或是在不同的框架之间复用 Builder 插件时，你可以使用\nbuilderPlugins 字段进行注册。\n\n\n示例#\n\n下面是 Builder 插件的使用示例。\n\n\n使用 npm 上的插件#\n\n使用 npm 上的插件，需要通过包管理器安装插件，并通过 import 引入。\n\n\n\nexport default defineConfig({\n  builderPlugins: [myBuilderPlugin()],\n});\n\n\n\n使用本地插件#\n\n使用本地代码仓库中的插件，直接通过相对路径 import 引入即可。\n\n\n\nexport default defineConfig({\n  builderPlugins: [myBuilderPlugin()],\n});\n\n\n\n插件配置项#\n\n如果插件提供了一些自定义的配置项，可以通过插件函数的参数传入配置。\n\n\n\nexport default defineConfig({\n  builderPlugins: [\n    myBuilderPlugin({\n      foo: 1,\n      bar: 2,\n    }),\n  ],\n});\n","frontmatter":{"title":"builderPlugins (构建插件)","sidebar_position":10},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/builder-plugins.mdx","_relativePath":"zh/configure/app/builder-plugins.mdx"},{"id":369,"title":"deploy.microFrontend","routePath":"/configure/app/deploy/microFrontend","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":277},{"text":"配置项","id":"配置项","depth":2,"charIndex":393},{"text":"enableHtmlEntry","id":"enablehtmlentry","depth":3,"charIndex":400},{"text":"externalBasicLibrary","id":"externalbasiclibrary","depth":3,"charIndex":638}],"domain":"","content":"#\n\n * 类型： object\n * 默认值： { enableHtmlEntry: true, externalBasicLibrary: false }\n\ninterface MicroFrontend {\n  enableHtmlEntry?: boolean;\n  externalBasicLibrary?: boolean;\n  moduleApp?: string;\n}\n\n\n开发者可使用 deploy.microFrontend 属性来配置微前端子应用的信息。\n\n注意\n\n需要先通过 pnpm run new 启用「微前端」 功能。\n\n\n示例#\n\nexport default defineConfig({\n  deploy: {\n    microFrontend: {\n      enableHtmlEntry: true,\n    },\n  },\n});\n\n\n\n配置项#\n\n\nenableHtmlEntry#\n\n * 类型： boolean\n\n * 默认值： true\n\n是否启用 html 入口的功能，默认为 true，将子应用构建成 HTML 模式，Garfish 支持了 html 入口，可以开启开选项，体验对应功能，为\nHTML 入口时直接将子应用 entry 指向子应用的 html 即可。\n\n可以通过设置为 false, 表明子应用构建为 js，构建为 js 后子应用无法独立运行，为 JS 入口时将子应用的入口文件指向子应用的 JS\n\n\nexternalBasicLibrary#\n\n * 类型： boolean\n\n * 默认值： false\n\n是否 external 基础库，当设置为 true 时，当前子应用将会 external：react、react-dom，EdenX 主应用会自动\nsetExternal 这两个基础库，如果其他类型的框架请通过 Garfish.setExternal 增加 react、react-dom 依赖","frontmatter":{"sidebar_label":"microFrontend"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/deploy/microFrontend.mdx","_relativePath":"zh/configure/app/deploy/microFrontend.mdx"},{"id":370,"title":"dev.assetPrefix","routePath":"/configure/app/dev/asset-prefix","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":4,"charIndex":305},{"text":"String 类型","id":"string-类型","depth":4,"charIndex":521}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.assetPrefix。\n\n * 类型： boolean | string\n * 默认值： '/'\n\n设置开发环境下的静态资源 URL 前缀，对应 webpack 的 output.publicPath 配置。\n\nassetPrefix 会影响构建产物中绝大部分静态资源的 URL，包括 JavaScript 文件、CSS\n文件、图片、视频等。如果指定了一个错误的值，则在加载这些资源时可能会出现 404 错误。\n\n该配置项仅用于开发环境。在生产环境下，请使用 output.assetPrefix 配置项进行设置。\n\nBoolean 类型#\n\n如果设置 assetPrefix 为 true，Builder 会使用 http://localhost:port/ 作为 URL 前缀：\n\nexport default {\n  dev: {\n    assetPrefix: true,\n  },\n};\n\n\n对应 JS 文件在浏览器中加载的地址如下：\n\n\n\n\n如果设置 assetPrefix 为 false 或不设置，则默认使用 / 作为访问前缀。\n\nString 类型#\n\n当 assetPrefix 的值为 string 类型时，字符串会作为前缀，自动拼接到静态资源访问 URL 上：\n\nexport default {\n  dev: {\n    assetPrefix: 'http://example.com/assets/',\n  },\n};\n\n\n对应 JS 文件在浏览器中加载的地址如下：\n\n\n","frontmatter":{"sidebar_label":"assetPrefix"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/dev/asset-prefix.mdx","_relativePath":"zh/configure/app/dev/asset-prefix.mdx"},{"id":371,"title":"dev.beforeStartUrl","routePath":"/configure/app/dev/before-start-url","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.beforeStartUrl。\n\n * 类型： () => Promise | void\n * 默认值： undefined\n\ndev.beforeStartUrl 用于在打开 startUrl 前执行一段回调函数，该配置项需要与 dev.startUrl 一同使用。\n\nexport default {\n  dev: {\n    startUrl: true,\n    beforeStartUrl: async () => {\n      await doSomeThing();\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"beforeStartUrl"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/dev/before-start-url.mdx","_relativePath":"zh/configure/app/dev/before-start-url.mdx"},{"id":372,"title":"dev.hmr","routePath":"/configure/app/dev/hmr","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.hmr。\n\n * 类型： boolean\n * 默认值： true\n\n是否开启 Hot Module Replacement 热更新能力。\n\n当 hmr 设置为 false 时，将不再提供热更新和 react-refresh 功能。\n\nexport default {\n  dev: {\n    hmr: false,\n  },\n};\n","frontmatter":{"sidebar_label":"hmr"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/dev/hmr.mdx","_relativePath":"zh/configure/app/dev/hmr.mdx"},{"id":373,"title":"dev.host","routePath":"/configure/app/dev/host","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.host。\n\n * 类型： string\n * 默认值： 0.0.0.0\n\n指定 dev server 启动时监听的 host。\n\n默认情况下，dev server 会监听 0.0.0.0，这代表监听所有的网络接口，包括 localhost 和公网地址。\n\n如果你希望 dev server 只监听 localhost，可以设置为：\n\nexport default {\n  dev: {\n    host: 'localhost',\n  },\n};\n","frontmatter":{"sidebar_label":"host"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/dev/host.mdx","_relativePath":"zh/configure/app/dev/host.mdx"},{"id":374,"title":"dev.https","routePath":"/configure/app/dev/https","lang":"zh","toc":[{"text":"自动生成证书","id":"自动生成证书","depth":4,"charIndex":337},{"text":"手动设置证书","id":"手动设置证书","depth":4,"charIndex":851}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.https。\n\n * 类型： boolean | { key: string; cert: string }\n * 默认值： false\n\n配置该选项后，可以开启 Dev Server 对 HTTPS 的支持，同时会禁用 HTTP 服务器。\n\n开启前：\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n\n开启后：\n\n  > Local:    https://localhost:8080/\n  > Network:  https://192.168.0.1:8080/\n\n\n自动生成证书#\n\n你可以直接将 https 设置为 true，Builder 会基于 devcert 来自动生成 Dev Server 所需的 HTTPS 证书。\n\n使用这种方式时，你需要在当前项目中手动安装 devcert 依赖：\n\n# npm\nnpm install devcert@1.2.2 -D\n\n# yarn\nyarn add devcert@1.2.2 -D\n\n# pnpm\npnpm add devcert@1.2.2 -D\n\n\n然后配置 dev.https 为 true 即可：\n\nexport default {\n  dev: {\n    https: true,\n  },\n};\n\n\n该方式有一定局限性，由于 devcert 目前不支持 IP addresses，因此访问 Network 域名时，会遇到「您的连接不是私密连接」的问题。\n\n此问题的解决方法为：点击 Chrome 浏览器问题页面的「高级」->「继续前往 192.168.0.1（不安全）」。\n\nTIP\n\nhttps 代理自动安装证书需要获取 root 权限, 请根据提示输入密码即可。 密码仅在信任证书时使用，不会泄漏或者用于其他环节。\n\n手动设置证书#\n\n你也可以在 dev.https 选项中手动传入 HTTPS 服务器所需要的证书和对应的私钥，这个参数将直接传递给 Node.js 中 https 模块的\ncreateServer。\n\n具体可以参考 https.createServer。\n\n\n\nexport default {\n  dev: {\n    https: {\n      key: fs.readFileSync('certificates/private.pem'),\n      cert: fs.readFileSync('certificates/public.pem'),\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"https"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/dev/https.mdx","_relativePath":"zh/configure/app/dev/https.mdx"},{"id":375,"title":"dev.port","routePath":"/configure/app/dev/port","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":151}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.port。\n\n * 类型： number\n * 默认值： 8080\n\n设置 Dev Server 监听的端口号。\n\n默认情况下，Dev Server 会监听 8080 端口，并在端口被占用时自动递增端口号。\n\n\n示例#\n\n将端口设置为 3000：\n\nexport default {\n  dev: {\n    port: 3000,\n  },\n};\n","frontmatter":{"sidebar_label":"port"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/dev/port.mdx","_relativePath":"zh/configure/app/dev/port.mdx"},{"id":376,"title":"dev.progressBar","routePath":"/configure/app/dev/progress-bar","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.progressBar。\n\n * 类型：\n\ntype ProgressBar =\n  | boolean\n  | {\n      id?: string;\n    };\n\n\n * 默认值： true\n\n是否在编译过程中展示进度条。\n\nexport default {\n  dev: {\n    progressBar: false,\n  },\n};\n\n\n如果需要修改进度条左侧显示的文本内容，可以设置 id 选项：\n\nexport default {\n  dev: {\n    progressBar: {\n      id: 'Some Text',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"progressBar"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/dev/progress-bar.mdx","_relativePath":"zh/configure/app/dev/progress-bar.mdx"},{"id":377,"title":"dev.proxy","routePath":"/configure/app/dev/proxy","lang":"zh","toc":[{"text":"注册插件","id":"注册插件","depth":3,"charIndex":110},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":410},{"text":"String 类型","id":"string-类型","depth":3,"charIndex":738},{"text":"启动代理","id":"启动代理","depth":3,"charIndex":987}],"domain":"","content":"#\n\n * 类型： string | Object\n * 默认值： null\n\n该选项用于在开发环境下启用基于 whistle 的全局代理，可以用来查看、修改 HTTP/HTTPS 请求、响应、也可以用作代理服务器。\n\n\n注册插件#\n\n使用该选项前，你需要提前安装和注册 @modern-js/plugin-proxy 插件：\n\n# npm\nnpm add @modern-js/plugin-proxy -D\n\n# yarn\nyarn add @modern-js/plugin-proxy -D\n\n# pnpm\npnpm add @modern-js/plugin-proxy -D\n\n\n安装完成后，在 modern.config.ts 文件中注册插件：\n\n\n\n\nexport default defineConfig({\n  plugins: [appTools(), proxyPlugin()],\n});\n\n\n\nObject 类型#\n\ndev.proxy 的值为 Object 时，对象的 key 对应匹配的 pattern，对象的 value 对应匹配的 target。\n\n例如：\n\nexport default defineConfig({\n  dev: {\n    proxy: {\n      'https://www.baidu.com': 'https://google.com.hk',\n      //可以通过 file 协议直接返回静态文件。\n      'https://example.com/api': 'file://./data.json',\n    },\n  },\n});\n\n\n请参考 whistle - 匹配模式 来了解详细用法。\n\n\nString 类型#\n\ndev.proxy 的值为 string 时， 可以用来指定单独的代理文件，例如：\n\nexport default defineConfig({\n  dev: {\n    proxy: './proxy.js',\n  },\n});\n\n\nmodule.exports = {\n  name: 'my-app',\n  rules: `\n    ^example.com:8080/api/***   http://localhost:3001/api/$\n  `,\n};\n\n\n\n启动代理#\n\n执行 dev, 提示如下时，即代理服务器启动成功：\n\n  App running at:\n\n  Local:    http://localhost:8080/\n  Network:  http://192.168.0.1:8080/\n\nℹ  info      Starting the proxy server.....\n✔  success   Proxy Server start on localhost:8899\n\n\n访问 localhost:8899, 可以在 UI 界面上查看 Network 以及配置代理规则：\n\n\n\nINFO\n\nhttps 代理自动安装证书需要获取 root 权限, 请根据提示输入密码即可。密码仅在信任证书时使用，不会泄漏或者用于其他环节。","frontmatter":{"sidebar_label":"proxy"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/dev/proxy.mdx","_relativePath":"zh/configure/app/dev/proxy.mdx"},{"id":378,"title":"dev.startUrl","routePath":"/configure/app/dev/start-url","lang":"zh","toc":[{"text":"端口号占位符","id":"端口号占位符","depth":3,"charIndex":455}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.startUrl。\n\n * 类型： boolean | string | string[] | undefined\n * 默认值： undefined\n\ndev.startUrl 用于设置 Dev Server 启动时自动在浏览器中打开的页面 URL。\n\n默认情况下，Dev Server 启动时不会打开任何页面。\n\n你可以设置为如下的值：\n\nexport default {\n  dev: {\n    // 打开项目的默认页面，等价于 `http://localhost:`\n    startUrl: true,\n    // 打开指定的页面\n    startUrl: 'http://localhost:8080',\n    // 打开多个页面\n    startUrl: ['http://localhost:8080', 'http://localhost:8080/about'],\n  },\n};\n\n\n\n端口号占位符#\n\n由于端口号可能会发生变动，你可以使用 占位符来指代当前端口号，Builder 会自动将占位符替换为实际监听的端口号。\n\nexport default {\n  dev: {\n    startUrl: 'http://localhost:/home',\n  },\n};\n","frontmatter":{"sidebar_label":"startUrl"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/dev/start-url.mdx","_relativePath":"zh/configure/app/dev/start-url.mdx"},{"id":379,"title":"experiments.lazyCompilation","routePath":"/configure/app/experiments/lazy-compilation","lang":"zh","toc":[{"text":"延迟编译异步模块","id":"延迟编译异步模块","depth":3,"charIndex":343},{"text":"延迟编译入口模块","id":"延迟编译入口模块","depth":3,"charIndex":599},{"text":"局限性","id":"局限性","depth":3,"charIndex":1000},{"text":"禁用拆包规则","id":"禁用拆包规则","depth":4,"charIndex":1006},{"text":"使用代理","id":"使用代理","depth":4,"charIndex":1099}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 experiments.lazyCompilation。\n\n * 类型：\n\ntype LazyCompilationOptions =\n  | boolean\n  | {\n      // 是否为异步模块开启延迟编译\n      imports?: boolean;\n      // 是否为入口模块开启延迟编译\n      entries?: boolean;\n    };\n\n\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n用于开启延迟编译（即按需编译）的能力。当开启此配置项时，Builder 会进行延迟编译，提升项目的编译启动速度。\n\n延迟编译只在开发环境下生效。\n\n\n延迟编译异步模块#\n\n延迟编译 Dynamic Import 引入的异步模块：\n\nexport default {\n  experiments: {\n    lazyCompilation: {\n      imports: true,\n      entries: false,\n    },\n  },\n};\n\n\n开启 imports 选项后，所有的异步模块只有在被请求时才触发编译。如果你的项目是一个单页应用（SPA），并通过 Dynamic Import\n进行了路由拆分，那么会有明显的编译提速效果。\n\n\n延迟编译入口模块#\n\n除了延迟编译异步模块，你也可以选择同时延迟编译入口模块和异步模块。\n\nexport default {\n  experiments: {\n    lazyCompilation: {\n      imports: true,\n      entries: true,\n    },\n  },\n};\n\n\n以上配置也可以简化为：\n\nexport default {\n  experiments: {\n    lazyCompilation: true,\n  },\n};\n\n\n开启 entries 选项后，当启动编译时，不会编译所有的页面，而是仅在路由跳转到对应的页面时，才对该页面进行编译。\n\n使用延迟编译入口模块时，有以下注意事项：\n\n * 只适用于多页应用（MPA），对单页应用（SPA）没有优化效果。\n * 当你访问一个页面时，由于要等待页面编译完成，会有一段时间的白屏。\n\n\n局限性#\n\n禁用拆包规则#\n\n当你开启延迟编译时，为了保证编译结果正常，Builder\n会在开发环境下禁用拆包规则。这不会影响生产环境的打包产物，但会导致开发环境和生产环境的打包产物有一定差异。\n\n使用代理#\n\nLazy Compilation 依赖 webpack 在本地启动的开发服务器，当你将某个域名代理到 localhost 进行开发时，Lazy\nCompilation 将无法正常工作。因此，如果你需要使用代理时，请禁用 Lazy Compilation。","frontmatter":{"sidebar_label":"lazyCompilation"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/experiments/lazy-compilation.mdx","_relativePath":"zh/configure/app/experiments/lazy-compilation.mdx"},{"id":380,"title":"html.appIcon","routePath":"/configure/app/html/app-icon","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":235}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.appIcon。\n\n * 类型： string\n * 默认值： undefined\n\n设置 iOS 系统下的 apple-touch-icon 图标的文件路径，可以设置为相对于项目根目录的相对路径，也可以设置为文件的绝对路径。暂不支持设置为\nCDN URL。\n\n配置该选项后，在编译过程中会自动将图标拷贝至 dist 目录下，并在 HTML 中添加相应的 link 标签。\n\n\n示例#\n\n设置为相对路径：\n\nexport default {\n  html: {\n    appIcon: './src/assets/icon.png',\n  },\n};\n\n\n设置为绝对路径：\n\n\n\nexport default {\n  html: {\n    appIcon: path.resolve(__dirname, './src/assets/icon.png'),\n  },\n};\n\n\n重新编译后，HTML 中自动生成了以下标签：\n\n\n","frontmatter":{"sidebar_label":"appIcon"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/app-icon.mdx","_relativePath":"zh/configure/app/html/app-icon.mdx"},{"id":381,"title":"html.crossorigin","routePath":"/configure/app/html/crossorigin","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"可选值","id":"可选值","depth":3,"charIndex":-1}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.crossorigin。\n\n * 类型： boolean | 'anonymous' | 'use-credentials'\n * 默认值： false\n\n用于设置\n\n","frontmatter":{"sidebar_label":"crossorigin"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/crossorigin.mdx","_relativePath":"zh/configure/app/html/crossorigin.mdx"},{"id":382,"title":"html.disableHtmlFolder","routePath":"/configure/app/html/disable-html-folder","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":172}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.disableHtmlFolder。\n\n * 类型： boolean\n * 默认值： false\n\n移除 HTML 产物对应的文件夹。开启该选项后，生成的 HTML 文件目录会从 [name]/index.html 变为 [name].html。\n\n\n示例#\n\n默认情况下，HTML 产物在 dist 目录下的结构为：\n\n/dist\n└── html\n    └── main\n        └── index.html\n\n\n开启 html.disableHtmlFolder 配置:\n\nexport default {\n  html: {\n    disableHtmlFolder: true,\n  },\n};\n\n\n重新编译后，HTML 产物在 dist 中的目录结构如下：\n\n/dist\n└── html\n    └── main.html\n\n\n> 如果需要设置 HTML 文件在 dist 目录中的路径，请使用 output.distPath.html 配置。","frontmatter":{"sidebar_label":"disableHtmlFolder"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/disable-html-folder.mdx","_relativePath":"zh/configure/app/html/disable-html-folder.mdx"},{"id":383,"title":"html.faviconByEntries","routePath":"/configure/app/html/favicon-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":237}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.faviconByEntries。\n\n * 类型： Record\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 favicon。\n\n整体用法与 favicon 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\nfaviconByEntries 的优先级高于 favicon，因此会覆盖 favicon 中设置的值。\n\n\n示例#\n\nexport default {\n  html: {\n    favicon: './src/assets/default.png',\n    faviconByEntries: {\n      foo: './src/assets/foo.png',\n    },\n  },\n};\n\n\n重新编译后，可以看到:\n\n * 页面 foo 的 favicon 为 ./src/assets/foo.png。\n * 其他页面的 favicon 为 ./src/assets/default.png。","frontmatter":{"sidebar_label":"faviconByEntries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/favicon-by-entries.mdx","_relativePath":"zh/configure/app/html/favicon-by-entries.mdx"},{"id":384,"title":"html.favicon","routePath":"/configure/app/html/favicon","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":214}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.favicon。\n\n * 类型： string\n * 默认值： undefined\n\n设置页面的 favicon 图标，可以设置为：\n\n * URL 地址。\n * 文件的绝对路径。\n * 相对于项目根目录的相对路径。\n\n配置该选项后，在编译过程中会自动将图标拷贝至 dist 目录下，并在 HTML 中添加相应的 link 标签。\n\n\n示例#\n\n设置为相对路径：\n\nexport default {\n  html: {\n    favicon: './src/assets/icon.png',\n  },\n};\n\n\n设置为绝对路径：\n\n\n\nexport default {\n  html: {\n    favicon: path.resolve(__dirname, './src/assets/icon.png'),\n  },\n};\n\n\n设置为 URL：\n\n\n\nexport default {\n  html: {\n    favicon: 'https://foo.com/favicon.ico',\n  },\n};\n\n\n重新编译后，HTML 中自动生成了以下标签：\n\n\n","frontmatter":{"sidebar_label":"favicon"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/favicon.mdx","_relativePath":"zh/configure/app/html/favicon.mdx"},{"id":385,"title":"html.injectByEntries","routePath":"/configure/app/html/inject-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":238}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.injectByEntries。\n\n * 类型： Record\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 script 标签插入位置。\n\n整体用法与 inject 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ninjectByEntries 的优先级高于 inject，因此会覆盖 inject 中设置的值。\n\n\n示例#\n\nexport default {\n  html: {\n    inject: 'head',\n    injectByEntries: {\n      foo: 'body',\n    },\n  },\n};\n\n\n重新编译后，可以看到:\n\n * 页面 foo 的 script 标签会插入到 body 标签内。\n * 其他页面的 script 标签会插入到 head 标签内。","frontmatter":{"sidebar_label":"injectByEntries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/inject-by-entries.mdx","_relativePath":"zh/configure/app/html/inject-by-entries.mdx"},{"id":386,"title":"html.inject","routePath":"/configure/app/html/inject","lang":"zh","toc":[{"text":"默认插入位置","id":"默认插入位置","depth":4,"charIndex":-1},{"text":"插入至 body 标签","id":"插入至-body-标签","depth":4,"charIndex":-1}],"domain":"","content":"","frontmatter":{"sidebar_label":"inject"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/inject.mdx","_relativePath":"zh/configure/app/html/inject.mdx"},{"id":387,"title":"html.metaByEntries","routePath":"/configure/app/html/meta-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":222}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.metaByEntries。\n\n * 类型： Record\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 meta 标签。\n\n整体用法与 meta 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\nmetaByEntries 的优先级高于 meta，因此会覆盖 meta 中设置的值。\n\n\n示例#\n\nexport default {\n  html: {\n    meta: {\n      description: 'ByteDance',\n    },\n    metaByEntries: {\n      foo: {\n        description: 'TikTok',\n      },\n    },\n  },\n};\n\n\n编译后，可以看到页面 foo 的 meta 为：\n\n\n\n\n其他页面的 meta 为：\n\n\n","frontmatter":{"sidebar_label":"metaByEntries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/meta-by-entries.mdx","_relativePath":"zh/configure/app/html/meta-by-entries.mdx"},{"id":388,"title":"html.meta","routePath":"/configure/app/html/meta","lang":"zh","toc":[{"text":"字符串用法","id":"字符串用法","depth":4,"charIndex":104},{"text":"对象用法","id":"对象用法","depth":4,"charIndex":327},{"text":"移除默认值","id":"移除默认值","depth":3,"charIndex":626}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.meta。\n\n * 类型： Record>\n * 默认值： undefined\n\n配置 HTML 页面的 标签。\n\n字符串用法#\n\n当 meta 对象的 value 为字符串时，会自动将对象的 key 映射为 name，value 映射为 content。\n\n比如设置 description：\n\nexport default {\n  html: {\n    meta: {\n      description: 'a description of the page',\n    },\n  },\n};\n\n\n最终在 HTML 中生成的 meta 标签为：\n\n\n\n\n对象用法#\n\n当 meta 对象的 value 为对象时，会将该对象的 key: value 映射为 meta 标签的属性。\n\n这种情况下默认不会设置 name 和 content 属性。\n\n比如设置 http-equiv：\n\nexport default {\n  html: {\n    meta: {\n      'http-equiv': {\n        'http-equiv': 'x-ua-compatible',\n        content: 'ie=edge',\n      },\n    },\n  },\n};\n\n\n最终在 HTML 中生成的 meta 标签为：\n\n\n\n\n\n移除默认值#\n\n将 meta 对象的 value 设置为 false，则表示不生成对应的 meta 标签。\n\n比如移除框架预设的 imagemode：\n\nexport default {\n  html: {\n    meta: {\n      imagemode: false,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"meta"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/meta.mdx","_relativePath":"zh/configure/app/html/meta.mdx"},{"id":389,"title":"html.mountId","routePath":"/configure/app/html/mount-id","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":-1},{"text":"更新相关代码","id":"更新相关代码","depth":4,"charIndex":-1},{"text":"自定义模板","id":"自定义模板","depth":4,"charIndex":-1}],"domain":"","content":"","frontmatter":{"sidebar_label":"mountId"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/mount-id.mdx","_relativePath":"zh/configure/app/html/mount-id.mdx"},{"id":390,"title":"html.scriptLoading","routePath":"/configure/app/html/script-loading","lang":"zh","toc":[{"text":"defer","id":"defer","depth":3,"charIndex":-1},{"text":"blocking","id":"blocking","depth":3,"charIndex":-1},{"text":"module","id":"module","depth":3,"charIndex":-1}],"domain":"","content":"","frontmatter":{"sidebar_label":"scriptLoading"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/script-loading.mdx","_relativePath":"zh/configure/app/html/script-loading.mdx"},{"id":391,"title":"html.tagsByEntries","routePath":"/configure/app/html/tags-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":217}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.tagsByEntries。\n\n * 类型： Record>\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面注入不同的标签。\n\n整体用法与 tags 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntagsByEntries 的优先级高于 tags，因此会覆盖 tags 中设置的值。\n\n\n示例#\n\nexport default {\n  html: {\n    tags: [{ tag: 'script', attrs: { src: 'a.js' } }],\n    tagsByEntries: {\n      foo: [{ tag: 'script', attrs: { src: 'b.js' } }],\n    },\n  },\n};\n\n\n编译后，可以看到页面 foo 注入标签：\n\n\n\n\n其他页面则注入了：\n\n\n","frontmatter":{"sidebar_label":"tagsByEntries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/tags-by-entries.mdx","_relativePath":"zh/configure/app/html/tags-by-entries.mdx"},{"id":392,"title":"html.tags","routePath":"/configure/app/html/tags","lang":"zh","toc":[{"text":"对象形式","id":"对象形式","depth":4,"charIndex":-1},{"text":"函数形式","id":"函数形式","depth":4,"charIndex":-1},{"text":"限制","id":"限制","depth":4,"charIndex":-1}],"domain":"","content":"","frontmatter":{"sidebar_label":"tags"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/tags.mdx","_relativePath":"zh/configure/app/html/tags.mdx"},{"id":393,"title":"html.templateByEntries","routePath":"/configure/app/html/template-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":241}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.templateByEntries。\n\n * 类型： Object\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 HTML 模板。\n\n整体用法与 template 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntemplateByEntries 的优先级高于 template，因此会覆盖 template 设置的值。\n\n\n示例#\n\nexport default {\n  html: {\n    template: './static/index.html',\n    templateByEntries: {\n      foo: './src/pages/foo/index.html',\n      bar: './src/pages/bar/index.html',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"templateByEntries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/template-by-entries.mdx","_relativePath":"zh/configure/app/html/template-by-entries.mdx"},{"id":394,"title":"html.templateParametersByEntries","routePath":"/configure/app/html/template-parameters-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":288}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.templateParametersByEntries。\n\n * 类型： Object\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的模板参数。\n\n整体用法与 templateParameters 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntemplateParametersByEntries 的优先级高于 templateParameters，因此会覆盖 templateParameters\n中设置的值。\n\n\n示例#\n\nexport default {\n  html: {\n    templateParametersByEntries: {\n      foo: {\n        type: 'a',\n      },\n      bar: {\n        type: 'b',\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"templateParametersByEntries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/template-parameters-by-entries.mdx","_relativePath":"zh/configure/app/html/template-parameters-by-entries.mdx"},{"id":395,"title":"html.templateParameters","routePath":"/configure/app/html/template-parameters","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":1076}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.templateParameters。\n\n * 类型： Object | Function\n * 默认值：\n\ntype DefaultParameters = {\n  meta: string; // 对应 html.meta 配置\n  title: string; // 对应 html.title 配置\n  mountId: string; // 对应 html.mountId 配置\n  entryName: string; // 入口名称\n  assetPrefix: string; // 对应 output.assetPrefix 配置\n  compilation: webpack.Compilation; // 对应 webpack 的 compilation 对象\n  webpackConfig: Configuration; // webpack 配置\n  // htmlWebpackPlugin 内置的参数\n  // 详见 https://github.com/jantimon/html-webpack-plugin\n  htmlWebpackPlugin: {\n    tags: object;\n    files: object;\n    options: object;\n  };\n};\n\n\n定义 HTML 模板中的参数，对应 html-webpack-plugin 的 templateParameters 配置项。你可以使用配置为对象或者函数。\n\n如果是对象，会和默认参数合并。比如：\n\nexport default {\n  html: {\n    templateParameters: {\n      title: 'My App',\n    },\n  },\n};\n\n\n如果是函数，会传入默认参数，你可以返回一个对象，用于覆盖默认参数。比如：\n\nexport default {\n  html: {\n    templateParameters: defaultParameters => {\n      console.log(defaultParameters.compilation);\n      console.log(defaultParameters.title);\n      return {\n        title: 'My App',\n      };\n    },\n  },\n};\n\n\n\n示例#\n\n如果需要在 HTML 模板中使用 foo 参数，可以添加如下设置：\n\nexport default {\n  html: {\n    templateParameters: {\n      foo: 'bar',\n    },\n  },\n};\n\n\n或者使用函数配置：\n\nexport default {\n  html: {\n    templateParameters: defaultParameters => {\n      return {\n        foo: 'bar',\n      };\n    },\n  },\n};\n\n\n接下来，你可以在 HTML 模板中，通过 <%= foo %> 来读取参数：\n\n\n\n\n经过编译后的最终 HTML 代码如下：\n\n\n","frontmatter":{"sidebar_label":"templateParameters"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/template-parameters.mdx","_relativePath":"zh/configure/app/html/template-parameters.mdx"},{"id":396,"title":"html.template","routePath":"/configure/app/html/template","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":137}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.template。\n\n * 类型： string\n * 默认值：\n\n定义 HTML 模板的文件路径，对应 html-webpack-plugin 的 template 配置项。\n\n\n示例#\n\n使用自定义的 HTML 模板文件替代默认模板，可以添加如下设置：\n\nexport default {\n  html: {\n    template: './static/index.html',\n  },\n};\n","frontmatter":{"sidebar_label":"template"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/template.mdx","_relativePath":"zh/configure/app/html/template.mdx"},{"id":397,"title":"html.titleByEntries","routePath":"/configure/app/html/title-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":225}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.titleByEntries。\n\n * 类型： Record\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 title。\n\n整体用法与 title 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntitleByEntries 的优先级高于 title，因此会覆盖 title 中设置的值。\n\n\n示例#\n\nexport default {\n  html: {\n    title: 'ByteDance',\n    titleByEntries: {\n      foo: 'TikTok',\n    },\n  },\n};\n\n\n重新编译后，可以看到:\n\n * 页面 foo 的 title 为 TikTok。\n * 其他页面的 title 为 ByteDance。","frontmatter":{"sidebar_label":"titleByEntries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/title-by-entries.mdx","_relativePath":"zh/configure/app/html/title-by-entries.mdx"},{"id":398,"title":"html.title","routePath":"/configure/app/html/title","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.title。\n\n * 类型： string\n * 默认值： undefined\n\n配置 HTML 页面的 title 标签，例如：\n\nexport default {\n  html: {\n    title: 'example',\n  },\n};\n","frontmatter":{"sidebar_label":"title"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/html/title.mdx","_relativePath":"zh/configure/app/html/title.mdx"},{"id":399,"title":"output.assetPrefix","routePath":"/configure/app/output/asset-prefix","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":390}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.assetPrefix。\n\n * 类型： boolean | string\n * 默认值： '/'\n\n在生产环境使用 CDN 部署时，可使用该选项设置静态资源的 URL 前缀，对应 webpack 的 output.publicPath 配置。\n\nassetPrefix 会影响构建产物中绝大部分静态资源的 URL，包括 JavaScript 文件、CSS\n文件、图片、视频等。如果指定了一个错误的值，则在加载这些资源时可能会出现 404 错误。\n\n该配置项仅用于生产环境。在开发环境下，请使用 dev.assetPrefix 配置项进行设置。\n\n设置后，项目的 JavaScript、CSS、图片等静态资源的 URL 都会加上 output.assetPrefix 作为前缀：\n\n\n示例#\n\nexport default {\n  output: {\n    assetPrefix: 'https://cdn.example.com/assets/',\n  },\n};\n\n\n构建之后，可以看到 JS 文件从以下地址加载：\n\n\n","frontmatter":{"sidebar_label":"assetPrefix"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/asset-prefix.mdx","_relativePath":"zh/configure/app/output/asset-prefix.mdx"},{"id":400,"title":"output.assetsRetry","routePath":"/configure/app/output/assets-retry","lang":"zh","toc":[{"text":"assetsRetry.max","id":"assetsretrymax","depth":3,"charIndex":973},{"text":"assetsRetry.domain","id":"assetsretrydomain","depth":3,"charIndex":1113},{"text":"assetsRetry.type","id":"assetsretrytype","depth":3,"charIndex":1335},{"text":"assetsRetry.test","id":"assetsretrytest","depth":3,"charIndex":1517},{"text":"assetsRetry.crossOrigin","id":"assetsretrycrossorigin","depth":3,"charIndex":1742},{"text":"assetsRetry.onRetry","id":"assetsretryonretry","depth":3,"charIndex":-1},{"text":"assetsRetry.onSuccess","id":"assetsretryonsuccess","depth":3,"charIndex":-1},{"text":"assetsRetry.onFail","id":"assetsretryonfail","depth":3,"charIndex":-1},{"text":"assetsRetry.inlineScript","id":"assetsretryinlinescript","depth":3,"charIndex":-1}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.assetsRetry。\n\n * 类型： Object\n\noutput.assetsRetry 用于配置资源加载失败时的重试逻辑。配置类型如下:\n\nexport type AssetsRetryHookContext = {\n  times: number;\n  domain: string;\n  url: string;\n  tagName: string;\n};\n\nexport type AssetsRetryOptions = {\n  type?: string[];\n  domain?: string[];\n  max?: number;\n  test?: string | ((url: string) => boolean);\n  crossOrigin?: boolean;\n  onRetry?: (options: AssetsRetryHookContext) => void;\n  onSuccess?: (options: AssetsRetryHookContext) => void;\n  onFail?: (options: AssetsRetryHookContext) => void;\n};\n\n\n由于该能力会往 HTML 中注入额外的一些运行时代码，因此我们默认关闭了该能力，如果需要开启该能力，你可以添加以下配置：\n\nexport default {\n  output: {\n    assetsRetry: {},\n  },\n};\n\n\n当你开启该能力后，assetsRetry 的默认配置如下：\n\nexport const defaultAssetsRetryOptions: AssetsRetryOptions = {\n  type: ['script', 'link', 'img'],\n  domain: [],\n  max: 3,\n  test: '',\n  crossOrigin: false,\n  onRetry: () => {},\n  onSuccess: () => {},\n  onFail: () => {},\n};\n\n\n同时你也可以使用以下的配置项，来定制你的重试逻辑。\n\n\nassetsRetry.max#\n\n * 类型： number\n * 默认值： 3\n\n单个资源的最大重试次数。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      max: 3,\n    },\n  },\n};\n\n\n\nassetsRetry.domain#\n\n * 类型： string[]\n * 默认值： []\n\n指定资源加载失败时的重试域名，如果为空则使用当前页面的域名。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      domain: ['https://cdn1.example.com', 'https://cdn2.example.com'],\n    },\n  },\n};\n\n\n\nassetsRetry.type#\n\n * 类型： string[]\n * 默认值： ['script', 'link', 'img']\n\n可重试的资源类型。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      type: ['script', 'link'],\n    },\n  },\n};\n\n\n\nassetsRetry.test#\n\n * 类型： string | ((url: string) => boolean) | undefined\n * 默认值： undefined\n\n匹配资源 URL 的正则表达式或函数，默认匹配所有资源。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      test: /cdn\\.example\\.com/,\n    },\n  },\n};\n\n\n\nassetsRetry.crossOrigin#\n\n * 类型： undefined | boolean\n * 默认值： false\n\n用于向","frontmatter":{"sidebar_label":"assetsRetry"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/assets-retry.mdx","_relativePath":"zh/configure/app/output/assets-retry.mdx"},{"id":401,"title":"output.charset","routePath":"/configure/app/output/charset","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.charset。\n\n * 类型： 'ascii' | 'utf8'\n * 默认值： 'ascii'\n\n默认情况下，Builder 的产物内容是纯 ASCII 的，并且会转义所有非 ASCII 字符。\n\n如果不希望进行转义，而是输出所有原始字符，可以将 output.charset 设置为 utf8。\n\nexport default {\n  output: {\n    charset: 'utf8',\n  },\n};\n\n\n当 output.charset 为 utf8 时，Builder 会自动将 添加到生成的 HTML 文件中。","frontmatter":{"sidebar_label":"charset"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/charset.mdx","_relativePath":"zh/configure/app/output/charset.mdx"},{"id":402,"title":"output.cleanDistPath","routePath":"/configure/app/output/clean-dist-path","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.cleanDistPath。\n\n * 类型： boolean\n * 默认值： true\n\n是否在构建开始前清理 dist 目录下的所有文件。\n\n默认情况下，Builder 会自动清理 dist 目录下的文件，你可以把 cleanDistPath 设置为 false 来禁用该行为。\n\nexport default {\n  output: {\n    cleanDistPath: false,\n  },\n};\n","frontmatter":{"sidebar_label":"cleanDistPath"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/clean-dist-path.mdx","_relativePath":"zh/configure/app/output/clean-dist-path.mdx"},{"id":403,"title":"output.convertToRem","routePath":"/configure/app/output/convert-to-rem","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":4,"charIndex":208},{"text":"Object 类型","id":"object-类型","depth":4,"charIndex":642},{"text":"示例","id":"示例","depth":3,"charIndex":1566}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.convertToRem。\n\n * 类型： boolean | object\n * 默认值： false\n\n通过设置 output.convertToRem，Builder 可进行如下处理：\n\n * 将 CSS 中的 px 转成 rem\n * 在 HTML 模版中插入运行时代码，对根元素 fontSize 进行设置\n\nBoolean 类型#\n\n当设置 output.convertToRem 为 true，将开启 rem 处理能力。\n\nexport default {\n  output: {\n    convertToRem: true,\n  },\n};\n\n\n此时，rem 配置默认如下：\n\n{\n  enableRuntime: true,\n  rootFontSize: 50,\n  screenWidth: 375,\n  rootFontSize: 50,\n  maxRootFontSize: 64,\n  widthQueryKey: '',\n  excludeEntries: [],\n  supportLandscape: false,\n  useRootFontSizeBeyondMax: false,\n  pxtorem: {\n    rootValue: 50,\n    unitPrecision: 5,\n    propList: ['*'],\n  }\n}\n\n\nObject 类型#\n\n当 output.convertToRem 的值为 object 类型时，Builder 会根据当前配置进行 rem 处理。\n\n选项：\n\n名称                         类型         默认值     描述\nenableRuntime              boolean    true    是否自动生成 runtime 代码来动态计算根元素字体大小\ninlineRuntime              boolean    true    是否将 runtime 代码内联到 HTML 文件中。如果设置为 false，运行时代码会被抽取为一个独立的\n                                              convert-rem.[version].js 文件，并输出到产物目录下\nrootFontSize               number     50      根元素字体值\nmaxRootFontSize            number     64      最大根元素字体值\nwidthQueryKey              string     ''      根据 widthQueryKey 的值去 url query 中取 client width\nscreenWidth                number     375     UI 设计图宽度\nexcludeEntries             string[]   []      不进行调整的页面入口\nsupportLandscape           boolean    false   横屏时使用 height 计算 rem\nuseRootFontSizeBeyondMax   boolean    false   超过 maxRootFontSize 时，是否使用 rootFontSize\npxtorem                    object             postcss-pxtorem 插件属性\n\n\n示例#\n\nexport default {\n  output: {\n    convertToRem: {\n      rootFontSize: 30,\n      excludeEntries: ['404', 'page2'],\n      pxtorem: {\n        propList: ['font-size'],\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"convertToRem"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/convert-to-rem.mdx","_relativePath":"zh/configure/app/output/convert-to-rem.mdx"},{"id":404,"title":"output.copy","routePath":"/configure/app/output/copy","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.copy。\n\n * 类型： CopyPluginOptions | CopyPluginOptions['patterns']\n * 默认值： undefined\n\n将指定的文件或目录拷贝到构建输出目录中。\n\n例如，将 src/assets 下的文件直接拷贝到 dist 目录：\n\nexport default {\n  output: {\n    copy: [{ from: './src/assets', to: '' }],\n  },\n};\n\n\n更详细的配置项请参考：copy-webpack-plugin 文档。","frontmatter":{"sidebar_label":"copy"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/copy.mdx","_relativePath":"zh/configure/app/output/copy.mdx"},{"id":405,"title":"output.cssModuleLocalIdentName","routePath":"/configure/app/output/css-module-local-ident-name","lang":"zh","toc":[{"text":"默认值","id":"默认值","depth":3,"charIndex":254},{"text":"模板字符串","id":"模板字符串","depth":3,"charIndex":445},{"text":"示例","id":"示例","depth":3,"charIndex":706}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.cssModuleLocalIdentName。\n\n * 类型： string\n * 默认值：\n\n// isProd 表示生产环境构建\nconst localIdentName = isProd\n  ? '[hash:base64:5]'\n  : '[path][name]__[local]--[hash:base64:5]';\n\n\n设置 CSS Modules 编译后生成的 className 格式。\n\n\n默认值#\n\ncssModuleLocalIdentName 在开发环境和生产环境有不同的默认值。\n\n在生产环境，Builder 会生成更简短的类名，从而减少构建产物的体积。\n\n\n\n// 在开发环境下，值为 `.src-index-module__header--xxxxx`\n// 在生产环境下，值为 `.xxxxx`\nconsole.log(styles.header);\n\n\n\n模板字符串#\n\n在 cssModuleLocalIdentName 中，你可以使用以下模板字符串：\n\n * [name] - 源文件名称。\n * [local] - 原始类名。\n * [hash] - 字符串的哈希值。\n * [folder] - 文件夹的相对路径。\n * [path] - 源文件的相对路径。\n * [file] - 文件名和路径。\n * [ext] - 文件后缀名，包含点号。\n * [hash::] - 带有哈希设置的哈希。\n\nTIP\n\n在使用 Rspack 作为打包工具时, 暂不支持配置 。\n\n\n示例#\n\n将 cssModuleLocalIdentName 设置为其他值：\n\nexport default {\n  output: {\n    cssModuleLocalIdentName: '[hash:base64:4]',\n  },\n};\n","frontmatter":{"sidebar_label":"cssModuleLocalIdentName"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/css-module-local-ident-name.mdx","_relativePath":"zh/configure/app/output/css-module-local-ident-name.mdx"},{"id":406,"title":"output.cssModules","routePath":"/configure/app/output/css-modules","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.cssModules。\n\n * 类型：\n\ntype CssModules = {\n  auto?: boolean | RegExp | ((resourcePath: string) => boolean);\n};\n\n\n * 默认值： undefined\n\n自定义 CSS 模块配置。\n\ncssModules.auto#\n\nauto 配置项允许基于文件名自动启用 CSS 模块。\n\n * 类型： boolean | RegExp | ((resourcePath: string) => boolean);\n\n * 默认值： undefined\n\n类型说明：\n\n * undefined: 根据 output.disableCssModuleExtension 配置项决定为哪些样式文件启用 CSS 模块。\n * true: 为所有匹配 /\\.module\\.\\w+$/i.test(filename) 正则表达式的文件启用 CSS 模块。\n * false: 禁用 CSS 模块。\n * RegExp: 为所有匹配 /RegExp/i.test(filename) 正则表达式的文件禁用 CSS 模块。\n * function: 为所有通过基于文件名的过滤函数校验的文件启用 CSS 模块。\n\nexport default {\n  output: {\n    cssModules: {\n      auto: resource => {\n        return resource.includes('.module.') || resource.includes('shared/');\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"cssModules"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/css-modules.mdx","_relativePath":"zh/configure/app/output/css-modules.mdx"},{"id":407,"title":"output.dataUriLimit","routePath":"/configure/app/output/data-uri-limit","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":520}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.dataUriLimit。\n\n * 类型：\n\ntype DataUriLimitConfig = {\n  svg?: number;\n  font?: number;\n  image?: number;\n  media?: number;\n};\n\n\n * 默认值：\n\nconst defaultDatUriLimit = {\n  svg: 10000,\n  font: 10000,\n  image: 10000,\n  media: 10000,\n};\n\n\n设置图片、字体、媒体等静态资源被自动内联为 base64 的体积阈值。\n\n默认情况下，体积小于 10KB 的图片、字体、媒体等文件，会自动经过 Base64 编码，内联到页面中，不再会发送独立的 HTTP 请求。\n\n你可以通过修改 dataUriLimit 参数来调整这个阈值。\n\n其中：\n\n * svg：表示 SVG 图片的体积阈值。\n * font：表示字体文件的体积阈值。\n * image：表示非 SVG 图片的体积阈值。\n * media：表示视频等媒体资源的体积阈值。\n\n\n示例#\n\n修改图片资源的阈值为 5000 Bytes，设置视频资源不内联：\n\nexport default {\n  output: {\n    dataUriLimit: {\n      image: 5000,\n      media: 0,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"dataUriLimit"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/data-uri-limit.mdx","_relativePath":"zh/configure/app/output/data-uri-limit.mdx"},{"id":408,"title":"output.disableCssExtract","routePath":"/configure/app/output/disable-css-extract","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableCssExtract。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否禁用 CSS 提取逻辑，并将 CSS 文件内联到 JS 文件中。\n\n默认情况下，Builder 会把 CSS 提取为独立的 .css 文件，并输出到构建产物目录。设置该选项为 true 后，CSS 文件会被内联到 JS\n文件中，并在运行时通过","frontmatter":{"sidebar_label":"disableCssExtract"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/disable-css-extract.mdx","_relativePath":"zh/configure/app/output/disable-css-extract.mdx"},{"id":409,"title":"output.disableCssModuleExtension","routePath":"/configure/app/output/disable-css-module-extension","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":414},{"text":"规则","id":"规则","depth":3,"charIndex":496},{"text":"未开启 disableCssModuleExtension（默认）","id":"未开启-disablecssmoduleextension（默认）","depth":4,"charIndex":530},{"text":"开启 disableCssModuleExtension","id":"开启-disablecssmoduleextension","depth":4,"charIndex":677}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableCssModuleExtension。\n\n * 类型： boolean\n * 默认值： false\n\n是否将源码目录下的所有样式文件当做 CSS Modules 模块进行处理。\n\n在默认情况下，只有 *.module.css 结尾的文件才被视为 CSS Modules 模块。开启该配置项之后，会将源码目录下的所有 *.css 样式文件当做\nCSS Modules 模块。\n\n.sass、.scss 和 .less 文件的处理规则与 .css 文件一致，也会受到 disableCssModuleExtension 的影响。\n\nTIP\n\n我们不推荐开启此配置项，因为开启 disableCssModuleExtension 后，CSS Modules 文件和普通 CSS\n文件无法得到明确的区分，不利于长期维护。\n\n\n示例#\n\nexport default {\n  output: {\n    disableCssModuleExtension: true,\n  },\n};\n\n\n\n规则#\n\n以下是对 CSS Modules 判断规则的详细解释：\n\n未开启 disableCssModuleExtension（默认）#\n\n以下文件会视为 CSS Modules：\n\n * 所有 *.module.css 文件\n\n以下文件会视为普通 CSS：\n\n * 所有 *.css 文件（不含 .module）\n * 所有 *.global.css 文件\n\n开启 disableCssModuleExtension#\n\n以下文件会视为 CSS Modules：\n\n * 源码目录下的 *.css 和 *.module.css 文件\n * node_modules 下的 *.module.css 文件\n\n以下文件会视为普通 CSS：\n\n * 所有 *.global.css 文件\n * node_modules 下的 *.css 文件（不含 .module）\n\nTIP\n\n对于 node_modules 中的 CSS Modules 文件，请始终使用 *.module.css 后缀。","frontmatter":{"sidebar_label":"disableCssModuleExtension"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/disable-css-module-extension.mdx","_relativePath":"zh/configure/app/output/disable-css-module-extension.mdx"},{"id":410,"title":"output.disableFilenameHash","routePath":"/configure/app/output/disable-filename-hash","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":205}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableFilenameHash。\n\n * 类型： boolean\n * 默认值： false\n\n移除生产环境的构建产物名称中的 hash 值。\n\n在生产环境构建后，会自动在文件名中间添加 hash 值，如果不需要添加，可以通过 output.disableFilenameHash 配置来禁用该行为。\n\n\n示例#\n\n默认情况下，构建后的产物名称为：\n\nFile                                     Size         Gzipped\ndist/static/css/187.7879e19d.css         126.99 KB    9.17 KB\ndist/static/js/main.18a568e5.js          2.24 KB      922 B\n\n\n添加 output.disableFilenameHash 配置：\n\nexport default {\n  output: {\n    disableFilenameHash: true,\n  },\n};\n\n\n重新构建，产物的名称变为：\n\nFile                            Size         Gzipped\ndist/static/css/187.css         126.99 KB    9.17 KB\ndist/static/js/main.js          2.24 KB      922 B\n","frontmatter":{"sidebar_label":"disableFilenameHash"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/disable-filename-hash.mdx","_relativePath":"zh/configure/app/output/disable-filename-hash.mdx"},{"id":411,"title":"output.disableInlineRuntimeChunk","routePath":"/configure/app/output/disable-inline-runtime-chunk","lang":"zh","toc":[{"text":"禁用内联","id":"禁用内联","depth":3,"charIndex":427},{"text":"合并到页面文件中","id":"合并到页面文件中","depth":3,"charIndex":621}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableInlineRuntimeChunk。\n\n * 类型： boolean\n * 默认值： false\n\n用于控制是否将打包工具的 runtime 代码内联到 HTML 中。\n\n什么是 runtimeChunk\n\n当 Builder 构建完成后，会在 dist 目录生成 builder-runtime.js 文件，该文件为 webpack 或 Rspack 的\nruntime 代码，即 runtimeChunk。\n\nruntimeChunk 是一段运行时代码，它由 webpack 或 Rspack 提供，包含必要的模块处理逻辑，比如模块加载、模块解析等，具体可参考\nRuntime。\n\n在生产环境下，Builder 默认会将 runtimeChunk 文件内联到 HTML 文件中，而不是写到产物目录中，这样做是为了减少文件请求的数量。\n\n\n禁用内联#\n\n如果你不希望 runtimeChunk 文件被内联到 HTML 文件里，可以把 disableInlineRuntimeChunk 设置为\ntrue，此时会生成一个独立的 builder-runtime.js 文件。\n\nexport default {\n  output: {\n    disableInlineRuntimeChunk: true,\n  },\n};\n\n\n\n合并到页面文件中#\n\n如果你不希望生成独立的 runtimeChunk 文件，而是想让 runtimeChunk 代码被打包到页面的 JS 文件里，可以这样设置：\n\nexport default {\n  tools: {\n    webpack: {\n      optimization: {\n        runtimeChunk: false,\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"disableInlineRuntimeChunk"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/disable-inline-runtime-chunk.mdx","_relativePath":"zh/configure/app/output/disable-inline-runtime-chunk.mdx"},{"id":412,"title":"output.disableMinimize","routePath":"/configure/app/output/disable-minimize","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableMinimize。\n\n * 类型： boolean\n * 默认值： false\n\n是否禁用生产环境下的代码压缩。\n\n默认情况下，JS 代码和 CSS 代码会在生产环境构建时被自动压缩，从而提升页面性能。如果你不希望执行代码压缩，可以将 disableMinimize 设置为\ntrue。\n\nexport default {\n  output: {\n    disableMinimize: true,\n  },\n};\n\n\nTIP\n\n该配置项通常用于代码调试和问题排查，不建议在生产环境禁用代码压缩，否则会导致页面性能显著下降。","frontmatter":{"sidebar_label":"disableMinimize"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/disable-minimize.mdx","_relativePath":"zh/configure/app/output/disable-minimize.mdx"},{"id":413,"title":"output.disableNodePolyfill","routePath":"/configure/app/output/disable-node-polyfill","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n该配置项用于控制是否在代码中注入 Node 模块的 Polyfill。\n\n默认情况下，我们不会将 Node Polyfill 注入到代码中，以避免造成代码体积增大。如果你需要注入 Node Polyfill，可以将\noutput.disableNodePolyfill 设置为 false：\n\nexport default defineConfig({\n  output: {\n    disableNodePolyfill: false,\n  },\n});\n\n\n该配置项基于 Modern.js Builder 的 Node Polyfill 插件实现，你可以阅读 Modern.js Builder - Node\nPolyfill 插件 文档来了解详细信息。","frontmatter":{"sidebar_label":"disableNodePolyfill"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/disable-node-polyfill.mdx","_relativePath":"zh/configure/app/output/disable-node-polyfill.mdx"},{"id":414,"title":"output.disableSourceMap","routePath":"/configure/app/output/disable-source-map","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableSourceMap。\n\n * 类型：\n\ntype DisableSourceMap =\n  | boolean\n  | {\n      js?: boolean;\n      css?: boolean;\n    };\n\n\n * 默认值：\n\nconst defaultDisableSourceMap = {\n  js: false,\n  css: process.env.NODE_ENV === 'production',\n};\n\n\n是否禁用 Source Map 生成。\n\n什么是 Source Map\n\nSource Map 是保存源代码映射关系的信息文件，它记录了编译后的代码的每一个位置，以及所对应的编译前的位置。通过 Source\nMap，可以在调试编译后的代码时，直接查看对应的源代码。\n\n默认情况下，Builder 的 Source Map 生成规则如下：\n\n * 在开发环境构建时，会生成 JS 文件和 CSS 文件的 SourceMap，便于进行开发调试。\n * 在生产环境构建时，会生成 JS 文件的 Source Map，用于调试和排查线上问题；不会生成 CSS 文件的 Source Map。\n\nTIP\n\n在使用 Rspack 作为打包工具时，暂不支持单独禁用 css sourcemap。\n\n如果项目不需要 Source Map，可以关闭该功能，从而提升构建的速度。\n\nexport default {\n  output: {\n    disableSourceMap: true,\n  },\n};\n\n\n如果需要开启开发环境的 Source Map，并在生产环境禁用，可以设置为：\n\nexport default {\n  output: {\n    disableSourceMap: process.env.NODE_ENV === 'production',\n  },\n};\n\n\n如果需要单独控制 JS 文件或 CSS 文件的 Source Map，可以参考下方设置：\n\nexport default {\n  output: {\n    disableSourceMap: {\n      js: false,\n      css: true,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"disableSourceMap"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/disable-source-map.mdx","_relativePath":"zh/configure/app/output/disable-source-map.mdx"},{"id":415,"title":"output.disableSvgr","routePath":"/configure/app/output/disable-svgr","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableSvgr。\n\n * 类型： boolean\n * 默认值： false\n\n是否调用 SVGR 将 SVG 转化为 React 组件。如果设置为 true，将把所有的.svg 文件视为资源处理。\n\n默认情况下，在 JS 文件中引用 SVG 资源时，Builder 会调用 SVGR，将 SVG 图片转换为一个 React 组件。 如果你确定项目内的所有\nSVG 资源都没有当成 React 组件使用时，可以通过将 disableSvgr 设置为 true 来关闭此项转换，以提升构建性能。\n\nexport default {\n  output: {\n    disableSvgr: true,\n  },\n};\n","frontmatter":{"sidebar_label":"disableSvgr"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/disable-svgr.mdx","_relativePath":"zh/configure/app/output/disable-svgr.mdx"},{"id":416,"title":"output.disableTsChecker","routePath":"/configure/app/output/disable-ts-checker","lang":"zh","toc":[{"text":"阻塞编译","id":"阻塞编译","depth":3,"charIndex":276},{"text":"示例","id":"示例","depth":3,"charIndex":350}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableTsChecker。\n\n * 类型： boolean\n * 默认值： false\n\n是否禁用编译过程中的 TypeScript 类型检查。\n\n默认情况下，Builder 执行构建的过程中，会在一个独立的进程里运行 TypeScript 类型检查工具，它的检查逻辑与 TypeScript 原生的 tsc\n命令一致，你可以通过 tsconfig.json 或是 Builder 的 tools.tsChecker 配置项来自定义检查行为。\n\n\n阻塞编译#\n\n * 在开发环境构建时，类型错误不会阻塞编译流程。\n * 在生产环境构建时，类型错误会导致构建失败，以保证生产环境代码的稳定性。\n\n\n示例#\n\n禁用 TypeScript 类型检查：\n\nexport default {\n  output: {\n    disableTsChecker: true,\n  },\n};\n\n\n禁用开发环境构建时的类型检查：\n\nexport default {\n  output: {\n    disableTsChecker: process.env.NODE_ENV === 'development',\n  },\n};\n\n\n禁用生产环境构建时的类型检查：\n\nexport default {\n  output: {\n    disableTsChecker: process.env.NODE_ENV === 'production',\n  },\n};\n\n\nTIP\n\n不建议在生产环境构建时禁用类型检查，这会导致线上代码的稳定性下降，请谨慎使用。","frontmatter":{"sidebar_label":"disableTsChecker"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/disable-ts-checker.mdx","_relativePath":"zh/configure/app/output/disable-ts-checker.mdx"},{"id":417,"title":"output.distPath","routePath":"/configure/app/output/dist-path","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":769}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.distPath。\n\n * 类型：\n\ntype DistPathConfig = {\n  root?: string;\n  js?: string;\n  css?: string;\n  svg?: string;\n  font?: string;\n  html?: string;\n  image?: string;\n  media?: string;\n  server?: string;\n};\n\n\n * 默认值：\n\nconst defaultDistPath = {\n  root: 'dist',\n  html: 'html',\n  js: 'static/js',\n  css: 'static/css',\n  svg: 'static/svg',\n  font: 'static/font',\n  image: 'static/image',\n  media: 'static/media',\n  server: 'bundles',\n};\n\n\n设置构建产物的输出目录，Builder 会根据产物的类型输出到对应的子目录下。\n\n其中：\n\n * root: 表示所有构建产物输出的根目录。\n * html：表示 HTML 文件的输出目录。\n * js：表示 JavaScript 文件的输出目录。\n * css：表示 CSS 样式文件的输出目录。\n * svg：表示 SVG 图片的输出目录。\n * font：表示字体文件的输出目录。\n * image：表示非 SVG 图片的输出目录。\n * media：表示视频等媒体资源的输出目录。\n * server: 表示服务端产物的输出目录，仅在 target 为 node 时有效。\n\n\n示例#\n\n以 JavaScript 文件为例，会输出到 distPath.root + distPath.js 目录，即为 dist/static/js。\n\n如果需要将 JavaScript 文件输出到 build/resource/js 目录，可以这样设置：\n\nexport default {\n  output: {\n    distPath: {\n      root: 'build',\n      js: 'resource/js',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"distPath"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/dist-path.mdx","_relativePath":"zh/configure/app/output/dist-path.mdx"},{"id":418,"title":"output.enableAssetFallback","routePath":"/configure/app/output/enable-asset-fallback","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":156}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableAssetFallback。\n\n * 类型： boolean\n * 默认值： false\n\n开启该选项后，当编译过程中遇到无法识别的文件类型时，会直接将该文件直接输出到产物目录；否则会抛出一个异常。\n\n\n示例#\n\n开启配置项：\n\nexport default {\n  output: {\n    enableAssetFallback: true,\n  },\n};\n\n\n在代码中引用一个未知类型的模块：\n\nimport './foo.xxx';\n\n\n编译后，foo.xxx 会被自动输出到 dist/static/media 目录下。\n\n你可以通过 output.distPath.media 和 output.filename.media 配置项来控制 fallback 后的输出路径和文件名称。\n\nTIP\n\n开启该配置会导致 webpack 配置中的 rules 结构变化，增加一层额外的 oneOf 嵌套结构。大多数情况下，我们不推荐你使用此配置。","frontmatter":{"sidebar_label":"enableAssetFallback"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/enable-asset-fallback.mdx","_relativePath":"zh/configure/app/output/enable-asset-fallback.mdx"},{"id":419,"title":"output.enableAssetManifest","routePath":"/configure/app/output/enable-asset-manifest","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":135}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableAssetManifest。\n\n * 类型： boolean\n * 默认值： false\n\n是否生成 manifest 文件，该文件包含所有构建产物的信息。\n\n\n示例#\n\n添加以下配置来开启：\n\nexport default {\n  output: {\n    enableAssetManifest: true,\n  },\n};\n\n\n开启后，当编译完成时，会自动生成 dist/manifest.json 文件：\n\n{\n  \"files\": {\n    \"main.css\": \"/static/css/main.45b01211.css\",\n    \"main.js\": \"/static/js/main.52fd298f.js\",\n    \"html/main/index.html\": \"/html/main/index.html\"\n  },\n  \"entrypoints\": [\"static/css/main.45b01211.css\", \"static/js/main.52fd298f.js\"]\n}\n","frontmatter":{"sidebar_label":"enableAssetManifest"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/enable-asset-manifest.mdx","_relativePath":"zh/configure/app/output/enable-asset-manifest.mdx"},{"id":420,"title":"output.enableCssModuleTSDeclaration","routePath":"/configure/app/output/enable-css-module-tsdeclaration","lang":"zh","toc":[{"text":"Example","id":"example","depth":3,"charIndex":168}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableCssModuleTSDeclaration。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否生成 CSS Modules 的 TypeScript 声明文件。\n\n\nExample#\n\n启用 CSS Module TypeScript 声明，比如：\n\nexport default {\n  output: {\n    enableCssModuleTSDeclaration: true,\n  },\n};\n\n\n项目构建完成后，每个 CSS Module 文件都会生成一个 .d.ts 文件。例如：\n\ninterface CssExports {\n  title: string;\n}\nexport const cssExports: CssExports;\nexport default cssExports;\n","frontmatter":{"sidebar_label":"enableCssModuleTSDeclaration"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/enable-css-module-tsdeclaration.mdx","_relativePath":"zh/configure/app/output/enable-css-module-tsdeclaration.mdx"},{"id":421,"title":"output.enableInlineScripts","routePath":"/configure/app/output/enable-inline-scripts","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"通过正则匹配","id":"通过正则匹配","depth":3,"charIndex":145}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableInlineScripts。\n\n * 类型： boolean | RegExp\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n用来控制生产环境中是否用\n\n\n通过正则匹配#\n\n当你需要内联产物中的一部分 JS 文件时，你可以将 enableInlineScripts 设置为一个正则表达式，匹配需要内联的 JS 文件的 URL。\n\n比如，将产物中的 main.js 内联到 HTML 中，你可以添加如下配置：\n\nexport default {\n  output: {\n    enableInlineScripts: /\\/main\\.\\w+\\.js$/,\n  },\n};\n\n\nTIP\n\n生产环境的文件名中默认包含了一个 hash 值，比如 /main.18a568e5.js。","frontmatter":{"sidebar_label":"enableInlineScripts"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/enable-inline-scripts.mdx","_relativePath":"zh/configure/app/output/enable-inline-scripts.mdx"},{"id":422,"title":"output.enableInlineStyles","routePath":"/configure/app/output/enable-inline-styles","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"通过正则匹配","id":"通过正则匹配","depth":3,"charIndex":-1}],"domain":"","content":"","frontmatter":{"sidebar_label":"enableInlineStyles"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/enable-inline-styles.mdx","_relativePath":"zh/configure/app/output/enable-inline-styles.mdx"},{"id":423,"title":"output.enableLatestDecorators","routePath":"/configure/app/output/enable-latest-decorators","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableLatestDecorators。\n\n * 类型： boolean\n * 默认值： false\n\n是否要使用 新版 decorator 提案 进行编译。\n\n默认情况下，Builder 在编译装饰器时采用 旧版 decorator 提案。\n\n将 output.enableLatestDecorators 设置为 true 时，Builder 会采用新版 decorator 提案 (2018-09\n版本) 进行编译。\n\nexport default {\n  output: {\n    enableLatestDecorators: true,\n  },\n};\n","frontmatter":{"sidebar_label":"enableLatestDecorators"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/enable-latest-decorators.mdx","_relativePath":"zh/configure/app/output/enable-latest-decorators.mdx"},{"id":424,"title":"output.externals","routePath":"/configure/app/output/externals","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":213}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.externals。\n\n * 类型： string | object | function | RegExp\n * 默认值： undefined\n\n在构建时，防止将代码中某些 import 的依赖包打包到 bundle 中，而是在运行时再去从外部获取这些依赖。\n\n详情请见: webpack 外部扩展 (Externals)\n\n\n示例#\n\n将 react-dom 依赖从构建产物中剔除。为了在运行时获取这个模块, react-dom 的值将全局检索 ReactDOM 变量。\n\nexport default {\n  output: {\n    externals: {\n      'react-dom': 'ReactDOM',\n    },\n  },\n};\n\n\nTIP\n\n当构建 Web Worker 产物时，externals 将不会生效。这是因为 Worker 环境不支持通过访问全局变量。","frontmatter":{"sidebar_label":"externals"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/externals.mdx","_relativePath":"zh/configure/app/output/externals.mdx"},{"id":425,"title":"output.filename","routePath":"/configure/app/output/filename","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":958},{"text":"异步模块的文件名","id":"异步模块的文件名","depth":3,"charIndex":1409}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.filename。\n\n * 类型：\n\ntype FilenameConfig = {\n  js?: string;\n  css?: string;\n  svg?: string;\n  font?: string;\n  image?: string;\n  media?: string;\n};\n\n\n * 默认值：\n\n// 开发环境\nconst devDefaultFilename = {\n  js: '[name].js',\n  css: '[name].css',\n  svg: '[name].[contenthash:8].svg',\n  font: '[name].[contenthash:8][ext]',\n  image: '[name].[contenthash:8][ext]',\n  media: '[name].[contenthash:8][ext]',\n};\n\n// 生产环境\nconst prodDefaultFilename = {\n  js: '[name].[contenthash:8].js',\n  css: '[name].[contenthash:8].css',\n  svg: '[name].[contenthash:8].svg',\n  font: '[name].[contenthash:8][ext]',\n  image: '[name].[contenthash:8][ext]',\n  media: '[name].[contenthash:8][ext]',\n};\n\n\n设置构建产物的名称。\n\n在生产环境构建后，会自动在文件名中间添加 hash 值，如果不需要添加，可以通过 output.disableFilenameHash 配置来禁用该行为。\n\n下面是各个文件类型的说明：\n\n * js：表示 JavaScript 文件的名称。\n * css：表示 CSS 样式文件的名称。\n * svg：表示 SVG 图片的名称。\n * font：表示字体文件的名称。\n * image：表示非 SVG 图片的名称。\n * media：表示视频等媒体资源的名称。\n\n\n示例#\n\n修改 JavaScript 文件的名称为 [name]_script.js：\n\nexport default {\n  output: {\n    filename: {\n      js:\n        process.env.NODE_ENV === 'production'\n          ? '[name]_script.[contenthash:8].js'\n          : '[name]_script.js',\n    },\n  },\n};\n\n\n文件名中的 hash 值\n\n通常来说，我们只会在生产环境下设置文件名的 hash 值（即 process.env.NODE_ENV === 'production' 时）。\n\n如果你在开发环境下设置了文件名的 hash，那么可能会导致热更新不生效（尤其是 CSS 文件）。这是因为每次文件内容变化时，都会引起 hash 变化，导致\nmini-css-extract-plugin 等工具无法读取到最新的文件内容。\n\n\n异步模块的文件名#\n\n当你在代码中通过 dynamic import 的方式引入模块时，该模块会被单独打包成一个文件，它默认的命名规则如下：\n\n * 在开发环境下会基于模块路径生成名称，比如 dist/static/js/async/src_add_ts.js。\n * 在生产环境下会是一个随机的数字 id，比如\n   dist/static/js/async/798.27e3083e.js，这是为了避免在生产环境中泄露源代码的路径，同时字符数也更少。\n\nconst { add } = await import('./add.ts');\n\n\n如果你希望为异步模块指定一个固定的名称，可以通过打包工具提供的 magic comments 来实现，通过 webpackChunkName 指定模块名称：\n\nconst { add } = await import(\n  /* webpackChunkName: \"my-chunk-name\" */ './add.ts'\n);\n\n\n通过以上写法指定模块名称后，生成的文件会是 dist/static/js/async/my-chunk-name.js。","frontmatter":{"sidebar_label":"filename"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/filename.mdx","_relativePath":"zh/configure/app/output/filename.mdx"},{"id":426,"title":"output.legalComments","routePath":"/configure/app/output/legal-comments","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":445}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.legalComments。\n\n * 类型： 'linked' | 'inline' | 'none'\n * 默认值： 'linked'\n\n配置 legal comment 的处理方式。\n\nlegal comment 是 JS 或 CSS 文件中的一些特殊注释，这些注释包含 @license 或 @preserve，或是以 //!\n开头。默认情况下，这些注释保留在输出文件中，因为这遵循了代码原作者的意图。\n\n你可以通过 legalComments 来配置相关行为：\n\n * linked：将所有 legal comments 移至 .LEGAL.txt 文件并通过注释链接到它们。\n * inline：保留所有 legal comments。\n * none：移除所有 legal comments。\n\nTIP\n\n在使用 Rspack 作为打包工具时，暂不支持 inline 配置项。\n\n\n示例#\n\n移除所有 legal comments。\n\nexport default {\n  output: {\n    legalComments: 'none',\n  },\n};\n","frontmatter":{"sidebar_label":"legalComments"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/legal-comments.mdx","_relativePath":"zh/configure/app/output/legal-comments.mdx"},{"id":427,"title":"output.overrideBrowserslist","routePath":"/configure/app/output/override-browserslist","lang":"zh","toc":[{"text":"优先级","id":"优先级","depth":4,"charIndex":212},{"text":"默认值","id":"默认值","depth":4,"charIndex":424},{"text":"示例","id":"示例","depth":3,"charIndex":556},{"text":"根据产物类型设置","id":"根据产物类型设置","depth":4,"charIndex":793}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.overrideBrowserslist。\n\n * 类型： string[] | Record\n * 默认值： undefined\n\n指定项目兼容的目标浏览器范围。该值会被 @babel/preset-env 和 autoprefixer 用来确定需要转换的 JavaScript\n语法特性和需要添加的 CSS 浏览器前缀。\n\n优先级#\n\noverrideBrowserslist 配置的优先级高于项目中的 .browserslistrc 配置文件和 package.json 中的\nbrowserslist 字段。\n\n大多数场景下，推荐优先使用 .browserslistrc 文件，而不是使用 overrideBrowserslist 配置。因为\n.browserslistrc 文件是官方定义的配置文件，通用性更强，可以被社区中的其他库识别。\n\n默认值#\n\n如果项目中没有定义任何 browserslist 相关的配置，也没有定义 overrideBrowserslist，那么 Builder 会设置默认值为：\n\n['> 0.01%', 'not dead', 'not op_mini all'];\n\n\n\n示例#\n\n下面是兼容移动端 H5 场景的示例：\n\nexport default {\n  output: {\n    overrideBrowserslist: [\n      'iOS >= 9',\n      'Android >= 4.4',\n      'last 2 versions',\n      '> 0.2%',\n      'not dead',\n    ],\n  },\n};\n\n\n可以查看 browserslist 文档 来了解如何自定义浏览器范围。\n\n根据产物类型设置#\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的目标浏览器范围。此时，你需要把 overrideBrowserslist 设置为一个对象，对象的\nkey 为对应的产物类型。\n\n比如为 web 和 node 设置不同的范围：\n\nexport default {\n  output: {\n    overrideBrowserslist: {\n      web: [\n        'iOS >= 9',\n        'Android >= 4.4',\n        'last 2 versions',\n        '> 0.2%',\n        'not dead',\n      ],\n      node: ['node >= 14'],\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"overrideBrowserslist"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/override-browserslist.mdx","_relativePath":"zh/configure/app/output/override-browserslist.mdx"},{"id":428,"title":"output.polyfill","routePath":"/configure/app/output/polyfill","lang":"zh","toc":[{"text":"配置项","id":"配置项","depth":3,"charIndex":159},{"text":"entry","id":"entry","depth":4,"charIndex":165},{"text":"usage","id":"usage","depth":4,"charIndex":278},{"text":"ua","id":"ua","depth":4,"charIndex":443},{"text":"off","id":"off","depth":4,"charIndex":534}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.polyfill。\n\n * 类型： 'entry' | 'usage' | 'ua' | 'off'\n * 默认值： 'entry'\n\n通过 output.polyfill 你可以配置 Polyfill 的注入方式。\n\n\n配置项#\n\nentry#\n\n当 output.polyfill 配置为 'entry' 时，会在每个入口文件中注入 Polyfill。\n\n等价于 @babel/preset-env 的 useBuiltIns: 'entry' 配置。\n\nusage#\n\n当 output.polyfill 配置为 'usage' 时，会在每个文件中根据代码中使用的 API 注入 Polyfill。\n\n等价于 @babel/preset-env 的 useBuiltIns: 'usage' 配置。\n\nTIP\n\n在使用 Rspack 作为打包工具时，暂不支持 usage 配置项。\n\nua#\n\n根据当前请求的 UA 信息，动态下发 Polyfill 代码。\n\n动态下发能力需要与上层框架结合使用，详情可参考 Modern.js - 运行时按需 Polyfill。\n\noff#\n\n不注入 Polyfill。使用此选项时，需要自行保证代码的兼容性。","frontmatter":{"sidebar_label":"polyfill"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/polyfill.mdx","_relativePath":"zh/configure/app/output/polyfill.mdx"},{"id":429,"title":"output.splitRouteChunks","routePath":"/configure/app/output/splitRouteChunks","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n当使用约定式路由时，框架会根据路由对 js 和 css 进行拆分，以实现按需加载。如果你的项目不希望根据路由对 js 和 css 进行拆分，可以将该选项设置为\nfalse。\n\n示例\n\nexport default {\n  output: {\n    splitRouteChunks: false,\n  },\n}\n","frontmatter":{"sidebar_label":"splitRouteChunks"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/splitRouteChunks.mdx","_relativePath":"zh/configure/app/output/splitRouteChunks.mdx"},{"id":430,"title":"output.ssg","routePath":"/configure/app/output/ssg","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":103},{"text":"单入口","id":"单入口","depth":3,"charIndex":109},{"text":"多入口","id":"多入口","depth":3,"charIndex":947},{"text":"配置路由","id":"配置路由","depth":3,"charIndex":1497},{"text":"阻止默认行为","id":"阻止默认行为","depth":3,"charIndex":2076},{"text":"添加动态路由参数","id":"添加动态路由参数","depth":3,"charIndex":2512}],"domain":"","content":"#\n\n * 类型： boolean | object | function\n * 默认值： undefined\n\n开启自控式路由或约定式路由 SSG 功能的配置。\n\n客户端路由\n\n相关内容可以查看路由。\n\n\n示例#\n\n\n单入口#\n\n当该配置设置为 true 时，将会默认开启所有入口的 SSG 功能。\n\n对自控式路由而言，将会渲染入口的根路由。对约定式路由而言，将会渲染入口中每一条路由。\n\n例如 src/ 目录下有以下满足约定式路由的文件结构：\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       ├── page.tsx\n│       └── user\n│           ├── layout.tsx\n│           ├── page.tsx\n│           └── profile\n│               └── page.tsx\n\n\n在 modern.config.js 中做以下设置：\n\nexport default defineConfig({\n  output: {\n    ssg: true,\n  },\n});\n\n\n执行 pnpm build 构建应用后。dist/ 目录将会生成三张 HTML 分别对应三条路由（不开启 SSG 时只有一张 HTML），并且所有 HTML\n都已经渲染。\n\n而例如下面的自控式路由：\n\n\n\n\n\n\nconst Router = typeof window === 'undefined' ? StaticRouter : BrowserRouter;\n\nexport default () => {\n  const { context } = useRuntimeContext();\n  const pathname = context?.request?.pathname;\n  return (\n    \n      \n        index} />\n        about} />\n      \n    \n  );\n};\n\n\n同样使用上面的配置，在执行 pnpm run build 后，只有入口路由 / 会生成渲染后的 HTML。\n\n\n多入口#\n\noutput.ssg 也可以按照入口配置，配置生效的规则同样由入口路由方式决定。\n\n例如以下目录结构：\n\n。\n├── src\n│   ├── entryA\n│   │   └── routes\n│   │       ├── layout.tsx\n│   │       ├── page.tsx\n│   │       └── user\n│   │           ├── layout.tsx\n│   │           ├── page.tsx\n│   │           └── profile\n│   │               └── page.tsx\n│   └── entryB\n│       └── App.tsx\n\n\n默认情况下，所有约定式路由的入口，在设置 output.ssg 配置为 true 后都会在构建阶段渲染。可以配置 false\n来取消指定入口的的默认行为，例如取消上述 entryA 入口在构建时的渲染：\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      entryA: true,\n      entryB: false,\n    },\n  },\n});\n\n\n\n配置路由#\n\n上述内容中提到，自控式路由默认只会开启入口路由的 SSG 配置。\n\n可以在 output.ssg 中设置具体的路由，告知 Modern.js 开启这些客户端路由的 SSG 功能。例如上述 src/App.tsx 的文件内容为：\n\n在 modern.config.js 中这样设置后，/about 路由也会开启 SSG 功能：\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      routes: ['/', '/about'],\n    },\n  },\n});\n\n\nModern.js 将会自动根据入口拼接完整的 URL 并交给 SSG 插件完成渲染。\n\n也可以为具体入口或路由配置请求头，例如：\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      headers: {},\n      routes: [\n        '/',\n        {\n          url: '/about',\n          headers: {},\n        },\n      ],\n    },\n  },\n});\n\n\nINFO\n\n路由中设置的 headers 会覆盖入口中设置的 headers。\n\n\n阻止默认行为#\n\n默认情况下，约定式路由的路由会全部开启 SSG。Modern.js 提供了另一个字段，用来阻止默认的 SSG 行为。\n\n例如以下目录结构，/、/user、/user/profle 三条路由都开启 SSG：\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       ├── page.tsx\n│       └── user\n│           ├── layout.tsx\n│           ├── page.tsx\n│           └── profile\n│               └── page.tsx\n\n\n可以这样设置，禁用某一条客户端路由的默认行为：\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      preventDefault: ['/user'],\n    },\n  },\n});\n\n\n\n添加动态路由参数#\n\n部分路由可能是动态的，例如自控式路由中的 /user/:id 或是约定式路由中 user/[id]/page.tsx 文件生成的路由。\n\n可以在 output.ssg 中配置具体的参数，渲染指定参数的路由，例如：\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      routes: [\n        {\n          url: '/user/:id',\n          params: [\n            {\n              id: 'modernjs',\n            },\n          ],\n        },\n      ],\n    },\n  },\n});\n\n\n动态路由和 SSG 的组合，在根据 CMS 系统数据变更，实时生成静态页面时非常有用。","frontmatter":{"sidebar_label":"ssg"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/ssg.mdx","_relativePath":"zh/configure/app/output/ssg.mdx"},{"id":431,"title":"output.svgDefaultExport","routePath":"/configure/app/output/svg-default-export","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.svgDefaultExport。\n\n * 类型： 'url' | 'component'\n * 默认值： 'url'\n\noutput.svgDefaultExport 可以用来配置 SVG 文件的默认导出。\n\n当 output.svgDefaultExport 配置为 url 时，SVG 文件的默认导出是文件的 URL。例如：\n\n\n\nconsole.log(logo); // => 资源 url\n\n\n当 output.svgDefaultExport 配置为 component 时，SVG 文件的默认导出是文件的 React 组件。例如：\n\n\n\nconsole.log(Logo); // => React 组件\n\n\n此时，你也可以通过指定 ?url 的 query 来导入 url，比如：\n\n\n\nconsole.log(logo); // => 资源 url\n","frontmatter":{"sidebar_label":"svgDefaultExport"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/svg-default-export.mdx","_relativePath":"zh/configure/app/output/svg-default-export.mdx"},{"id":432,"title":"output.tempDir","routePath":"/configure/app/output/temp-dir","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： string\n * 默认值： ''\n\n项目开发或构建时，Modern.js 会生成真实的 Webpack 入口和 HTML 模板，并放在临时目录下。\n\n如果希望由多个配置同时启动某项目，可以通过该配置，将文件生成到不同的临时目录下，避免相互干扰。配置可以是相对路径或绝对路径，但应避免项目外的路径。\n\n示例\n\nexport default {\n  output: {\n    tempDir: path.join('node_modules', '.temp-dir'),\n  }\n}\n","frontmatter":{"sidebar_label":"tempDir"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/output/temp-dir.mdx","_relativePath":"zh/configure/app/output/temp-dir.mdx"},{"id":433,"title":"performance.buildCache","routePath":"/configure/app/performance/build-cache","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.buildCache。\n\n * 类型：\n\ntype BuildCacheConfig =\n  | {\n      /**\n       * webpack 文件缓存系统的缓存目录\n       */\n      cacheDirectory?: string;\n    }\n  | boolean;\n\n\n * 默认值：\n\nconst defaultBuildCacheConfig = {\n  cacheDirectory: './node_modules/.cache/webpack',\n};\n\n\n * 打包工具： 仅支持 webpack\n\n控制 Builder 在构建过程中的缓存行为。\n\nBuilder 默认会开启构建缓存来提升二次构建的速度，并默认把生成的缓存文件写到 ./node_modules/.cache/webpack 目录下。\n\n你可以通过 buildCache 配置缓存路径，比如：\n\nexport default {\n  performance: {\n    buildCache: {\n      cacheDirectory: './node_modules/.custom_cache/webpack',\n    },\n  },\n};\n\n\n如果不希望缓存，你也可以将 buildCache 置为 false 将其禁用掉：\n\nexport default {\n  performance: {\n    buildCache: false,\n  },\n};\n","frontmatter":{"sidebar_label":"buildCache"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/performance/build-cache.mdx","_relativePath":"zh/configure/app/performance/build-cache.mdx"},{"id":434,"title":"performance.bundleAnalyze","routePath":"/configure/app/performance/bundle-analyze","lang":"zh","toc":[{"text":"启用 Bundle Analyze","id":"启用-bundle-analyze","depth":3,"charIndex":357},{"text":"覆盖默认配置","id":"覆盖默认配置","depth":3,"charIndex":789},{"text":"Size 类型","id":"size-类型","depth":3,"charIndex":1042},{"text":"生成 stats.json","id":"生成-statsjson","depth":3,"charIndex":1243},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":1413}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.bundleAnalyze。\n\n * 类型： Object | undefined\n\n用于开启 webpack-bundle-analyzer 插件来分析产物体积。\n\n默认情况下，Builder 不会开启 webpack-bundle-analyzer。当开启该功能后，内部的默认配置如下:\n\nconst defaultConfig = {\n  analyzerMode: 'static',\n  openAnalyzer: false,\n  // target 为编译目标，如 `web`、`node` 等\n  reportFilename: `report-${target}.html`,\n};\n\n\n\n启用 Bundle Analyze#\n\n你有两种方式开启 webpack-bundle-analyzer 来分析构建产物的体积:\n\n * 添加环境变量 BUNDLE_ANALYZE=true，比如：\n\nBUNDLE_ANALYZE=true pnpm build\n\n\n * 配置 performance.bundleAnalyze 来固定开启：\n\nexport default {\n  performance: {\n    bundleAnalyze: {},\n  },\n};\n\n\n在启用后，Builder 会生成一个分析构建产物体积的 HTML 文件，并在 Terminal 中打印以下日志：\n\nWebpack Bundle Analyzer saved report to /Project/my-project/dist/report-web.html\n\n\n手动在浏览器中打开该文件，可以看到打包产物的瓦片图；区块的面积越大，说明该模块的体积越大。\n\n\n\n\n覆盖默认配置#\n\n你可以通过 performance.bundleAnalyze 来覆盖默认配置，比如开启 server 模式：\n\nexport default {\n  performance: {\n    bundleAnalyze: process.env.BUNDLE_ANALYZE\n      ? {\n          analyzerMode: 'server',\n          openAnalyzer: true,\n        }\n      : {},\n  },\n};\n\n\n\nSize 类型#\n\n在 webpack-bundle-analyzer 的面板中，你可以在左上角控制 Size 类型（默认为 Parsed）：\n\n * Stat：从打包工具的 stats 对象中获取的体积，它反映了代码在压缩之前的体积。\n * Parsed：磁盘上的文件体积，它反映了代码在压缩之后的体积。\n * Gzipped：浏览器里请求的文件体积，它反映了代码在压缩和 gzip 后的体积。\n\n\n生成 stats.json#\n\ngenerateStatsFile 设置为 true 时，将会生成 stats JSON 文件。\n\nexport default {\n  performance: {\n    bundleAnalyze: {\n      generateStatsFile: true,\n    },\n  },\n};\n\n\n\n注意事项#\n\n 1. 开启 Server 模式会导致 build 进程不能正常退出。\n 2. 开启 bundleAnalyzer 会降低构建性能。因此，在日常开发过程中不应该开启此配置项，建议通过 BUNDLE_ANALYZE\n    环境变量来按需开启。\n 3. 由于 dev 阶段不会进行代码压缩等优化，无法反映真实的产物体积，因此建议在 build 阶段分析产物体积。","frontmatter":{"sidebar_label":"bundleAnalyze"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/performance/bundle-analyze.mdx","_relativePath":"zh/configure/app/performance/bundle-analyze.mdx"},{"id":435,"title":"performance.chunkSplit","routePath":"/configure/app/performance/chunk-split","lang":"zh","toc":[{"text":"chunkSplit.strategy","id":"chunksplitstrategy","depth":3,"charIndex":774},{"text":"默认拆包策略","id":"默认拆包策略","depth":3,"charIndex":1076},{"text":"chunkSplit.minSize","id":"chunksplitminsize","depth":3,"charIndex":1650},{"text":"chunkSplit.maxSize","id":"chunksplitmaxsize","depth":3,"charIndex":1954},{"text":"chunkSplit.forceSplitting","id":"chunksplitforcesplitting","depth":3,"charIndex":2264},{"text":"chunkSplit.splitChunks","id":"chunksplitsplitchunks","depth":3,"charIndex":2667},{"text":"chunkSplit.override","id":"chunksplitoverride","depth":3,"charIndex":3173}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.chunkSplit。\n\n * 类型： Object\n * 默认值： { strategy: 'split-by-experience' }\n\nperformance.chunkSplit 用于配置 Builder 的拆包策略。配置项的类型 ChunkSplit 如下:\n\ntype ForceSplitting = RegExp[] | Record;\n\ninterface BaseChunkSplit {\n  strategy?:\n    | 'split-by-module'\n    | 'split-by-experience'\n    | 'all-in-one'\n    | 'single-vendor';\n  override?: SplitChunks;\n  forceSplitting?: ForceSplitting;\n}\n\ninterface SplitBySize {\n  strategy?: 'split-by-size';\n  minSize?: number;\n  maxSize?: number;\n  override?: SplitChunks;\n  forceSplitting?: ForceSplitting;\n}\n\ninterface SplitCustom {\n  strategy?: 'custom';\n  splitChunks?: SplitChunks;\n  forceSplitting?: ForceSplitting;\n}\n\nexport type ChunkSplit = BaseChunkSplit | SplitBySize | SplitCustom;\n\n\n\nchunkSplit.strategy#\n\nBuilder 支持设置以下几种拆包策略：\n\n * split-by-experience: 根据经验制定的拆分策略，自动将一些常用的 npm 包拆分为体积适中的 chunk。\n * split-by-module: 按 NPM 包的粒度拆分，每个 NPM 包对应一个 chunk。\n * split-by-size：根据模块大小自动进行拆分。\n * all-in-one: 将所有代码全部打包到一个 chunk 中。\n * single-vendor: 将所有 NPM 包的代码打包到一个单独的 chunk 中。\n * custom: 自定义拆包配置。\n\n\n默认拆包策略#\n\nBuilder 默认采用 split-by-experience 策略，这是我们根据经验制定的策略。具体来说，当你的项目中引用了以下 npm\n包时，它们会自动被拆分为单独的 chunk：\n\n * lib-polyfill.js：包含 core-js，@babel/runtime，@swc/helpers。\n * lib-react.js：包含 react，react-dom。\n * lib-router.js：包含 react-router，react-router-dom，history，@remix-run/router。\n * lib-lodash.js：包含 lodash，lodash-es。\n * lib-antd.js：包含 antd。\n * lib-arco.js：包含 @arco-design/web-react。\n * lib-semi.js：包含 @douyinfe/semi-ui。\n\nTIP\n\n如果项目中没有安装或引用以上 npm 包，则不会生成相应的 chunk。\n\n如果你想使用其他拆包策略，可以通过 performance.chunkSplit.strategy 配置项来指定。\n\nTIP\n\n在使用 Rspack 作为打包工具时，暂时不支持采用 split-by-module 策略。\n\n\nchunkSplit.minSize#\n\n * 类型： number\n * 默认值： 10000\n\n当 performance.chunkSplit.strategy 为 split-by-size 时，可以通过\nperformance.chunkSplit.minSize 配置项来指定 chunk 的最小大小，单位为字节。默认值为 10000。比如:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'split-by-size',\n      minSize: 20000,\n    },\n  },\n};\n\n\n\nchunkSplit.maxSize#\n\n * 类型： number\n * 默认值： Infinity\n\n当 performance.chunkSplit.strategy 为 split-by-size 时，可以通过\nperformance.chunkSplit.maxSize 配置项来指定 chunk 的最大大小，单位为字节。默认值为 Infinity。比如:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'split-by-size',\n      maxSize: 50000,\n    },\n  },\n};\n\n\n\nchunkSplit.forceSplitting#\n\n * 类型： RegExp[] | Record\n * 默认值： []\n\n通过 performance.chunkSplit.forceSplitting 配置项可以将指定的模块强制拆分为一个独立的 chunk。\n\n比如将 node_modules 下的 axios 库拆分到 axios.js 中：\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'split-by-experience',\n      forceSplitting: {\n        axios: /node_modules\\/axios/,\n      },\n    },\n  },\n};\n\n\n相比直接配置 webpack 的 splitChunks，这是一个更加简便的方式。\n\n\nchunkSplit.splitChunks#\n\n当 performance.chunkSplit.strategy 为 custom 时，可以通过\nperformance.chunkSplit.splitChunks 配置项来指定自定义的 webpack 拆包配置。此配置会和 webpack 的\nsplitChunks 配置进行合并（cacheGroups 配置也会合并）。比如:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'custom',\n      splitChunks: {\n        cacheGroups: {\n          react: {\n            test: /[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/,\n            name: 'react',\n            chunks: 'all',\n          },\n        },\n      },\n    },\n  },\n};\n\n\n\nchunkSplit.override#\n\n当 performance.chunkSplit.strategy 为\nsplit-by-experience、split-by-module、split-by-size 或 single-vendor 时，可以通过\nperformance.chunkSplit.override 配置项来自定义 webpack 拆包配置，此配置会和 webpack 的 splitChunks\n配置进行合并（cacheGroups 配置也会合并）。比如:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'split-by-experience',\n      override: {\n        cacheGroups: {\n          react: {\n            test: /[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/,\n            name: 'react',\n            chunks: 'all',\n          },\n        },\n      },\n    },\n  },\n};\n\n\n> 当 Builder 构建 \"node\" 类型的产物时，由于 Node Bundles 不需要通过拆包来优化加载性能，因此 chunkSplit\n> 规则不会生效。","frontmatter":{"sidebar_label":"chunkSplit"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/performance/chunk-split.mdx","_relativePath":"zh/configure/app/performance/chunk-split.mdx"},{"id":436,"title":"performance.printFileSize","routePath":"/configure/app/performance/print-file-size","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":553}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.printFileSize。\n\n * 类型： boolean\n * 默认值： true\n\n是否在生产环境构建后输出所有静态资源文件的体积。\n\ninfo    File sizes after production build:\n\n  File                                     Size         Gzipped\n  dist/static/js/lib-corejs.1c836fe7.js    212.89 kB    66.57 kB\n  dist/static/js/lib-react.fcafbc5c.js     134.65 kB    43.45 kB\n  dist/static/js/main.6ff06f70.js          8.93 kB      3.73 kB\n  dist/static/css/main.9f48031b.css        2.64 kB      927 B\n  dist/html/main/index.html                1.64 kB      874 B\n\n\n\n示例#\n\n禁用相关日志：\n\nexport default {\n  performance: {\n    printFileSize: false,\n  },\n};\n","frontmatter":{"sidebar_label":"printFileSize"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/performance/print-file-size.mdx","_relativePath":"zh/configure/app/performance/print-file-size.mdx"},{"id":437,"title":"performance.profile","routePath":"/configure/app/performance/profile","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":155}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.profile。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否捕获每个模块的耗时信息，对应 webpack 的 profile 配置。\n\n\n示例#\n\nexport default {\n  performance: {\n    profile: true,\n  },\n};\n\n\n开启后，Webpack 生成一些有关模块的统计数据的 JSON 文件会将模块构建的耗时信息也包含进去。","frontmatter":{"sidebar_label":"profile"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/performance/profile.mdx","_relativePath":"zh/configure/app/performance/profile.mdx"},{"id":438,"title":"performance.removeConsole","routePath":"/configure/app/performance/remove-console","lang":"zh","toc":[{"text":"移除所有 console","id":"移除所有-console","depth":4,"charIndex":148},{"text":"移除特定的 console","id":"移除特定的-console","depth":4,"charIndex":282}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.removeConsole。\n\n * 类型： boolean | ConsoleType[]\n * 默认值： false\n\n在生产环境构建时，是否自动移除代码中的 console.xx。\n\n移除所有 console#\n\n当 removeConsole 被设置为 true 时，会移除所有类型的 console.xx：\n\nexport default {\n  performance: {\n    removeConsole: true,\n  },\n};\n\n\n移除特定的 console#\n\n你也可以指定仅移除特定类型的 console.xx，比如移除 console.log 和 console.warn：\n\nexport default {\n  performance: {\n    removeConsole: ['log', 'warn'],\n  },\n};\n\n\n目前支持配置以下类型的 console：\n\ntype ConsoleType = 'log' | 'info' | 'warn' | 'error' | 'table' | 'group';\n","frontmatter":{"sidebar_label":"removeConsole"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/performance/remove-console.mdx","_relativePath":"zh/configure/app/performance/remove-console.mdx"},{"id":439,"title":"performance.removeMomentLocale","routePath":"/configure/app/performance/remove-moment-locale","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.removeMomentLocale。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否移除 moment.js 的语言包文件。\n\nmoment.js 默认包含了大量的语言包文件，会导致打包后的包体积增大。\n\n当项目中使用了 moment.js 时，推荐开启此选项，自动排除所有的语言包文件：\n\nexport default {\n  performance: {\n    removeMomentLocale: true,\n  },\n};\n\n\n开启后，可以通过以下方式来加载语言包文件：\n\n\nimport 'moment/locale/zh-cn';\n\nmoment.locale('zh-cn');\n","frontmatter":{"sidebar_label":"removeMomentLocale"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/performance/remove-moment-locale.mdx","_relativePath":"zh/configure/app/performance/remove-moment-locale.mdx"},{"id":440,"title":"plugins (插件)","routePath":"/configure/app/plugins","lang":"zh","toc":[{"text":"注意事项","id":"注意事项","depth":2,"charIndex":83},{"text":"插件类型","id":"插件类型","depth":2,"charIndex":280},{"text":"插件执行顺序","id":"插件执行顺序","depth":2,"charIndex":464},{"text":"示例","id":"示例","depth":2,"charIndex":599},{"text":"使用 npm 上的插件","id":"使用-npm-上的插件","depth":3,"charIndex":623},{"text":"使用本地插件","id":"使用本地插件","depth":3,"charIndex":742},{"text":"插件配置项","id":"插件配置项","depth":3,"charIndex":851}],"domain":"","content":"#\n\n * 类型： CliPlugin[]\n * 默认值： []\n\n用于配置自定义的 Modern.js 框架插件。\n\n自定义插件的编写方式请参考 如何编写插件。\n\n\n注意事项#\n\n该选项用于配置框架插件，如果你需要配置其他类型的插件，请选择对应的配置方式：\n\n * 配置 Modern.js Builder 插件，请使用 builderPlugins 配置项。\n * 配置 webpack 插件，请使用 tools.webpack 或 tools.webpackChain 配置项。\n * 配置 Babel 插件，请使用 tools.babel 配置项。\n\n\n插件类型#\n\nModern.js 中内置了三种不同的框架插件：\n\n * CLI 插件，适用于本地开发、编译构建阶段，可以在命令行和编译阶段扩展各种能力。\n * Server 插件，适用于服务端。\n * Runtime 插件，适用于前端运行时。\n\n目前 Modern.js 开放了自定义 CLI 插件的能力，Server 插件和 Runtime 插件会在后续开放。\n\n\n插件执行顺序#\n\n默认情况下，自定义插件会按照 plugins 数组的顺序依次执行，Modern.js 内置插件的执行时机早于自定义插件。\n\n当插件内部使用了控制顺序的相关字段，比如 pre、post 时，会基于声明的字段对执行顺序进行调整，详见 插件之间的关系。\n\n\n示例#\n\n下面是 CLI 插件的使用示例。\n\n\n使用 npm 上的插件#\n\n使用 npm 上的插件，需要通过包管理器安装插件，并通过 import 引入。\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n\n使用本地插件#\n\n使用本地代码仓库中的插件，直接通过相对路径 import 引入即可。\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n\n插件配置项#\n\n如果插件提供了一些自定义的配置项，可以通过插件函数的参数传入配置。\n\n\n\nexport default defineConfig({\n  plugins: [\n    myPlugin({\n      foo: 1,\n      bar: 2,\n    }),\n  ],\n});\n","frontmatter":{"title":"plugins (插件)","sidebar_position":9},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/plugins.mdx","_relativePath":"zh/configure/app/plugins.mdx"},{"id":441,"title":"总览","routePath":"/configure/app/runtime/intro","lang":"zh","toc":[{"text":"配置方式","id":"配置方式","depth":2,"charIndex":25},{"text":"runtime","id":"runtime","depth":3,"charIndex":33},{"text":"基本用法","id":"基本用法","depth":4,"charIndex":75},{"text":"运行时配置","id":"运行时配置","depth":4,"charIndex":197},{"text":"runtimeByEntries","id":"runtimebyentries","depth":3,"charIndex":502},{"text":"说明","id":"说明","depth":4,"charIndex":549}],"domain":"","content":"#\n\n此节将介绍 Runtime 插件的配置。\n\n\n配置方式#\n\n\nruntime#\n\n * 类型： Object\n\nruntime 配置方式如下：\n\n基本用法#\n\n在 modern.config.ts 中配置\n\n\n\nexport default defineConfig({\n  runtime: {\n    state: true,\n    router: true,\n  },\n});\n\n\n运行时配置#\n\n通过 defineConfig API 配置：\n\nINFO\n\n当 runtime 配置中存在函数时，只能使用该方式进行配置。\n\nINFO\n\n使用运行时配置，可以解决 Runtime 插件配置需要在运行时才能获取到具体内容问题。\n\nRuntime 插件运行时配置和直接在 modern.config.ts 中的配置默认会进行合并，且运行时配置优先级更高。\n\nWARNING\n\ndefineConfig 中只能定义 Runtime 插件的具体配置内容，确认是否开启插件还需要通过 package.json 中的 modernConfig\n或者 modern.config.ts 中的配置决定。\n\n\nruntimeByEntries#\n\n * 类型： Object\n * **默认值：**无\n\n说明#\n\n按入口添加 runtime 配置，选项属性同 runtime 一致，指定值会和 runtime 属性内容做替换合并操作。\n\n\n\nexport default defineConfig({\n  runtime: {\n    state: false,\n  },\n  runtimeByEntries: {\n    entry1: {\n      state: true, // { state: true }\n    },\n    entry2: {\n      // { state: false, router: true }\n      router: true,\n    },\n  },\n});\n","frontmatter":{"sidebar_label":"总览","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/runtime/intro.mdx","_relativePath":"zh/configure/app/runtime/intro.mdx"},{"id":442,"title":"runtime.masterApp","routePath":"/configure/app/runtime/master-app","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":56},{"text":"manifest","id":"manifest","depth":2,"charIndex":436},{"text":"getAppList?","id":"getapplist?","depth":3,"charIndex":501},{"text":"apps","id":"apps","depth":3,"charIndex":586},{"text":"其他配置项","id":"其他配置项","depth":3,"charIndex":784}],"domain":"","content":"#\n\n * 类型： Object\n\nINFO\n\n需要先通过 pnpm run new 启用「微前端」 功能。\n\n\n示例#\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n\nmanifest#\n\ninterface Manifest {\n  getAppList?: () => Array;\n}\n\n\n\ngetAppList?#\n\n通过 getAppList 配置，可以自定义如何获取远程列表数据\n\ntype GetAppList = () => Promise>;\n\n\n\napps#\n\n当 apps 为对象类型的时候，表示子应用模块的信息 Array\n\ninterface AppInfo {\n  name: string;\n  entry: string;\n  activeWhen?: string | ()=> boolean;\n}\n\n\n * name: 子应用的名称。\n * entry: 子应用的入口。\n * activeWhen?: 子应用激活路径。\n\n\n其他配置项#\n\n在 masterApp 配置下，开发者可以透传 Garfish 的配置项。\n\n所有支持的配置项点此查看。","frontmatter":{"sidebar_label":"masterApp"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/runtime/master-app.mdx","_relativePath":"zh/configure/app/runtime/master-app.mdx"},{"id":443,"title":"runtime.router","routePath":"/configure/app/runtime/router","lang":"zh","toc":[{"text":"basename","id":"basename","depth":2,"charIndex":134},{"text":"supportHtml5History","id":"supporthtml5history","depth":2,"charIndex":213}],"domain":"","content":"#\n\n * 类型： boolean | Object\n * 默认值： false\n\n开启 router 之后，支持使用 Modern.js 默认提供的约定式路由进行路由管理。Modern.js 的路由模块基于 React Router 6\n实现。\n\n具体配置如下：\n\n\nbasename#\n\n * 类型： string\n * 默认值： /\n\n设置客户端路由的 basename，通常用于应用需要部署在域名非根路径下的场景。\n\n\nsupportHtml5History#\n\n * 类型： boolean\n * 默认值： true\n\n值为 true，使用 BrowserRouter；否则使用 HashRouter。推荐使用 BrowserRouter。\n\nWARNING\n\n当开启 SSR 时，不支持设置 supportHtml5History。","frontmatter":{"sidebar_label":"router"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/runtime/router.mdx","_relativePath":"zh/configure/app/runtime/router.mdx"},{"id":444,"title":"runtime.state","routePath":"/configure/app/runtime/state","lang":"zh","toc":[{"text":"models","id":"models","depth":2,"charIndex":83},{"text":"initialState","id":"initialstate","depth":2,"charIndex":185},{"text":"immer","id":"immer","depth":2,"charIndex":277},{"text":"effects","id":"effects","depth":2,"charIndex":364},{"text":"autoActions","id":"autoactions","depth":2,"charIndex":438},{"text":"devtools","id":"devtools","depth":2,"charIndex":524}],"domain":"","content":"#\n\n * 类型： boolean | object\n * 默认值： false\n\n开启 state 后就可以使用 Model 来做状态管理。\n\n具体配置项如下：\n\n\nmodels#\n\n * 类型： Array\n * 默认值： []\n\n注册提前挂载的 model 对象，这些 model 会在 Reduck store 创建完成后立即执行挂载。一般使用无需提前挂载。\n\n\ninitialState#\n\n * 类型： Object\n * 默认值： {}\n\n用于设置全局 store 的初始状态。一般用于 SSR 在 hydration 阶段初始化数据。\n\n\nimmer#\n\n * 类型： boolean\n * 默认值： true\n\n是否启用以 mutable 更新 state 的方式，默认启用，若想禁用则设置为 false。\n\n\neffects#\n\n * 类型： boolean\n * 默认值： true\n\n是否启用副作用管理特性，默认启用，若想禁用则设置为 false。\n\n\nautoActions#\n\n * 类型： boolean\n * 默认值： true\n\n是否启用自动生成 actions 特性，默认启用，若想禁用则设置为 false。\n\n\ndevtools#\n\n * 类型： boolean | EnhancerOptions\n * 默认值： true\n\n是否启用 devtools，默认启用，同时支持 redux-devtools-extension 的所有参数，若想禁用则设置为 false。","frontmatter":{"sidebar_label":"state"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/runtime/state.mdx","_relativePath":"zh/configure/app/runtime/state.mdx"},{"id":445,"title":"security.checkSyntax","routePath":"/configure/app/security/check-syntax","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":238},{"text":"错误日志","id":"错误日志","depth":3,"charIndex":482},{"text":"解决方法","id":"解决方法","depth":3,"charIndex":802}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 security.checkSyntax。\n\n * 类型：\n\ntype CheckSyntax =\n  | boolean\n  | {\n      targets: string[];\n      exclude?: RegExp | Array;\n    };\n\n\n * 默认值： false\n\n分析构建产物中是否存在当前浏览器范围下不兼容的高级语法。如果存在，会将详细信息打印在终端。\n\n\n示例#\n\nexport default {\n  security: {\n    checkSyntax: true,\n    exclude: /node_modules\\/foo/,\n  },\n};\n\n\n如果将 security.checkSyntax 指定为 true 的话，则 targets 会被认定为项目设定的 browserslist，详情请参考\n设置浏览器范围。\n\n开启后将在生产环境下进行检测，当检测到不兼容的高级语法后，会将错误日志打印在终端，并退出当前构建流程。\n\n\n错误日志#\n\n错误日志的格式如下所示，包含代码来源文件、产物位置、错误原因、源代码等信息：\n\nerror   [Syntax Checker] Find some syntax errors after production build:\n\n  ERROR#1:\n  source - /node_modules/foo/index.js:1:0\n  output - /Project/dist/static/js/main.3f7a4d7e.js:2:39400\n  reason - The keyword 'const' is reserved (2:39400)\n  code   - const foo = 'bar';\n\n\n\n解决方法#\n\n当检测到语法错误后，你可以通过以下方式来处理：\n\n * 如果你希望降级该语法，以保证代码具备良好的兼容性，可以通过 source.include 配置来编译相应的模块。\n * 如果你不希望降级该语法，可以调整项目的 browserslist 范围，调整至与该语法相匹配的范围。\n * 如果你不希望对某些产物进行语法检查，可用 checkSyntax.exclude 配置排除要检查的文件。","frontmatter":{"sidebar_label":"checkSyntax"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/security/check-syntax.mdx","_relativePath":"zh/configure/app/security/check-syntax.mdx"},{"id":446,"title":"security.nonce","routePath":"/configure/app/security/nonce","lang":"zh","toc":[{"text":"nonce 介绍","id":"nonce-介绍","depth":4,"charIndex":178},{"text":"示例","id":"示例","depth":3,"charIndex":-1}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 security.nonce。\n\n * 类型：\n\ntype Nonce = string;\n\n\n * 默认值： undefined\n\n为 HTML 所引入的脚本资源添加随机属性值 nonce，使浏览器在解析到带有匹配 nonce 值的内联脚本时，能判断该脚本是否能执行。\n\nnonce 介绍#\n\nnonce 机制在 Content Security Policy（CSP，内容安全策略）中起到关键作用，用于提升网页安全性。其允许开发者在 CSP 中为内联","frontmatter":{"sidebar_label":"nonce"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/security/nonce.mdx","_relativePath":"zh/configure/app/security/nonce.mdx"},{"id":447,"title":"security.sri","routePath":"/configure/app/security/sri","lang":"zh","toc":[{"text":"SRI 介绍","id":"sri-介绍","depth":4,"charIndex":384},{"text":"示例","id":"示例","depth":3,"charIndex":621}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 security.sri。\n\n * 类型：\n\ntype SRIOptions =\n  | {\n      hashFuncNames?: string[];\n      enabled?: 'auto' | boolean;\n      hashLoading?: 'eager' | 'lazy';\n    }\n  | boolean;\n\n\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n为 HTML 所引入的子资源添加完整性属性 —— integrity，使浏览器能够验证引入资源的完整性，以此防止下载的资源被篡改。\n\n启动该选项后会将 webpack 的 output.crossOriginLoading 配置项设置为 anonymous。\n\nSRI 介绍#\n\n子资源完整性 Subresource Integrity（SRI）是专门用来校验资源的一种方案，它读取资源标签中的 integrity\n属性，将其中的信息摘要值，和资源实际的信息摘要值进行对比，如果发现无法匹配，那么浏览器就会拒绝执行资源。\n\n对于 script 标签来说，结果为拒绝执行其中的代码；对于 CSS link 来说，结果为不加载其中的样式。\n\n关于 SRI 的更多内容，可以查看 Subresource Integrity - MDN。\n\n\n示例#\n\n默认情况下，不会开启 SRI，当开启之后它的默认配置如下：\n\n{\n  hashFuncNames: ['sha384'];\n  enabled: \"auto\",\n  hashLoading: \"eager\",\n}\n\n\n你可以按照你自己的需求自定义配置项:\n\nexport default {\n  security: {\n    sri: {\n      hashFuncNames: ['sha-256'],\n      enabled: true,\n      hashLoading: 'lazy',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"sri"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/security/sri.mdx","_relativePath":"zh/configure/app/security/sri.mdx"},{"id":448,"title":"server.baseUrl","routePath":"/configure/app/server/base-url","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： string | string[]\n * 默认值： undefined\n\n统一设置服务端路由前缀（常用于多个应用共享同一域名的情况，区分流量)。\n\nexport default defineConfig({\n  server: {\n    // 所有生成的路由前面都会自动加上前缀 `/base`\n    // 生成的服务端路由文件路径：dist/route.json\n    baseUrl: '/base'\n\n    // 多 baseUrl\n    baseUrl: ['/base-new', '/base-old']\n  }\n})\n\n\ndev 之后可以看到路由访问会加上对应前缀:\n\nApp running at:\n\n  > Local:    http://localhost:8080/base/\n  > Network:  http://192.168.0.1:8080/base/\n","frontmatter":{"sidebar_label":"baseUrl"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/server/base-url.mdx","_relativePath":"zh/configure/app/server/base-url.mdx"},{"id":449,"title":"server.enableFrameworkExt","routePath":"/configure/app/server/enable-framework-ext","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":221}],"domain":"","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n默认情况下，开启自定义 Web Server 功能后，Middleware 会使用 Modern.js 本身的语法。\n\n开启 server.enableFrameworkExt 可以使用其他框架扩展的语法。\n\nexport default defineConfig({\n  server: {\n    enableFrameworkExt: true,\n  },\n});\n\n\n\n示例#\n\n默认的使用方式：\n\n\n\nexport const middleware: Middleware = (ctx, next) => {\n  console.log(ctx.request.url);\n  next();\n};\n\n\n开启后，Middleware 类型将从其他命名空间下导出，并且可以使用框架拓展的语法：\n\n\n\nexport const middleware: SomeType = (...args) => {\n  console.log(args[0].url);\n  next();\n};\n\n\nNOTE\n\n上述代码为伪代码，具体使用方式需要参考对应的框架拓展。","frontmatter":{"sidebar_label":"enableFrameworkExt"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/server/enable-framework-ext.mdx","_relativePath":"zh/configure/app/server/enable-framework-ext.mdx"},{"id":450,"title":"server.port","routePath":"/configure/app/server/port","lang":"zh","toc":[{"text":"与 dev.port 的区别","id":"与-devport-的区别","depth":3,"charIndex":198}],"domain":"","content":"#\n\n * 类型： number\n * 默认值： 8080\n\nModern.js 在执行 dev, start 和 serve 命令时，会以 8080\n为默认端口启动，并会在端口被占用时自动递增端口号。你可以通过该配置来修改 Server 启动的端口号：\n\nexport default defineConfig({\n  server: {\n    port: 3000,\n  },\n});\n\n\n\n与 dev.port 的区别#\n\n大多数情况下，我们推荐使用 server.port 而不是 dev.port 来设置端口号，他们之间的区别如下：\n\n * dev.port 仅在开发环境下生效，server.port 在开发环境和生产环境下均能生效。\n * 在开发环境下，dev.port 的优先级高于 server.port。\n\n当你同时设置 dev.port 和 server.port 时，dev.port 会在开发环境下生效，server.port\n会在生产环境下生效。比如以下例子，在开发环境下监听的端口号为 3001，在生产环境下监听的端口号为 3002。\n\nexport default defineConfig({\n  dev: {\n    port: 3001,\n  },\n  server: {\n    port: 3002,\n  },\n});\n","frontmatter":{"sidebar_label":"port"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/server/port.mdx","_relativePath":"zh/configure/app/server/port.mdx"},{"id":451,"title":"server.publicRoutes","routePath":"/configure/app/server/public-routes","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： Object\n * 默认值： 根据文件约定自动生成的服务端路由规则，每个文件生成一条路由规则。\n\n该配置选项只作用于服务端路由，可以自定义 config/public/ 下资源的访问路由。\n\n对象的 key 为 config/public/ 的相对文件路径（不使用 ./）, 值可以是 string。\n\nexport default defineConfig({\n  server: {\n    publicRoutes: {\n      // 设置一个长路由\n      'index.json': '/user-config/card-info/extra/help.json',\n\n      // 设置一个不带后缀的路由\n      'robot.txt': '/app/authentication',\n    },\n  },\n});\n","frontmatter":{"sidebar_label":"publicRoutes"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/server/public-routes.mdx","_relativePath":"zh/configure/app/server/public-routes.mdx"},{"id":452,"title":"server.routes","routePath":"/configure/app/server/routes","lang":"zh","toc":[{"text":"自定义访问路由","id":"自定义访问路由","depth":2,"charIndex":102},{"text":"自定义响应头","id":"自定义响应头","depth":2,"charIndex":931}],"domain":"","content":"#\n\n * 类型： Object\n * 默认值： 根据文件约定自动生成的服务端路由规则，每个入口生成一条路由规则，入口名称等于路由路径。\n\n该配置选项只作用于服务端路由，可以自定义应用入口的访问路由。\n\n\n自定义访问路由#\n\n对象的 key 为当前应用的入口名, 值可以是 string | Array。\n\n当值类型为 string 时，当前值即表示访问该入口的路由名称。\n\nexport default defineConfig({\n  server: {\n    routes: {\n      // 默认路由为 /entryName1，自定义后为 /p/test1\n      entryName1: '/p/test1'\n      // 支持动态服务端路由配置\n      entryName2: '/detail/:id'\n    }\n  }\n});\n\n\n也可以通过 Array 为入口设置多个访问路由:\n\nexport default defineConfig({\n  server: {\n    routes: {\n      'page-a': [`/a`, '/b'],\n    },\n  },\n});\n\n\n此时，通过 /a、/b 两个路由都可以访问到 page-a 入口。\n\n执行 dev 命令后，可以在 dist/route.json 中查看入口 page-a 存在两条路由记录:\n\n{\n  \"routes\": [\n    {\n      \"urlPath\": \"/a\",\n      \"entryName\": \"page-a\",\n      \"entryPath\": \"html/page-a/index.html\",\n      \"isSPA\": true,\n      \"isSSR\": false\n    },\n    {\n      \"urlPath\": \"/b\",\n      \"entryName\": \"page-a\",\n      \"entryPath\": \"html/page-a/index.html\",\n      \"isSPA\": true,\n      \"isSSR\": false\n    }\n  ]\n}\n\n\n\n自定义响应头#\n\n可以通过配置入口的 resHeaders 设置响应头：\n\nexport default defineConfig({\n  server: {\n    routes: {\n      'page-a': {\n        route: ['/a', '/b'],\n        resHeaders: {\n          'x-modern-test': '1',\n        },\n      },\n    },\n  },\n});\n\n\nNOTE\n\n这一配置在生产环境与开发环境都生效，可以根据 NODE_ENV 区分环境设置不同的响应头。但如果你只需要在开发环境设置响应头，推荐使用\ntools.devServer.headers。","frontmatter":{"sidebar_label":"routes"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/server/routes.mdx","_relativePath":"zh/configure/app/server/routes.mdx"},{"id":453,"title":"server.ssrByEntries","routePath":"/configure/app/server/ssr-by-entries","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： Object\n * 默认值： undefined\n\n按入口设置 SSR 选项，选项内的属性同 ssr，指定值会和 SSR 属性内容做替换合并操作，例如：\n\nINFO\n\n「 入口名 」默认为目录名，少数情况下通过 source.entries 自定义入口时，入口名为 source.entries 对象的 key。\n\nexport default defineConfig({\n  server: {\n    ssr: true,\n    ssrByEntries: {\n      // page-a 不启用 SSR\n      'page-a': false,\n    },\n  },\n});\n\n\n如上配置，项目整体启用了 SSR, 但是针对入口 page-a 关闭了 SSR 渲染能力。","frontmatter":{"sidebar_label":"ssrByEntries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/server/ssr-by-entries.mdx","_relativePath":"zh/configure/app/server/ssr-by-entries.mdx"},{"id":454,"title":"server.ssr","routePath":"/configure/app/server/ssr","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":57},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":186}],"domain":"","content":"#\n\n * 类型： boolean | Object\n * 默认值： false\n\nSSR 开关以及相关设置。\n\n\nBoolean 类型#\n\n当值类型为 boolean 时，表示是否开启 SSR 部署模式，默认 false 不开启。\n\nexport default defineConfig({\n  server: {\n    ssr: true,\n  },\n});\n\n\n\nObject 类型#\n\n当值类型为 Object 时，可以配置如下属性：\n\n * mode：string = 'string'，默认为使用 renderToString 渲染。配置为 stream 开启流式渲染。\n\n * forceCSR：boolean = false，默认关闭强制 CSR 渲染。配置为 true 后，在页面访问时添加 ?csr=true 即可强制\n   CSR。\n\n * inlineScript：boolean = true，默认情况下，SSR 的数据会以内联脚本的方式注入到 HTML 中，并且直接赋值给全局变量。配置为\n   false 后，会下发 JSON，而不是赋值给全局变量。\n\nexport default defineConfig({\n  server: {\n    forceCSR: true,\n    mode: 'stream',\n    inlineScript: false,\n  },\n});\n","frontmatter":{"sidebar_label":"ssr"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/server/ssr.mdx","_relativePath":"zh/configure/app/server/ssr.mdx"},{"id":455,"title":"source.alias","routePath":"/configure/app/source/alias","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":4,"charIndex":266},{"text":"Function 类型","id":"function-类型","depth":4,"charIndex":490}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.alias。\n\n * 类型： Record | Function\n * 默认值： undefined\n\n设置文件引用的别名，对应 webpack 的 resolve.alias 配置。\n\nTIP\n\n对于 TypeScript 项目，只需要在 tsconfig.json 中配置 compilerOptions.paths 即可，Builder 会自动识别\ntsconfig.json 里的别名，因此不需要额外配置 alias 字段。\n\nObject 类型#\n\nalias 的值可以定义为 Object 类型，其中的相对路径会自动被 Builder 转换为绝对路径。\n\nexport default {\n  source: {\n    alias: {\n      '@common': './src/common',\n    },\n  },\n};\n\n\n以上配置完成后，如果在代码中引用 @common/Foo.tsx, 则会映射到 /src/common/Foo.tsx 路径上。\n\nFunction 类型#\n\nalias 的值定义为函数时，可以接受预设的 alias 对象，并对其进行修改。\n\nexport default {\n  source: {\n    alias: alias => {\n      alias['@common'] = './src/common';\n    },\n  },\n};\n\n\n也可以在函数中返回一个新对象作为最终结果，新对象会覆盖预设的 alias 对象。\n\nexport default {\n  source: {\n    alias: alias => {\n      return {\n        '@common': './src/common',\n      };\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"alias"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/alias.mdx","_relativePath":"zh/configure/app/source/alias.mdx"},{"id":456,"title":"source.compileJsDataURI","routePath":"/configure/app/source/compile-js-data-uri","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":285}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.compileJsDataURI。\n\n * 类型： boolean\n * 默认值： true\n\n该选项用于控制是否编译 data URI 中的 JavaScript 代码。\n\n默认情况下，Builder 会使用 Babel 或 SWC 对 data URI 中的代码进行编译。比如以下代码：\n\n\n\nimport 'data:text/javascript;charset=utf-8;base64,Y29uc29sZS5sb2coJ2lubGluZSAxJyk7';\n\n\n\n示例#\n\n添加以下配置来关闭：\n\nexport default {\n  source: {\n    compileJsDataURI: false,\n  },\n};\n","frontmatter":{"sidebar_label":"compileJsDataURI"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/compile-js-data-uri.mdx","_relativePath":"zh/configure/app/source/compile-js-data-uri.mdx"},{"id":457,"title":"source.configDir","routePath":"/configure/app/source/config-dir","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： string\n * 默认值： ./config\n\nModern.js 支持在 ./config 文件夹下放置一些文件自定义 HTML 模板、图标、静态资源等，具体可参考文件约定。\n\n通过该选项可以自定义配置文件的目录。\n\n例如，将资源文件目录调整为 resources 目录：\n\n\n\nexport default defineConfig({\n  source: {\n    configDir: './resources',\n  },\n});\n","frontmatter":{"sidebar_label":"configDir"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/config-dir.mdx","_relativePath":"zh/configure/app/source/config-dir.mdx"},{"id":458,"title":"source.define","routePath":"/configure/app/source/define","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":410}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.define。\n\n * 类型： Record\n * 默认值： {}\n\n构建时将代码中的变量替换成其它值或者表达式，可以用于在代码逻辑中区分开发环境与生产环境等场景。\n\n传入的配置对象的键名是需要替换变量的名称，或者是用 . 连接的多个标识符，配置项的值则根据类型进行不同的处理：\n\n * 字符串会被当作代码片段。\n * 包括函数在内的其他类型会被转换成字符串。\n * 嵌套对象的父子键名之间会用 . 连接作为需要替换的变量名。\n * 以 typeof 开头的键名会用来替换 typeof 调用。\n\n更多细节参考 https://webpack.js.org/plugins/define-plugin/。\n\nTIP\n\n在使用 Rspack 作为打包工具时，支持的类型可参考 Rspack.builtins.define\n\n\n示例#\n\nexport default {\n  source: {\n    define: {\n      PRODUCTION: JSON.stringify(true),\n      VERSION: JSON.stringify('5fa3b9'),\n      BROWSER_SUPPORTS_HTML5: true,\n      TWO: '1 + 1',\n      'typeof window': JSON.stringify('object'),\n      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n      'import.meta': { test: undefined },\n    },\n  },\n};\n\n\n表达式会被替换为对应的代码段：\n\nconst foo = TWO;\n\n// ⬇️ Turn into being...\nconst foo = 1 + 1;\n","frontmatter":{"sidebar_label":"define"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/define.mdx","_relativePath":"zh/configure/app/source/define.mdx"},{"id":459,"title":"source.designSystem","routePath":"/configure/app/source/design-system","lang":"zh","toc":[{"text":"结构","id":"结构","depth":3,"charIndex":295},{"text":"Screens","id":"screens","depth":4,"charIndex":362},{"text":"Colors","id":"colors","depth":4,"charIndex":3562},{"text":"Spacing","id":"spacing","depth":4,"charIndex":3893},{"text":"Core plugins","id":"core-plugins","depth":4,"charIndex":4388},{"text":"自定义默认配置","id":"自定义默认配置","depth":3,"charIndex":5009},{"text":"覆盖默认配置","id":"覆盖默认配置","depth":4,"charIndex":5069},{"text":"扩展默认配置","id":"扩展默认配置","depth":4,"charIndex":5481},{"text":"引用其他值","id":"引用其他值","depth":4,"charIndex":6123},{"text":"禁用整个核心插件","id":"禁用整个核心插件","depth":4,"charIndex":6885},{"text":"添加自己的 key","id":"添加自己的-key","depth":4,"charIndex":7265},{"text":"配置引用","id":"配置引用","depth":3,"charIndex":8216},{"text":"额外的配置","id":"额外的配置","depth":3,"charIndex":8421},{"text":"source.designSystem.supportStyledComponents","id":"sourcedesignsystemsupportstyledcomponents","depth":4,"charIndex":8484}],"domain":"","content":"#\n\n * 类型： Object\n * 默认值： 见下方配置详情。\n\n注意\n\n需要先通过 pnpm run new 启用 Tailwind CSS 功能。\n\n提示\n\n更多关于 TailwindCSS 配置可查看这里。\n\ndesignSystem 用于定义项目的调色板、排版比例（Typographic Scales 或者 Type\nScale）、字体列表、断点、边框圆角值等等。因为 Modern.js 借用了 Tailwind Theme 的设计方式，并且内部也集成了 Tailwind\nCSS，所以 designSystem 使用方式与 Tailwind CSS Theme 相同。\n\n\n结构#\n\ndesignSystem 对象包含 screens、colors 和 spacing 的属性，以及每个可自定义核心插件。\n\nScreens#\n\n使用 screens 可以自定义项目中的响应断点：\n\nconst designSystem = {\n  screens: {\n    sm: '640px',\n    md: '768px',\n    lg: '1024px',\n    xl: '1280px',\n  },\n};\n\n\n其中 screens 对象里的属性名是屏幕名称（用作 Tailwind CSS 生成的自适应实用程序变体的前缀，例如\nmd:text-center），值是该断点应在其开始的 min-width。\n\n默认断点受常见设备分辨率的启发：\n\nconst designSystem = {\n  screens: {\n    sm: '640px',\n    // => @media (min-width: 640px) { ... }\n\n    md: '768px',\n    // => @media (min-width: 768px) { ... }\n\n    lg: '1024px',\n    // => @media (min-width: 1024px) { ... }\n\n    xl: '1280px',\n    // => @media (min-width: 1280px) { ... }\n  },\n};\n\n\n你可以在你的项目中使用任意你喜欢的名称作为断点的属性：\n\nconst designSystem = {\n  screens: {\n    tablet: '640px',\n    // => @media (min-width: 640px) { ... }\n\n    laptop: '1024px',\n    // => @media (min-width: 1024px) { ... }\n\n    desktop: '1280px',\n    // => @media (min-width: 1280px) { ... }\n  },\n};\n\n\n这些屏幕名称反映在 utilities 中，因此 text-center 现在是这样的：\n\n.text-center {\n  text-align: center;\n}\n\n@media (min-width: 640px) {\n  .tablet\\:text-center {\n    text-align: center;\n  }\n}\n\n@media (min-width: 1024px) {\n  .laptop\\:text-center {\n    text-align: center;\n  }\n}\n\n@media (min-width: 1280px) {\n  .desktop\\:text-center {\n    text-align: center;\n  }\n}\n\n\nMax-width 断点#\n\n如果要使用 max-width 断点而不是 min-width，可以将屏幕指定为具有 max 属性的对象：\n\nconst designSystem = {\n  screens: {\n    xl: { max: '1279px' },\n    // => @media (max-width: 1279px) { ... }\n\n    lg: { max: '1023px' },\n    // => @media (max-width: 1023px) { ... }\n\n    md: { max: '767px' },\n    // => @media (max-width: 767px) { ... }\n\n    sm: { max: '639px' },\n    // => @media (max-width: 639px) { ... }\n  },\n};\n\n\n如有必要，以创建带有 min-width 和 max-width 定义的断点，例如：\n\nconst designSystem = {\n  screens: {\n    sm: { min: '640px', max: '767px' },\n    md: { min: '768px', max: '1023px' },\n    lg: { min: '1024px', max: '1279px' },\n    xl: { min: '1280px' },\n  },\n};\n\n\n多个范围的断点#\n\n有时，将单个断点定义应用于多个范围会很有用。\n\n例如，假设您有一个 sidebar，并且希望断点基于内容区域宽度而不是整个视口。您可以模拟这种情况，当 sidebar\n可见并缩小内容区域时，断点的样式使用较小的断点样式：\n\nconst designSystem = {\n  screens: {\n    sm: '500px',\n    md: [\n      // Sidebar appears at 768px, so revert to `sm:` styles between 768px\n      // and 868px, after which the main content area is wide enough again to\n      // apply the `md:` styles.\n      { min: '668px', max: '767px' },\n      { min: '868px' },\n    ],\n    lg: '1100px',\n    xl: '1400px',\n  },\n};\n\n\n自定义媒体查询#\n\n如果需要为断点提供完全自定义的媒体查询，则可以使用带有 raw 属性的对象：\n\nconst designSystem = {\n  extend: {\n    screens: {\n      portrait: { raw: '(orientation: portrait)' },\n      // => @media (orientation: portrait) { ... }\n    },\n  },\n};\n\n\nPrint 样式#\n\n如果需要为打印应用不同的样式，则 raw 选项可能特别有用。\n\n需要做的就是在 designSystem.extend.screens 下添加一个 print：\n\nconst designSystem = {\n  extend: {\n    screens: {\n      print: { raw: 'print' },\n      // => @media print { ... }\n    },\n  },\n};\n\n\n然后，可以使用诸如 print:text-black 之类的类来指定仅当某人尝试打印页面时才应用的样式：\n\n\n  {/* ...  */}\n\n\n\nDark Mode#\n\nraw 选项可以用于实现 “暗模式” 屏幕：\n\nconst designSystem = {\n  extend: {\n    screens: {\n      dark: { raw: '(prefers-color-scheme: dark)' },\n      // => @media (prefers-color-scheme: dark) { ... }\n    },\n  },\n};\n\n\n然后，您可以使用 dark: 前缀在暗模式下为元素设置不同的样式：\n\n\n  {/* ...  */}\n\n\n\n请注意，由于这些 screen variants 是在 Tailwind CSS 中实现的，因此无法使用这种方法将断点与暗模式结合使用 ，例如\nmd:dark:text-gray-300 将不起作用。\n\nColors#\n\ncolors 属性可让您自定义项目的全局调色板。\n\nconst designSystem = {\n  colors: {\n    transparent: 'transparent',\n    black: '#000',\n    white: '#fff',\n    gray: {\n      100: '#f7fafc',\n      // ...\n      900: '#1a202c',\n    },\n\n    // ...\n  },\n};\n\n\n默认情况下，这些颜色由 backgroundColor，textColor 和 borderColor 核心插件继承。\n\n想了解更多，可以查看：Customizing Colors。\n\nSpacing#\n\n使用 space 属性，可以自定义项目的全局间距和缩放比例：\n\nconst designSystem = {\n  spacing: {\n    px: '1px',\n    0: '0',\n    1: '0.25rem',\n    2: '0.5rem',\n    3: '0.75rem',\n    4: '1rem',\n    5: '1.25rem',\n    6: '1.5rem',\n    8: '2rem',\n    10: '2.5rem',\n    12: '3rem',\n    16: '4rem',\n    20: '5rem',\n    24: '6rem',\n    32: '8rem',\n    40: '10rem',\n    48: '12rem',\n    56: '14rem',\n    64: '16rem',\n  },\n};\n\n\n默认情况下，这些值由 padding，margin，negativeMargin，width 和 height 核心插件继承。\n\n想要了解更多，看 Customizing Spacing。\n\nCore plugins#\n\n主题部分的其余部分用于配置每个核心插件可用的值。\n\n例如，borderRadius 属性可让您自定义将生成的圆角的 utilities：\n\nconst designSystem = {\n  borderRadius: {\n    none: '0',\n    sm: '.125rem',\n    default: '.25rem',\n    lg: '.5rem',\n    full: '9999px',\n  },\n};\n\n\n**属性名确定所生成类的后缀，值确定实际 CSS 声明的值。**上面的示例 borderRadius 配置将生成以下 CSS 类：\n\n.rounded-none {\n  border-radius: 0;\n}\n.rounded-sm {\n  border-radius: 0.125rem;\n}\n.rounded {\n  border-radius: 0.25rem;\n}\n.rounded-lg {\n  border-radius: 0.5rem;\n}\n.rounded-full {\n  border-radius: 9999px;\n}\n\n\n会注意到，在主题配置中使用 default 属性创建了不带后缀的 rounded 类。这是许多（尽管不是全部）核心插件支持的 Tailwind CSS\n中的通用约定。\n\n要了解有关自定义特定核心插件的更多信息，请访问该插件的文档。\n\n\n自定义默认配置#\n\n开箱即用，您的项目将自动从默认主题配置继承值。如果想自定义默认主题，则根据目标有几种不同的选择。\n\n覆盖默认配置#\n\n要覆盖默认配置中的选项，请在 designSystem 中添加要覆盖的属性：\n\nconst designSystem = {\n  // Replaces all of the default `opacity` values\n  opacity: {\n    0: '0',\n    20: '0.2',\n    40: '0.4',\n    60: '0.6',\n    80: '0.8',\n    100: '1',\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\n这将完全替换默认属性配置，因此在上面的示例中，不会生成默认的 opacity utilities。\n\n您未提供的任何属性都将从默认主题继承，因此在上面的示例中，将保留颜色，间距，边框圆角，背景位置等内容的默认主题配置。\n\n扩展默认配置#\n\n如果您想保留主题选项的默认值，但又要添加新值，请在 designSystem.extend 属性下添加扩展的内容。\n\n例如，如果您想添加一个额外的断点但保留现有的断点，则可以扩展 screens 属性：\n\nconst designSystem = {\n  extend: {\n    // Adds a new breakpoint in addition to the default breakpoints\n    screens: {\n      '2xl': '1440px',\n    },\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\n您当然可以覆盖默认主题的某些部分，并在同一配置中扩展默认主题的其他部分：\n\nconst designSystem = {\n  opacity: {\n    0: '0',\n    20: '0.2',\n    40: '0.4',\n    60: '0.6',\n    80: '0.8',\n    100: '1',\n  },\n  extend: {\n    screens: {\n      '2xl': '1440px',\n    },\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\n引用其他值#\n\n如果需要在配置中引用另一个值，可以通过提供闭包函数而不是静态值来实现。函数将收到 theme() 函数作为参数，您可以使用该函数使用点表示法在配置中查找其他值。\n\n例如，您可以在 fill 配置上通过引用 theme('colors') 为调色板中的每种颜色生成 fill utilities。\n\nconst designSystem = {\n  colors: {\n    // ...\n  },\n  fill: theme => theme('colors'),\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\ntheme()函数尝试从已经完全合并的配置对象中找到您要查找的值，因此它可以引用您自己的自定义设置以及默认主题值。它也可以递归工作，因此只要链末尾有一个静态值，\n它就可以解析您要查找的值。\n\n引用默认配置\n\n如果出于任何原因想要引用默认配置中的值，则可以从 tailwindcss/defaultTheme\n导入它。一个有用的示例是，如果要将添加默认配置提供的字体中某一个字体：\n\nconst defaultTheme = require('tailwindcss/defaultTheme');\n\nconst designSystem = {\n  extend: {\n    fontFamily: {\n      sans: ['Lato', ...defaultTheme.fontFamily.sans],\n    },\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\n禁用整个核心插件#\n\n如果您不想为某个核心插件生成任何类，则最好在 corePlugins 配置中将该插件设置为 false，而不是在配置中为该属性提供一个空对象：\n\n// Don't assign an empty object in your theme configuration\n\nconst designSystem = {\n  opacity: {},\n};\n\n// Do disable the plugin in your corePlugins configuration\nconst designSyttem = {\n  corePlugins: {\n    opacity: false,\n  },\n};\n\n\n最终结果是相同的，但是由于许多核心插件未公开任何配置，因此无论如何只能使用 corePlugins 禁用它们，最好保持一致。\n\n添加自己的 key#\n\n在很多情况下，将自己的属性添加到配置对象可能会很有用。\n\n其中一个示例是添加新属性为多个核心插件之间复用。例如，您可以提取一个 positions对象，backgroundPosition 和\nobjectPosition 插件都可以引用该对象：\n\nconst designSystem = {\n  positions: {\n    bottom: 'bottom',\n    center: 'center',\n    left: 'left',\n    'left-bottom': 'left bottom',\n    'left-top': 'left top',\n    right: 'right',\n    'right-bottom': 'right bottom',\n    'right-top': 'right top',\n    top: 'top',\n  },\n  backgroundPosition: theme => theme('positions'),\n  objectPosition: theme => theme('positions'),\n};\n\n\n另一个示例是在自定义插件中添加新的属性以进行引用。例如，如果您为项目编写了渐变插件，则可以向该插件引用的主题对象添加渐变属性：\n\nconst designSystem = {\n  gradients: theme => ({\n    'blue-green': [theme('colors.blue.500'), theme('colors.green.500')],\n    'purple-blue': [theme('colors.purple.500'), theme('colors.blue.500')],\n    // ...\n  }),\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n  tools: {\n    tailwind: {\n      plugins: [require('./plugins/gradients')],\n    },\n  },\n});\n\n\n\n配置引用#\n\n除了 screens，colors 和 spacing 外，配置对象中的所有属性都映射到 Tailwind CSS\n的核心插件上。由于许多插件负责仅接受静态值集（例如，例如float）的 CSS 属性，因此请注意，并非每个插件在主题对象中都有对应的属性。\n\n所有这些属性也可以在 designSystem.extend 属性下使用，以扩展默认主题。\n\n关于所有属性的作用，可以查看此 链接。\n\n\n额外的配置#\n\n除了与 Tailwind CSS Theme 相同的配置以外，还有 Modern.js 提供的额外的配置。\n\nsource.designSystem.supportStyledComponents#\n\n该配置类型为 boolean，默认为 false。\n\n当该配置值为 true 时，运行时在应用外层提供 styled-components ThemeProvider 组件，并且将通过 designSystem\n生成的 Theme Token 对象注入。","frontmatter":{"sidebar_label":"designSystem"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/design-system.mdx","_relativePath":"zh/configure/app/source/design-system.mdx"},{"id":460,"title":"source.disableDefaultEntries","routePath":"/configure/app/source/disable-default-entries","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n用于关闭基于目录结构来自动识别页面入口的功能。\n\nINFO\n\n默认情况下，Modern.js 会基于目录约定来自动确定页面的入口，具体可参考入口。\n\n设置如下，即可关闭默认的行为：\n\nexport default defineConfig({\n  source: {\n    disableDefaultEntries: true,\n  },\n});\n\n\n关闭默认行为后，你需要使用 source.entries 配置自定义的入口。\n\nWARNING\n\n我们推荐使用 Modern.js 提供的目录规范来组织代码，从而更好地使用框架功能，避免一些冗余的配置。","frontmatter":{"sidebar_label":"disableDefaultEntries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/disable-default-entries.mdx","_relativePath":"zh/configure/app/source/disable-default-entries.mdx"},{"id":461,"title":"source.disableEntryDirs","routePath":"/configure/app/source/disable-entry-dirs","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： string[]\n * 默认值： []\n\nModern.js 默认会根据 src 目录识别应用入口，你可以通过该选项禁止某些目录被识别为应用入口。\n\n例如，当配置与目录结构如下时：\n\nexport default defineConfig({\n  source: {\n    disableEntryDirs: ['./src/one'],\n  },\n});\n\n\n└── src/\n    ├── one/\n    |    └── App.tsx\n    ├── two/\n    |    └── routes/\n    └── env.d.ts\n\n\n在未设置该配置项时，Modern.js 会根据项目目录产出两个 entry:\n\n * one\n * two\n\n当设置该配置项后，src/one 不会作为 entry 目录被识别。\n\n常见的用法是，将 src/common、src/components 目录配置到该选项中，避免这些目录被识别为应用入口。","frontmatter":{"sidebar_label":"disableEntryDirs"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/disable-entry-dirs.mdx","_relativePath":"zh/configure/app/source/disable-entry-dirs.mdx"},{"id":462,"title":"source.enableAsyncEntry","routePath":"/configure/app/source/enable-async-entry","lang":"zh","toc":[{"text":"背景知识","id":"背景知识","depth":2,"charIndex":172},{"text":"示例","id":"示例","depth":2,"charIndex":229}],"domain":"","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n该选项用于 webpack 模块联邦（Module Federation）场景。\n\n开启此选项后，Modern.js 会通过 Dynamic Import 来包裹自动生成的入口文件（Asynchronous\nBoundaries），使页面代码可以消费模块联邦生成的远程模块。\n\n\n背景知识#\n\n如果不了解 webpack 模块联邦，请先阅读 Module Federation 官方文档。\n\n\n示例#\n\n首先，在配置文件中开启此选项：\n\nexport default defineConfig({\n  source: {\n    enableAsyncEntry: true,\n  },\n});\n\n\n然后执行 dev 或 build 命令，可以看到 Modern.js 自动生成的文件变为以下结构：\n\nnode_modules\n  └─ .modern-js\n     └─ main\n        ├─ bootstrap.jsx  # 真正的入口代码\n        ├─ index.js      # 异步入口文件（asynchronous boundary）\n        └─ index.html\n\n\n其中 index.js 的内容如下：\n\nimport('./bootstrap.jsx');\n\n\n此时，就可以在当前页面中消费任意的远程模块了。\n\nINFO\n\nModern.js 未对 webpack 的 ModuleFederationPlugin 进行封装，请通过 tools.webpackChain 自行配置\nModuleFederationPlugin。","frontmatter":{"sidebar_label":"enableAsyncEntry"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/enable-async-entry.mdx","_relativePath":"zh/configure/app/source/enable-async-entry.mdx"},{"id":463,"title":"source.entriesDir","routePath":"/configure/app/source/entries-dir","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： string\n * 默认值： ./src\n\nModern.js 默认会扫描 src 目录来识别页面入口，你可以通过该选项自定义页面入口的识别目录。\n\n例如，当配置与目录结构如下时：\n\nexport default defineConfig({\n  source: {\n    entriesDir: './src/pages',\n  },\n});\n\n\n.\n└── src\n    └── pages\n        ├── a\n        │   └── App.tsx\n        └── b\n            └── App.tsx\n\n\nModern.js 会扫描 ./src/pages 目录，自动生成构建入口 a 和入口 b，结果如下：\n\nconst entry = {\n  a: './src/pages/a/App.tsx',\n  b: './src/pages/b/App.tsx',\n};\n","frontmatter":{"sidebar_label":"entriesDir"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/entries-dir.mdx","_relativePath":"zh/configure/app/source/entries-dir.mdx"},{"id":464,"title":"source.entries","routePath":"/configure/app/source/entries","lang":"zh","toc":[{"text":"String 类型","id":"string-类型","depth":2,"charIndex":283},{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":1008},{"text":"禁用入口文件生成","id":"禁用入口文件生成","depth":3,"charIndex":1404},{"text":"约定式路由","id":"约定式路由","depth":3,"charIndex":1765},{"text":"入口合并规则","id":"入口合并规则","depth":2,"charIndex":2045}],"domain":"","content":"#\n\n * 类型：\n\ntype Entries = Record<\n  string,\n  | string\n  | {\n      entry: string;\n      disableMount?: boolean;\n      customBootstrap?: string;\n    }\n>;\n\n\n * 默认值： 根据当前项目的目录结构计算出的入口对象。\n\n用于配置自定义页面入口。\n\n何时使用\n\n对于大部分场景，Modern.js 根据目录结构自动生成的入口已经可以满足需求，具体可参考入口。\n\n如果你需要自定义页面入口时，可以通过该选项进行设置。\n\n\nString 类型#\n\n当 entries 对象的 value 为 string 类型时，表示入口模块的文件路径:\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      // 指定一个名称为 entry_customize 的新入口\n      entry_customize: './src/home/test/index.ts',\n    },\n    // 禁用默认入口扫描\n    disableDefaultEntries: true,\n  },\n});\n\n\n默认情况下，配置的入口等价于 App.[jt]sx，即指定的入口文件只需要导出应用的根组件。\n\n例如以下目录结构：\n\n.\n├── src\n│   └── entry\n│       ├── chat.tsx\n│       └── home.tsx\n└── package.json\n\n\n上述目录不符合 Modern.js 的目录结构约定，因此，Modern.js 在分析目录结构时，不会得到任何默认入口。\n\n在不想改变目录结构的情况下（如项目迁移），可以通过 source.entries 自定义入口：\n\nexport default defineConfig({\n  source: {\n    entries: {\n      home: './src/entry/home.tsx',\n      chat: './src/entry/chat.tsx',\n    },\n    // 禁用默认入口扫描\n    disableDefaultEntries: true,\n  },\n});\n\n\n\nObject 类型#\n\n当值为 Object 时，可配置如下属性：\n\n * entry：string，入口文件路径。\n * disableMount：boolean = false，关闭 Modern.js 自动生成入口代码的行为。\n * customBootstrap： string = ''，指定自定义 Bootstrap 的文件路径。\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      entry_customize: {\n        // 入口文件路径\n        entry: './src/home/test/index.tsx',\n      },\n    },\n    // 禁用默认入口扫描\n    disableDefaultEntries: true,\n  },\n});\n\n\n\n禁用入口文件生成#\n\n默认情况下，配置的入口等价于 App.[jt]sx，Modern.js 会自动生成一个入口文件来引用你配置的入口。\n\n如果你希望禁用 Modern.js 自动生成入口文件的逻辑，可以将 disableMount 属性设置为 true。\n\nexport default defineConfig({\n  source: {\n    entries: {\n      entry_customize: {\n        entry: './src/home/test/index.tsx',\n        disableMount: true,\n      },\n    },\n    // 禁用默认入口扫描\n    disableDefaultEntries: true,\n  },\n});\n\n\n\n约定式路由#\n\n如果你需要为某个自定义入口启用约定式路由，可以将 entry 设置为目录路径：\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      // 启用约定式路由\n      entry_spa: {\n        // 约定式路由的入口路径必须设置为目录\n        entry: './src/about',\n      },\n    },\n    // 禁用默认入口扫描\n    disableDefaultEntries: true,\n  },\n});\n\n\n\n入口合并规则#\n\n在设置 source.entries 后，如果没有设置 disableDefaultEntries: true，Modern.js\n会将自定义入口与分析目录结构得到的入口合并。\n\n合并规则为：\n\n * 比较自定义入口设置的入口路径和默认入口路径，当入口路径一致时，自定义入口会覆盖默认入口。\n\n例如以下目录结构:\n\n.\n├── src\n│   ├── chat\n│   │   └── App.tsx\n│   └── home\n│       └── index.ts\n└── package.json\n\n\nModern.js 会分析 src/ 目录，得到默认入口 chat 和 home。当用户在 modern.config.ts 文件中配置如下时：\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      index: './src/home/index.ts',\n    },\n  },\n};\n\n\n可以看到自定义入口 index 的路径和默认入口 home 的路径一致，在合并的过程中，index 会覆盖掉 home，最终入口如下：\n\n * chat -> ./src/chat/App.tsx\n * index -> ./src/home/index.ts","frontmatter":{"sidebar_label":"entries"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/entries.mdx","_relativePath":"zh/configure/app/source/entries.mdx"},{"id":465,"title":"source.exclude","routePath":"/configure/app/source/exclude","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.exclude。\n\n * 类型： Array\n * 默认值： []\n * 打包工具： 仅支持 webpack\n\n指定不需要编译的 JavaScript/TypeScript 文件。用法与 webpack 中的 Rule.exclude\n一致，支持传入字符串或正则表达式来匹配模块的路径。\n\nTIP\n\n在使用 Rspack 作为打包工具时，默认所有文件都会经过编译，同时，不支持通过 source.exclude 排除。\n\n比如:\n\n\n\nexport default {\n  source: {\n    exclude: [path.resolve(__dirname, 'src/module-a'), /src\\/module-b/],\n  },\n};\n","frontmatter":{"sidebar_label":"exclude"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/exclude.mdx","_relativePath":"zh/configure/app/source/exclude.mdx"},{"id":466,"title":"source.globalVars","routePath":"/configure/app/source/global-vars","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":372},{"text":"函数用法","id":"函数用法","depth":3,"charIndex":648},{"text":"与 define 的区别","id":"与-define-的区别","depth":3,"charIndex":990},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":1522}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.globalVars。\n\n * 类型： Record | Function\n * 默认值：\n\n// Builder 默认会添加环境变量 `process.env.NODE_ENV`，因此你不需要手动添加它。\nconst defaultGlobalVars = {\n  'process.env.NODE_ENV': process.env.NODE_ENV,\n};\n\n\n用于在构建时将类似 process.env.FOO 的全局变量表达式替换为指定的值，比如：\n\nconsole.log(process.env.NODE_ENV);\n\n// ⬇️ Turn into being...\nconsole.log('development');\n\n\n\n示例#\n\n在下方示例中，会在代码中注入 ENABLE_VCONSOLE 和 APP_CONTEXT 两个环境变量：\n\nexport default {\n  source: {\n    globalVars: {\n      ENABLE_VCONSOLE: true,\n      APP_CONTEXT: { answer: 42 },\n    },\n  },\n};\n\n\n你可以在代码中直接使用它们：\n\nif (ENABLE_VCONSOLE) {\n  // do something\n}\n\nconsole.log(APP_CONTEXT);\n\n\n\n函数用法#\n\n * 类型：\n\ntype GlobalVarsFn = (\n  obj: Record,\n  utils: { env: NodeEnv; target: BuilderTarget },\n) => Record | void;\n\n\n你可以将 source.globalVars 设置为一个函数，从而动态设置一些环境变量的值。\n\n比如，根据当前的构建产物类型进行动态设置：\n\nexport default {\n  source: {\n    globalVars(obj, { target }) {\n      obj['MY_TARGET'] = target === 'node' ? 'server' : 'client';\n    },\n  },\n};\n\n\n\n与 define 的区别#\n\nsource.globalVars 是 source.define 的一个语法糖，它们之间唯一的区别是，source.globalVars 会自动将传入的值进行\nJSON 序列化处理，这使得设置全局变量的值更加方便。注意 globalVars 的每个值都需要是可以被 JSON 序列化的值。\n\nexport default {\n  source: {\n    globalVars: {\n      'process.env.BUILD_VERSION': '0.0.1',\n      'import.meta.foo': { bar: 42 },\n      'import.meta.baz': false,\n    },\n    define: {\n      'process.env.BUILD_VERSION': JSON.stringify('0.0.1'),\n      'import.meta': {\n        foo: JSON.stringify({ bar: 42 }),\n        baz: JSON.stringify(false),\n      },\n    },\n  },\n};\n\n\n\n注意事项#\n\nsource.globalVars 是通过字符串替换的形式来注入环境变量的，因此它无法对「解构赋值」等动态写法生效。\n\n在使用解构赋值时，Builder 将无法判断变量 NODE_ENV 是否与要替换的表达式 process.env.NODE_ENV\n存在关联，因此以下使用方式是无效的：\n\nconst { NODE_ENV } = process.env;\nconsole.log(NODE_ENV);\n// ❌ Won't get a string.\n","frontmatter":{"sidebar_label":"globalVars"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/global-vars.mdx","_relativePath":"zh/configure/app/source/global-vars.mdx"},{"id":467,"title":"source.include","routePath":"/configure/app/source/include","lang":"zh","toc":[{"text":"编译 npm 包","id":"编译-npm-包","depth":3,"charIndex":506},{"text":"编译 npm 包的子依赖","id":"编译-npm-包的子依赖","depth":3,"charIndex":956},{"text":"编译 Monorepo 中的其他库","id":"编译-monorepo-中的其他库","depth":3,"charIndex":1252},{"text":"编译 CommonJS 模块","id":"编译-commonjs-模块","depth":3,"charIndex":1661},{"text":"匹配 Symlink","id":"匹配-symlink","depth":3,"charIndex":2011},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":2255}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.include。\n\n * 类型： Array\n * 默认值： []\n * 打包工具： 仅支持 webpack\n\n出于编译性能的考虑，默认情况下，Builder 不会编译 node_modules 下的 JavaScript/TypeScript\n文件，也不会编译当前工程目录外部的 JavaScript/TypeScript 文件。\n\n通过 source.include 配置项，可以指定需要 Builder 额外进行编译的目录或模块。source.include 的用法与 webpack 中的\nRule.include 一致，支持传入字符串或正则表达式来匹配模块的路径。\n\n比如:\n\n\n\nexport default {\n  source: {\n    include: [path.resolve(__dirname, '../other-dir')],\n  },\n};\n\n\nTIP\n\n在使用 Rspack 作为打包工具时，默认所有文件都会经过编译，同时，不支持通过 source.exclude 排除。\n\n\n编译 npm 包#\n\n比较典型的使用场景是编译 node_modules 下的 npm 包，因为某些第三方依赖存在 ES6+\n的语法，这可能导致在低版本浏览器上无法运行，你可以通过该选项指定需要编译的依赖，从而解决此类问题。\n\n以 query-string 为例，你可以做如下的配置：\n\n\n\nexport default {\n  source: {\n    include: [\n      // 方法一:\n      // 先通过 require.resolve 来获取模块的路径\n      // 再通过 path.dirname 来指向对应的目录\n      path.dirname(require.resolve('query-string')),\n      // 方法二:\n      // 通过正则表达式进行匹配\n      // 所有包含 `/query-string/` 的路径都会被匹配到\n      /\\/query-string\\//,\n    ],\n  },\n};\n\n\n\n编译 npm 包的子依赖#\n\n当你通过 source.include 编译一个 npm 包时，Builder 默认只会编译匹配到的模块，不会编译对应模块的子依赖。\n\n以 query-string 为例，它依赖的 decode-uri-component 包中同样存在 ES6+ 代码，因此需要将\ndecode-uri-component 也加入到 source.include 中：\n\nexport default {\n  source: {\n    include: [/\\/query-string\\//, /\\/decode-uri-component\\//],\n  },\n};\n\n\n\n编译 Monorepo 中的其他库#\n\n在 Monorepo 中进行开发时，如果需要引用 Monorepo 中其他库的源代码，也可以直接在 source.include 进行配置:\n\n\n\nexport default {\n  source: {\n    include: [\n      // 方法一:\n      // 编译 Monorepo 的 package 目录下的所有文件\n      path.resolve(__dirname, '../../packages'),\n\n      // 方法二:\n      // 编译 Monorepo 的 package 目录里某个包的源代码\n      // 这种写法匹配的范围更加精准，对整体编译性能的影响更小\n      path.resolve(__dirname, '../../packages/xxx/src'),\n    ],\n  },\n};\n\n\n\n编译 CommonJS 模块#\n\nBabel 默认无法编译 CommonJS 模块，如果你编译了一个 CommonJS 模块，可能会出现 exports is not defined\n的运行时报错信息。\n\n当你需要使用 source.include 来编译 CommonJS 模块时，可以将 Babel 的 sourceType 配置设置为 unambiguous：\n\nexport default {\n  tools: {\n    babel(config) {\n      config.sourceType = 'unambiguous';\n    },\n  },\n};\n\n\n将 sourceType 设置为 unambiguous 可能会产生一些其他影响，请参考 Babel 官方文档。\n\n\n匹配 Symlink#\n\n如果你匹配的模块是通过 symlink 链接到当前项目中的，那么需要匹配这个模块的真实路径，而不是 symlink 后的路径。\n\n比如，你将 Monorepo 中的 packages/foo 路径 symlink 到当前项目的 node_modules/foo 路径下，则需要去匹配\npackages/foo 路径，而不是 node_modules/foo 路径。\n\n该行为可以通过 webpack 的 resolve.symlinks 配置项来进行控制。\n\n\n注意事项#\n\n注意，source.include 不应该被用于编译整个 node_modules 目录，比如下面的写法是错误的：\n\nexport default {\n  source: {\n    include: [/\\/node_modules\\//],\n  },\n};\n\n\n如果你对整个 node_modules 进行编译，不仅会使编译时间大幅度增加，并且可能会产生不可预期的错误。因为 node_modules 中的大部分 npm\n包发布的已经是编译后的产物，通常没必要经过二次编译。此外，core-js 等 npm 包被编译后可能会出现异常。","frontmatter":{"sidebar_label":"include"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/include.mdx","_relativePath":"zh/configure/app/source/include.mdx"},{"id":468,"title":"source.moduleScopes","routePath":"/configure/app/source/module-scopes","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":187},{"text":"Array 类型","id":"array-类型","depth":4,"charIndex":472},{"text":"Function 类型","id":"function-类型","depth":4,"charIndex":628}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.moduleScopes。\n\n * 类型： Array | Function\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n限制源代码的引用路径。配置该选项后，所有源文件只能从约定的目录下引用代码，从其他目录引用代码会产生对应的报错提示。\n\n\n示例#\n\n首先我们配置 moduleScopes 仅包含 src 目录：\n\nexport default {\n  source: {\n    moduleScopes: ['./src'],\n  },\n};\n\n\n然后在 src/App.tsx 中导入 src 目录外部的 utils/a 模块:\n\n\n\n\n在编译时，会提示引用路径错误:\n\n\n\n通过该选项配置 utils 目录，再进行编译，则不会出现错误提示。\n\nexport default {\n  source: {\n    moduleScopes: ['./src', './utils'],\n  },\n};\n\n\nArray 类型#\n\n当 moduleScopes 的值为 Array 类型时，可以直接设置若干个代码路径，比如添加以下配置：\n\nexport default {\n  source: {\n    moduleScopes: ['./src', './shared', './utils'],\n  },\n};\n\n\nFunction 类型#\n\nmoduleScopes 也支持通过函数的形式来进行修改，避免覆盖默认值：\n\nexport default {\n  source: {\n    moduleScopes: scopes => {\n      scopes.push('./shared');\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"moduleScopes"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/module-scopes.mdx","_relativePath":"zh/configure/app/source/module-scopes.mdx"},{"id":469,"title":"source.preEntry","routePath":"/configure/app/source/pre-entry","lang":"zh","toc":[{"text":"添加单个脚本","id":"添加单个脚本","depth":4,"charIndex":178},{"text":"添加全局样式","id":"添加全局样式","depth":4,"charIndex":434},{"text":"添加多个脚本","id":"添加多个脚本","depth":4,"charIndex":595}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.preEntry。\n\n * 类型： string | string[]\n * 默认值： undefined\n\n在每个页面的入口文件前添加一段代码，这段代码会早于页面的代码执行，因此可以用于执行一些全局的代码逻辑，比如注入 polyfill、设置全局样式等。\n\n添加单个脚本#\n\n首先创建一个 src/polyfill.ts 文件：\n\nconsole.log('I am a polyfill');\n\n\n然后将 src/polyfill.ts 配置到 source.preEntry 上：\n\nexport default {\n  source: {\n    preEntry: './src/polyfill.ts',\n  },\n};\n\n\n重新运行编译并访问任意页面，可以看到 src/polyfill.ts 中的代码已经执行，并在 console 中输出了对应的内容。\n\n添加全局样式#\n\n你也可以通过 source.preEntry 来配置全局样式，这段 CSS 代码会早于页面代码加载，比如引入一个 normalize.css 文件：\n\nexport default {\n  source: {\n    preEntry: './src/normalize.css',\n  },\n};\n\n\n添加多个脚本#\n\n你可以将 preEntry 设置为数组来添加多个脚本，它们会按数组顺序执行：\n\nexport default {\n  source: {\n    preEntry: ['./src/polyfill-a.ts', './src/polyfill-b.ts'],\n  },\n};\n","frontmatter":{"sidebar_label":"preEntry"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/pre-entry.mdx","_relativePath":"zh/configure/app/source/pre-entry.mdx"},{"id":470,"title":"source.resolveExtensionPrefix","routePath":"/configure/app/source/resolve-extension-prefix","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":232},{"text":"根据产物类型设置","id":"根据产物类型设置","depth":4,"charIndex":538}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.resolveExtensionPrefix。\n\n * 类型： string | Record\n * 默认值： undefined\n\n用于为 resolve.extensions 添加统一的前缀。\n\n如果多个文件拥有相同的名称，但具有不同的文件后缀，Builder 会根据 extensions\n数组的顺序进行识别，解析数组中第一个被识别的文件，并跳过其余文件。\n\n\n示例#\n\n下面是配置 .web 前缀的例子。\n\nexport default {\n  source: {\n    resolveExtensionPrefix: '.web',\n  },\n};\n\n\n配置完成后，extensions 数组会发生以下变化：\n\n// 配置前\nconst extensions = ['.js', '.ts', ...];\n\n// 配置后\nconst extensions = ['.web.js', '.js', '.web.ts' , '.ts', ...];\n\n\n在代码中 import './foo' 时，会优先识别 foo.web.js 文件，再识别 foo.js 文件。\n\n根据产物类型设置#\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的 extension 前缀。此时，你需要把 resolveExtensionPrefix\n设置为一个对象，对象的 key 为对应的产物类型。\n\n比如为 web 和 node 设置不同的 extension 前缀：\n\nexport default {\n  output: {\n    source: {\n      resolveExtensionPrefix: {\n        web: '.web',\n        node: '.node',\n      },\n    },\n  },\n};\n\n\n在代码中 import './foo' 时，对于 node 产物，会优先识别 foo.node.js 文件，而对于 web 产物，则会优先识别\nfoo.web.js 文件。","frontmatter":{"sidebar_label":"resolveExtensionPrefix"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/resolve-extension-prefix.mdx","_relativePath":"zh/configure/app/source/resolve-extension-prefix.mdx"},{"id":471,"title":"source.resolveMainFields","routePath":"/configure/app/source/resolve-main-fields","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":253},{"text":"根据产物类型设置","id":"根据产物类型设置","depth":4,"charIndex":352}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.resolveMainFields。\n\n * 类型：\n\ntype Fields = (string | string[])[];\n\ntype ResolveMainFields = Fields | Record;\n\n\n * 默认值： undefined\n\n该配置项将决定你使用 package.json 哪个字段导入 npm 模块。对应 webpack 的 resolve.mainFields 配置。\n\n\n示例#\n\nexport default {\n  source: {\n    resolveMainFields: ['main', 'browser', 'exports'],\n  },\n};\n\n\n根据产物类型设置#\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的 mainFields。此时，你需要把 resolveMainFields 设置为一个对象，对象的\nkey 为对应的产物类型。\n\n比如为 web 和 node 设置不同的 mainFields：\n\nexport default {\n  output: {\n    source: {\n      resolveMainFields: {\n        web: ['main', 'browser', 'exports'],\n        node: ['main', 'node', 'exports'],\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"resolveMainFields"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/resolve-main-fields.mdx","_relativePath":"zh/configure/app/source/resolve-main-fields.mdx"},{"id":472,"title":"source.transformImport","routePath":"/configure/app/source/transform-import","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":1285},{"text":"禁用默认配置","id":"禁用默认配置","depth":3,"charIndex":1530},{"text":"配置","id":"配置","depth":3,"charIndex":1802},{"text":"libraryName","id":"libraryname","depth":4,"charIndex":1807},{"text":"libraryDirectory","id":"librarydirectory","depth":4,"charIndex":1900},{"text":"style","id":"style","depth":4,"charIndex":2046},{"text":"styleLibraryDirectory","id":"stylelibrarydirectory","depth":4,"charIndex":2257},{"text":"camelToDashComponentName","id":"cameltodashcomponentname","depth":4,"charIndex":2473},{"text":"transformToDefaultImport","id":"transformtodefaultimport","depth":4,"charIndex":2611},{"text":"customName","id":"customname","depth":4,"charIndex":2730},{"text":"customStyleName","id":"customstylename","depth":4,"charIndex":3198}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.transformImport。\n\n用于按需引入组件库的代码和样式，能力等价于 babel-plugin-import。\n\n它与 babel-plugin-import 的区别在于，source.transformImport 不与 Babel 耦合。Builder\n会自动识别当前使用的编译工具是 Babel、SWC 还是 Rspack，并添加相应的按需引入配置。\n\n * 类型：\n\ntype Config =\n  | false\n  | Array<{\n      libraryName: string;\n      libraryDirectory?: string;\n      style?: string | boolean;\n      styleLibraryDirectory?: string;\n      camelToDashComponentName?: boolean;\n      transformToDefaultImport?: boolean;\n      customName?: ((member: string) => string | undefined) | string;\n      customStyleName?: ((member: string) => string | undefined) | string;\n    }>;\n\n\n * 默认值：\n\n当项目中安装了 Ant Design 组件库 <= 4.x 版本时，Builder 会自动添加以下默认配置：\n\nconst defaultAntdConfig = {\n  libraryName: 'antd',\n  libraryDirectory: isServer ? 'lib' : 'es',\n  style: true,\n};\n\n\n当项目中安装了 Arco Design 组件库 时，Builder 会自动添加以下默认配置：\n\nconst defaultArcoConfig = [\n  {\n    libraryName: '@arco-design/web-react',\n    libraryDirectory: isServer ? 'lib' : 'es',\n    camelToDashComponentName: false,\n    style: true,\n  },\n  {\n    libraryName: '@arco-design/web-react/icon',\n    libraryDirectory: isServer ? 'react-icon-cjs' : 'react-icon',\n    camelToDashComponentName: false,\n  },\n];\n\n\nTIP\n\n当你添加了 antd 或 @arco-design/web-react 相关的配置时，优先级会高于上述默认配置。\n\n\n示例#\n\n当使用上述 antd 默认配置：\n\nexport default {\n  source: {\n    transformImport: [\n      {\n        libraryName: 'antd',\n        libraryDirectory: 'es',\n        style: true,\n      },\n    ],\n  },\n};\n\n\n源代码如下：\n\n\n\n\n会被转换成：\n\n\nimport 'antd/es/button/style';\n\n\n\n禁用默认配置#\n\n你可以手动设置 transformImport: false 来关掉 transformImport 的默认行为。\n\nexport default {\n  source: {\n    transformImport: false,\n  },\n};\n\n\n比如，当你使用了 externals 来避免打包 antd 时，由于 transformImport 默认会转换 antd\n的引用路径，导致匹配的路径发生了变化，因此 externals 无法正确生效，此时你可以设置关闭 transformImport 来避免该问题。\n\n\n配置#\n\nlibraryName#\n\n * 类型： string\n\n用于指定需要按需加载的模块名称。当 Builder 遍历代码时，如果遇到了对应模块的 import 语句，则会对其进行转换。\n\nlibraryDirectory#\n\n * 类型： string\n * 默认值： 'lib'\n\n用于拼接转换后的路径，拼接规则为 ${libraryName}/${libraryDirectory}/${member}，其中 member 为引入成员。\n\n示例：\n\n\n\n\n转换结果:\n\n\n\n\nstyle#\n\n * 类型： boolean\n * 默认值： undefined\n\n确定是否需要引入相关样式，若为 true，则会引入路径 ${libraryName}/${libraryDirectory}/${member}/style。\n若为 false 或 undefined 则不会引入样式。\n\n当配置为 true 时：\n\n\n\n\n转换结果:\n\n\nimport 'foo/lib/button/style';\n\n\nstyleLibraryDirectory#\n\n * 类型： string\n * 默认值： undefined\n\n该配置用于拼接引入样式时的引入路径，若该配置被指定，则 style 配置项会被忽略。拼接引入路径为\n${libraryName}/${styleLibraryDirectory}/${member}。\n\n当配置为 styles 时：\n\n\n\n\n转换结果:\n\n\nimport 'foo/styles/button';\n\n\ncamelToDashComponentName#\n\n * 类型： boolean\n * 默认值： true\n\n是否需要将 camelCase 的引入转换成 kebab-case。\n\n示例：\n\n\n\n\n转换结果：\n\n// 设置成 true：\n\n// 设置成 false：\n\n\n\ntransformToDefaultImport#\n\n * 类型： boolean\n * 默认值： true\n\n是否将导入语句转换成默认导入。\n\n示例：\n\n\n\n\n转换结果：\n\n// 设置成 true：\n\n// 设置成 false：\n\n\n\ncustomName#\n\n * 类型： ((member: string) => string | undefined) | string\n * 默认值： undefined\n\n注意\n * 函数类型的配置只能在 Webpack 构建中使用。\n * 模版类型的配置只能在 Rspack 构建或者使用了 SWC 的 Webpack 构建中使用。\n\n自定义转换后的导入路径，输入是引入的成员，例如配置成 (member) => `my-lib/${member}` ，会将 转换成 。\n\n在使用 Rspack 构建时，不能使用函数配置，但可以使用 handlebars 模版字符串，对于上面的函数配置，在使用模版字符串时可以用以下模版代替\nmy-lib/{{ member }}，也可以使用一些内置帮助方法，例如 my-lib/{{ kebabCase member }} 来转换成\nkebab-case 格式，除了 kebabCase 以外还有 camelCase，snakeCase，upperCase，lowerCase 可以使用。\n\ncustomStyleName#\n\n * 类型： ((member: string) => string | undefined) | string\n * 默认值： undefined\n\n注意\n * 函数类型的配置只能在 Webpack 构建中使用。\n * 模版类型的配置只能在 Rspack 构建或者使用了 SWC 的 Webpack 构建中使用。\n\n自定义转换后的样式导入路径，输入是引入的成员，例如配置成 (member) => `my-lib/${member}` ，会将 转换成 。\n\n在使用 Rspack 构建时，不能使用函数配置，但可以使用 handlebars 模版字符串，对于上面的函数配置，在使用模版字符串时可以用以下模版代替\nmy-lib/{{ member }}，也可以使用一些内置帮助方法，例如 my-lib/{{ kebabCase member }} 来转换成\nkebab-case 格式，除了 kebabCase 以外还有 camelCase，snakeCase，upperCase，lowerCase 可以使用。","frontmatter":{"sidebar_label":"transformImport"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/source/transform-import.mdx","_relativePath":"zh/configure/app/source/transform-import.mdx"},{"id":473,"title":"testing.transformer","routePath":"/configure/app/testing/transformer","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： 'babel-jest' | 'ts-jest'\n * 默认值： babel-jest\n\n配置执行测试的时候对于源码的编译工具： babel-jest 或 ts-jest。默认使用 babel-jest。\n\n补充信息\n\nbabel-jest 也可以编译 TS 文件，但不会类型报错，如果你需要跑测试的时候对 TS 类型进行校验，那么请使用 ts-jest。","frontmatter":{"title":"testing.transformer","sidebar_label":"transformer","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/testing/transformer.mdx","_relativePath":"zh/configure/app/testing/transformer.mdx"},{"id":474,"title":"tools.autoprefixer","routePath":"/configure/app/tools/autoprefixer","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":299},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":470}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.autoprefixer。\n\n * 类型： Object | Function\n * 默认值：\n\n{\n  flexbox: 'no-2009',\n  // browserslist 取决于项目中的 browserslist 配置\n  // 以及 `output.overrideBrowserslist`(优先级更高) 配置\n  overrideBrowserslist: browserslist,\n}\n\n\n通过 tools.autoprefixer 可以修改 autoprefixer 的配置。\n\n\nObject 类型#\n\n当 tools.autoprefixer 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。比如：\n\nexport default {\n  tools: {\n    autoprefixer: {\n      flexbox: 'no-2009',\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当 tools.autoprefixer 为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。比如：\n\nexport default {\n  tools: {\n    autoprefixer(config) {\n      // 修改 flexbox 的配置\n      config.flexbox = 'no-2009';\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"autoprefixer"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/autoprefixer.mdx","_relativePath":"zh/configure/app/tools/autoprefixer.mdx"},{"id":475,"title":"tools.babel","routePath":"/configure/app/tools/babel","lang":"zh","toc":[{"text":"使用场景","id":"使用场景","depth":3,"charIndex":140},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":407},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":945},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":1389},{"text":"addPlugins","id":"addplugins","depth":4,"charIndex":1440},{"text":"addPresets","id":"addpresets","depth":4,"charIndex":1804},{"text":"removePlugins","id":"removeplugins","depth":4,"charIndex":2015},{"text":"removePresets","id":"removepresets","depth":4,"charIndex":2256},{"text":"addIncludes","id":"addincludes","depth":4,"charIndex":2497},{"text":"addExcludes","id":"addexcludes","depth":4,"charIndex":2926},{"text":"modifyPresetEnvOptions","id":"modifypresetenvoptions","depth":4,"charIndex":3327},{"text":"modifyPresetReactOptions","id":"modifypresetreactoptions","depth":4,"charIndex":3650},{"text":"调试 Babel 配置","id":"调试-babel-配置","depth":3,"charIndex":3952}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.babel。\n\n * 类型： Object | Function\n * 默认值： undefined\n\n通过 tools.babel 可以修改 babel-loader 的配置项。\n\n\n使用场景#\n\n请留意 tools.babel 在以下使用场景中的局限性：\n\n * Rspack 场景：在使用 Rspack 作为打包工具时，使用 tools.babel 配置项将会明显拖慢 Rspack 构建速度。因为 Rspack\n   默认使用的是 SWC 编译，配置 Babel 会导致代码需要被编译两次，产生了额外的编译开销。\n * webpack + SWC 场景：在使用 webpack 作为打包工具时，如果你使用了 Builder 的 SWC 插件进行代码编译，那么\n   tools.babel 选项将不会生效。\n\n\nFunction 类型#\n\n当 tools.babel 为 Function 类型时，默认 Babel 配置会作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终的\nbabel-loader 配置。\n\nexport default {\n  tools: {\n    babel(config) {\n      // 添加一个插件，比如配置某个组件库的按需引入\n      config.plugins.push([\n        'babel-plugin-import',\n        {\n          libraryName: 'xxx-components',\n          libraryDirectory: 'es',\n          style: true,\n        },\n      ]);\n    },\n  },\n};\n\n\ntools.babel 函数的第二个参数提供了一些方便的工具函数，请继续阅读下方文档。\n\nTIP\n\n以上示例仅作为参考，通常来说，你不需要手动配置 babel-plugin-import，因为 Builder 已经提供了更通用的\nsource.transformImport 配置。\n\n\nObject 类型#\n\n当 tools.babel 的值为 Object 类型时，会与默认配置通过 Object.assign 浅合并。\n\nCAUTION\n\nObject.assign 是浅拷贝，会完全覆盖内置的 presets 或 plugins 数组，导致内置的 presets 或 plugins\n失效，请在明确影响面的情况下再使用这种方式。\n\nexport default {\n  tools: {\n    babel: {\n      plugins: [\n        [\n          'babel-plugin-import',\n          {\n            libraryName: 'xxx-components',\n            libraryDirectory: 'es',\n            style: true,\n          },\n        ],\n      ],\n    },\n  },\n};\n\n\n\n工具函数#\n\ntools.babel 为 Function 类型时，第二个参数可用的工具函数如下:\n\naddPlugins#\n\n * 类型： (plugins: BabelPlugin[]) => void\n\n添加若干个 Babel 插件。\n\nexport default {\n  tools: {\n    babel(config, { addPlugins }) {\n      addPlugins([\n        [\n          'babel-plugin-import',\n          {\n            libraryName: 'xxx-components',\n            libraryDirectory: 'es',\n            style: true,\n          },\n        ],\n      ]);\n    },\n  },\n};\n\n\naddPresets#\n\n * 类型： (presets: BabelPlugin[]) => void\n\n添加若干个 Babel 预设配置 (大多数情况下不需要增加预设)。\n\nexport default {\n  tools: {\n    babel(config, { addPresets }) {\n      addPresets(['@babel/preset-env']);\n    },\n  },\n};\n\n\nremovePlugins#\n\n * 类型： (plugins: string | string[]) => void\n\n移除 Babel 插件，传入需要移除的插件名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\nexport default {\n  tools: {\n    babel(config, { removePlugins }) {\n      removePlugins('babel-plugin-import');\n    },\n  },\n};\n\n\nremovePresets#\n\n * 类型： (presets: string | string[]) => void\n\n移除 Babel 预设配置，传入需要移除的预设名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\nexport default {\n  tools: {\n    babel(config, { removePresets }) {\n      removePresets('@babel/preset-env');\n    },\n  },\n};\n\n\naddIncludes#\n\n * 类型： (includes: string | RegExp | (string | RegExp)[]) => void\n\n默认情况下 Babel 只会编译 src 目录下的业务代码，使用 addIncludes 你可以指定 Babel 编译 node_modules\n下的一些文件。比如编译 query-string 依赖：\n\nexport default {\n  tools: {\n    babel(config, { addIncludes }) {\n      addIncludes(/\\/query-string\\//);\n    },\n  },\n};\n\n\nTIP\n\naddIncludes 函数的用法与 source.include 配置项基本一致，请查看 source.include 文档\n来查看更详细的用法说明。也可以直接使用 source.include 来代替 addIncludes 函数。\n\naddExcludes#\n\n * 类型： (excludes: string | RegExp | (string | RegExp)[]) => void\n\naddExcludes 和 addIncludes 的用处相反，指定 Babel 编译时排除某些文件。\n\n比如不编译 src/example 目录下的文件:\n\nexport default {\n  tools: {\n    babel(config, { addExcludes }) {\n      addExcludes('src/example');\n    },\n  },\n};\n\n\nTIP\n\naddExcludes 函数的用法与 source.exclude 配置项基本一致，请查看 source.exclude 文档\n来查看更详细的用法说明。也可以直接使用 source.exclude 来代替 addExcludes 函数。\n\nmodifyPresetEnvOptions#\n\n * 类型： (options: PresetEnvOptions) => void\n\n修改 @babel/preset-env 的配置项，传入的配置会与默认配置进行浅层合并，比如:\n\nexport default {\n  tools: {\n    babel(config, { modifyPresetEnvOptions }) {\n      modifyPresetEnvOptions({\n        targets: {\n          browsers: ['last 2 versions'],\n        },\n      });\n    },\n  },\n};\n\n\nmodifyPresetReactOptions#\n\n * 类型： (options: PresetReactOptions) => void\n\n修改 @babel/preset-react 的配置项，传入的配置会与默认配置进行浅层合并，比如:\n\nexport default {\n  tools: {\n    babel(config, { modifyPresetReactOptions }) {\n      modifyPresetReactOptions({\n        pragma: 'React.createElement',\n      });\n    },\n  },\n};\n\n\n\n调试 Babel 配置#\n\n当你通过 tools.babel 修改 babel-loader 配置后，可以在 Builder 调试模式 下查看最终生成的配置。\n\n首先通过 DEBUG=builder 参数开启调试模式：\n\n# 调试开发环境\nDEBUG=builder pnpm dev\n\n# 调试生产环境\nDEBUG=builder pnpm build\n\n\n然后打开生成的 (webpack|rspack).config.web.js，搜索 babel-loader 关键词，即可看到完整的 babel-loader\n配置内容。","frontmatter":{"sidebar_label":"babel"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/babel.mdx","_relativePath":"zh/configure/app/tools/babel.mdx"},{"id":476,"title":"tools.bundlerChain","routePath":"/configure/app/tools/bundler-chain","lang":"zh","toc":[{"text":"工具集合","id":"工具集合","depth":3,"charIndex":693},{"text":"env","id":"env","depth":4,"charIndex":700},{"text":"isProd","id":"isprod","depth":4,"charIndex":990},{"text":"target","id":"target","depth":4,"charIndex":1208},{"text":"isServer","id":"isserver","depth":4,"charIndex":1446},{"text":"isWebWorker","id":"iswebworker","depth":4,"charIndex":1655},{"text":"HtmlPlugin","id":"htmlplugin","depth":3,"charIndex":1886},{"text":"CHAIN_ID","id":"chain_id","depth":4,"charIndex":2147},{"text":"CHAIN_ID.ONE_OF","id":"chain_idone_of","depth":3,"charIndex":2397},{"text":"CHAIN_ID.USE","id":"chain_iduse","depth":3,"charIndex":2676},{"text":"CHAIN_ID.PLUGIN","id":"chain_idplugin","depth":3,"charIndex":2918},{"text":"常用 BundlerChain 使用示例","id":"常用-bundlerchain-使用示例","depth":3,"charIndex":3450}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.bundlerChain。\n\n * 类型： Function | undefined\n * 默认值： undefined\n\n你可以通过 tools.bundlerChain 来修改默认的 webpack 和 Rspack 配置，它的值为 Function 类型，接收两个参数：\n\n * 第一个参数为 bundler-chain 对象实例，你可以通过这个实例来修改 webpack 和 Rspack 的配置。\n * 第二个参数为一个工具集合，包括env、isProd、CHAIN_ID 等。\n\n什么是 BundlerChain\n\nBundler chain 是 webpack chain 的子集，其中包含一部分 webpack chain API，你可以用它来同时修改 webpack 和\nRspack 的配置。\n\n通过 bundler chain 修改的配置，在 webpack 和 Rspack 构建时均可生效。需要注意的是，bundler chain 只支持修改\nwebpack 和 Rspack 间无差异部分的配置。如，修改 devtool 配置项(webpack 和 Rspack 的 devtool\n属性值类型相同)，或添加一个Rspack 兼容的 webpack 插件。\n\n> tools.bundlerChain 的执行时机早于 tools.webpackChain / tools.webpack /\n> tools.rspack，因此会被其他几个配置中的修改所覆盖。\n\n\n工具集合#\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\nexport default {\n  tools: {\n    bundlerChain: (chain, { env }) => {\n      if (env === 'development') {\n        chain.devtool('cheap-module-eval-source-map');\n      }\n    },\n  },\n};\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\nexport default {\n  tools: {\n    bundlerChain: (chain, { isProd }) => {\n      if (isProd) {\n        chain.devtool('source-map');\n      }\n    },\n  },\n};\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\nexport default {\n  tools: {\n    bundlerChain: (chain, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n    },\n  },\n};\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\nexport default {\n  tools: {\n    bundlerChain: (chain, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n    },\n  },\n};\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\nexport default {\n  tools: {\n    bundlerChain: (chain, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n    },\n  },\n};\n\n\n\nHtmlPlugin#\n\n * 类型： typeof import('html-webpack-plugin') | import('@rspack/plugin-html')\n\n通过这个参数你可以拿到 webpack 或 Rspack 中的 HtmlPlugin 实例。\n\nexport default {\n  tools: {\n    bundlerChain: (chain, { HtmlPlugin }) => {\n      console.log(HtmlPlugin);\n    },\n  },\n};\n\n\nCHAIN_ID#\n\nBuilder 中预先定义了一些常用的 Chain ID，你可以通过这些 ID 来定位到内置的 Rule 或 Plugin。\n\nCHAIN_ID.RULE#\n\nID          描述\nRULE.MJS    处理 mjs 的规则\nRULE.CSS    处理 css 的规则\nRULE.LESS   处理 less 的规则\nRULE.SASS   处理 sass 的规则\nRULE.TOML   处理 toml 的规则\nRULE.YAML   处理 yaml 的规则\n\n\nCHAIN_ID.ONE_OF#\n\n通过 ONE_OF.XXX 可以匹配到规则数组中的某一类规则。\n\nID                  描述\nONE_OF.SVG          处理 SVG 的规则，在 data URI 和单独文件之间自动选择\nONE_OF.SVG_URL      处理 SVG 的规则，输出为单独文件\nONE_OF.SVG_INLINE   处理 SVG 的规则，作为 data URI 内联到 bundle 中\nONE_OF.SVG_ASSETS   处理 SVG 的规则，在 data URI 和单独文件之间自动选择\n\n\nCHAIN_ID.USE#\n\n通过 USE.XXX 可以匹配到对应的 loader。\n\nID            描述\nUSE.LESS      对应 less-loader\nUSE.SASS      对应 sass-loader\nUSE.TOML      对应 toml-loader\nUSE.YAML      对应 yaml-loader\nUSE.SVGR      对应 @svgr/webpack\nUSE.POSTCSS   对应 postcss-loader\n\n\nCHAIN_ID.PLUGIN#\n\n通过 PLUGIN.XXX 可以匹配到对应的 plugin。\n\nID                          描述\nPLUGIN.HTML                 对应 HtmlPlugin，使用时需要拼接 entry 名称：${PLUGIN.HTML}-${entryName}\nPLUGIN.APP_ICON             对应 AppIconPlugin\nPLUGIN.INLINE_HTML          对应 InlineChunkHtmlPlugin\nPLUGIN.BUNDLE_ANALYZER      对应 WebpackBundleAnalyzer\nPLUGIN.BOTTOM_TEMPLATE      对应 BottomTemplatePlugin\nPLUGIN.ASSETS_RETRY         对应 Builder 中的 webpack 静态资源重试插件 WebpackAssetsRetryPlugin\nPLUGIN.AUTO_SET_ROOT_SIZE   对应 Builder 中的自动设置根字体大小插件 AutoSetRootSizePlugin\n\n\n常用 BundlerChain 使用示例#\n\nBundlerChain 的使用可参考：常用 WebpackChain 使用示例。","frontmatter":{"sidebar_label":"bundlerChain"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/bundler-chain.mdx","_relativePath":"zh/configure/app/tools/bundler-chain.mdx"},{"id":477,"title":"tools.cssExtract","routePath":"/configure/app/tools/css-extract","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":471},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":684}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.cssExtract。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  // Loader 配置\n  loaderOptions: {},\n  // Plugin 配置\n  pluginOptions: {\n    // cssPath 默认为 static/css, cssFilename 默认为 [name].[contenthash:8].css\n    filename: `${cssPath}/${cssFilename}`,\n    chunkFilename: `${cssPath}/async/${cssFilename}`,\n    ignoreOrder: true,\n  },\n};\n\n\n * 打包工具： 仅支持 webpack\n\n通过 tools.cssExtract 可以更改 mini-css-extract-plugin 的配置。\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。比如：\n\nexport default {\n  tools: {\n    cssExtract: {\n      pluginOptions: {\n        filename: 'static/css/[name].[contenthash:8].css',\n      },\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\nexport default {\n  tools: {\n    cssExtract: config => {\n      config.pluginOptions.filename = 'static/css/[name].[contenthash:8].css';\n      return config;\n    },\n  },\n};\n\n\n更多配置细节可参考 mini-css-extract-plugin。","frontmatter":{"sidebar_label":"cssExtract"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/css-extract.mdx","_relativePath":"zh/configure/app/tools/css-extract.mdx"},{"id":478,"title":"tools.cssLoader","routePath":"/configure/app/tools/css-loader","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":568},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":748}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.cssLoader。\n\n * 类型： Object | Function\n * 默认值： undefined\n\n通过 tools.cssLoader 可以修改 css-loader 的配置项。默认配置如下:\n\n{\n  modules: {\n    auto: true,\n    exportLocalsConvention: 'camelCase',\n    localIdentName: config.output.cssModuleLocalIdentName,\n    // isServer 表示 node (SSR) 构建\n    // isWebWorker 表示 web worker 构建\n    exportOnlyLocals: isServer || isWebWorker,\n  },\n  // 默认在开发环境下启用 CSS 的 Source Map\n  sourceMap: isDev,\n  // importLoaders 在编译 css 文件时为 `1`，在编译 sass/less 文件时为 `2`\n  importLoaders: 1 || 2,\n}\n\n\n * 打包工具： 仅支持 webpack\n\n\nObject 类型#\n\n当此值为 Object 类型时，会与默认配置进行深层合并 (deep merge)。比如：\n\nexport default {\n  tools: {\n    cssLoader: {\n      modules: {\n        exportOnlyLocals: true,\n      },\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\nexport default {\n  tools: {\n    cssLoader: config => {\n      config.modules.exportOnlyLocals = true;\n      return config;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"cssLoader"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/css-loader.mdx","_relativePath":"zh/configure/app/tools/css-loader.mdx"},{"id":479,"title":"tools.devServer","routePath":"/configure/app/tools/dev-server","lang":"zh","toc":[{"text":"选项","id":"选项","depth":3,"charIndex":122},{"text":"after","id":"after","depth":4,"charIndex":127},{"text":"before","id":"before","depth":4,"charIndex":761},{"text":"client","id":"client","depth":4,"charIndex":1020},{"text":"compress","id":"compress","depth":4,"charIndex":1540},{"text":"devMiddleware","id":"devmiddleware","depth":4,"charIndex":1726},{"text":"headers","id":"headers","depth":4,"charIndex":1950},{"text":"historyApiFallback","id":"historyapifallback","depth":4,"charIndex":2123},{"text":"hot","id":"hot","depth":4,"charIndex":2418},{"text":"https","id":"https","depth":4,"charIndex":2489},{"text":"liveReload","id":"livereload","depth":4,"charIndex":2883},{"text":"setupMiddlewares","id":"setupmiddlewares","depth":4,"charIndex":3044},{"text":"proxy","id":"proxy","depth":4,"charIndex":4211},{"text":"watch","id":"watch","depth":4,"charIndex":5958}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.devServer。\n\n * 类型： Object\n * 默认值： {}\n\n通过 tools.devServer 可以修改开发环境服务器的配置。\n\n\n选项#\n\nafter#\n\n * 类型： Array\n * 默认值： []\n\n添加自定义中间件，在所有开发环境中间件后执行。\n\nexport default {\n  tools: {\n    devServer: {\n      after: [\n        async (req, res, next) => {\n          console.log('after dev middleware');\n          next();\n        },\n      ],\n    },\n  },\n};\n\n\nwebpack-dev-server 使用 Express 作为服务端框架。Modern.js 中没有使用任何框架，上述中间件中 req 和 res 都是\nNode 原生对象，因此 webpack-dev-server 的 Express 中间件不一定能直接在 Modern.js 中使用。\n\n如果要迁移 webpack-dev-server 中使用的 Express 中间件，可以使用以下方式，将 Express app 作为中间件传入：\n\n\n\n\n// 初始化 Express app\nconst app = express();\napp.use(expressMiddleware);\n\nexport default {\n  tools: {\n    devServer: {\n      after: [app],\n    },\n  },\n};\n\n\nbefore#\n\n * 类型： Array\n * 默认值： []\n\n添加自定义中间件，在所有开发环境中间件前执行。\n\nexport default {\n  tools: {\n    devServer: {\n      before: [\n        async (req, res, next) => {\n          console.log('before dev middleware');\n          next();\n        },\n      ],\n    },\n  },\n};\n\n\nclient#\n\n * 类型：\n\n{\n    /** 指定协议名称 */\n    protocol?: string;\n    /** 事件流路径 */\n    path?: string;\n    /** 指定监听请求的端口号 */\n    port?: string;\n    /** 指定要使用的 host */\n    host?: string;\n}\n\n\n * 默认值：\n\nconst defaultConfig = {\n  path: '/webpack-hmr',\n  // By default it is set to the port number of the dev server\n  port: '',\n  // By default it is set to \"location.hostname\"\n  host: '',\n  // By default it is set to \"location.protocol === 'https:' ? 'wss' : 'ws'\"\"\n  protocol: '',\n};\n\n\n对应 HMR 客户端的配置，通常用于设置 HMR 对应的 WebSocket URL。\n\ncompress#\n\n * 类型： boolean\n * 默认值： true\n\n是否对静态资源启用 gzip 压缩。\n\n如果你需要禁用 gzip 压缩，可以将 compress 设置为 false：\n\nexport default {\n  tools: {\n    devServer: {\n      compress: false,\n    },\n  },\n};\n\n\ndevMiddleware#\n\n * 类型：\n\n{\n  writeToDisk: boolean | ((filename: string) => boolean);\n}\n\n\n * 默认值：\n\n{\n  writeToDisk: (file: string) => !file.includes('.hot-update.'),\n}\n\n\ndevMiddleware 配置项。当前配置是 webpack-dev-middleware 配置项的子集.\n\nheaders#\n\n * 类型： Record\n * 默认值： undefined\n\n设置自定义响应头。\n\nexport default {\n  tools: {\n    devServer: {\n      headers: {\n        'X-Custom-Foo': 'bar',\n      },\n    },\n  },\n};\n\n\nhistoryApiFallback#\n\n * 类型： boolean | ConnectHistoryApiFallbackOptions\n * 默认值： false\n\n在需要对一些 404 响应或其他请求提供替代页面的场景，可通过 devServer.historyApiFallback 进行设置：\n\nexport default {\n  tools: {\n    devServer: {\n      historyApiFallback: true,\n    },\n  },\n};\n\n\n更多选项和详细信息可参考 connect-history-api-fallback 文档。\n\nhot#\n\n * 类型： boolean\n * 默认值： true\n\n是否开启 Hot Module Replacement 热更新能力。\n\nhttps#\n\n * 类型： boolean | { key: string; cert: string }\n * 默认值： false\n\n默认情况下，DevServer 会启用 HTTP 服务器。通过设置 devServer.https 为 true 将开启对 HTTPS 的支持，同时会禁用\nHTTP 服务器。\n\n你也可以手动传入 HTTPS 服务器所需要的证书和对应的私钥：\n\nexport default {\n  tools: {\n    devServer: {\n      https: {\n        key: fs.readFileSync('certificates/private.pem'),\n        cert: fs.readFileSync('certificates/public.pem'),\n      },\n    },\n  },\n};\n\n\nliveReload#\n\n * 类型： boolean\n * 默认值： true\n\n默认情况下，当监听到文件变化时，DevServer 将会刷新页面（为使 liveReload 能够生效，devServer.hot 配置项应当禁用）。通过设置\ndevServer.liveReload 为 false 可以关闭该行为。\n\nsetupMiddlewares#\n\n * 类型：\n\nArray<\n  (\n    middlewares: {\n      unshift: (...handlers: RequestHandler[]) => void;\n      push: (...handlers: RequestHandler[]) => void;\n    },\n    server: {\n      sockWrite: (\n        type: string,\n        data?: string | boolean | Record,\n      ) => void;\n    },\n  ) => void\n>;\n\n\n * 默认值： undefined\n\n提供执行自定义函数和应用自定义中间件的能力。\n\n几种不同中间件之间的执行顺序是: devServer.before => unshift => 内置中间件 => push =>\ndevServer.after。\n\nexport default {\n  tools: {\n    devServer: {\n      setupMiddlewares: [\n        (middlewares, server) => {\n          middlewares.unshift((req, res, next) => {\n            next();\n          });\n\n          middlewares.push((req, res, next) => {\n            next();\n          });\n        },\n      ],\n    },\n  },\n};\n\n\n一些特殊场景需求可能需要使用服务器 API：\n\n * sockWrite。允许向 hmr 客户端传递一些消息，hmr 客户端将根据接收到的消息类型进行不同的处理。如果你发送一个\n   \"content-changed \" 的消息，页面将会重新加载。\n\nexport default {\n  tools: {\n    devServer: {\n      setupMiddlewares: [\n        (middlewares, server) => {\n          // 添加自定义 watcher 并在文件更新时触发页面刷新\n          watcher.on('change', changed => {\n            server.sockWrite('content-changed');\n          });\n        },\n      ],\n    },\n  },\n};\n\n\nproxy#\n\n * 类型： Record | Record\n * 默认值： undefined\n\n代理请求到指定的服务上。\n\nexport default {\n  tools: {\n    devServer: {\n      proxy: {\n        '/api': 'http://localhost:3000',\n      },\n    },\n  },\n};\n\n\n此时，/api/users 请求将会代理到 http://localhost:3000/api/users。\n\n如果你不想传递 /api，可以通过 pathRewrite 重写请求路径：\n\nexport default {\n  tools: {\n    devServer: {\n      proxy: {\n        '/api': {\n          target: 'http://localhost:3000',\n          pathRewrite: { '^/api': '' },\n        },\n      },\n    },\n  },\n};\n\n\nDevServer Proxy 基于 http-proxy-middleware 实现。你可以使用 http-proxy-middleware\n的所有配置项，具体可以查看文档。\n\nDevServer Proxy 完整类型定义为：\n\n\n\ntype ProxyDetail = HttpProxyOptions & {\n  bypass?: (\n    req: IncomingMessage,\n    res: ServerResponse,\n    proxyOptions: ProxyOptions,\n  ) => string | undefined | null | false;\n  context?: string | string[];\n};\n\ntype ProxyOptions =\n  | Record\n  | Record\n  | ProxyDetail[]\n  | ProxyDetail;\n\n\n除了 http-proxy-middleware 的选项外，还支持 bypass 和 context 两个配置项：\n\n * bypass：根据函数的返回值绕过代理。\n   * 返回 null 或 undefined 会继续用代理处理请求。\n   * 返回 false 会返回 404 错误。\n   * 返回一个具体的服务路径，将会使用此路径替代原请求路径。\n * context：如果你想代理多个特定的路径到同一个目标，你可以使用 context 配置项。\n\n// 自定义 bypass 方法\nexport default {\n  tools: {\n    devServer: {\n      proxy: {\n        '/api': {\n          target: 'http://localhost:3000',\n          bypass: function (req, res, proxyOptions) {\n            if (req.headers.accept.indexOf('html') !== -1) {\n              console.log('Skipping proxy for browser request.');\n              return '/index.html';\n            }\n          },\n        },\n      },\n    },\n  },\n};\n\n\n// 代理多个路径到同一个目标\nexport default {\n  tools: {\n    devServer: {\n      proxy: [\n        {\n          context: ['/auth', '/api'],\n          target: 'http://localhost:3000',\n        },\n      ],\n    },\n  },\n};\n\n\nwatch#\n\n * 类型： boolean\n * 默认值： true\n\n是否监听 mock/、server/、api/ 等目录的文件变化。","frontmatter":{"sidebar_label":"devServer"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/dev-server.mdx","_relativePath":"zh/configure/app/tools/dev-server.mdx"},{"id":480,"title":"tools.esbuild","routePath":"/configure/app/tools/esbuild","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":36},{"text":"配置项","id":"配置项","depth":2,"charIndex":488}],"domain":"","content":"#\n\n * 类型： Object\n * 默认值： undefined\n\n\n介绍#\n\nesbuild 是一款基于 Golang 开发的前端构建工具，具有打包、编译和压缩 JavaScript 代码的功能，相比传统的打包编译工具，esbuild\n在性能上有显著提升。在代码压缩方面，相比 webpack 内置的 terser 压缩器，esbuild 在性能上有数十倍的提升。\n\nModern.js Builder 提供了 esbuild 插件，让你能使用 esbuild 代替 babel-loader、ts-loader 和\nterser 等库进行代码编译和压缩。在大型工程中启用 esbuild 后，可以大幅度减少代码编译和压缩所需的时间，同时有效避免 OOM (heap out\nof memory) 问题。\n\n推荐使用 SWC\n\n相较于 esbuild，我们更推荐使用 SWC 来编译和压缩代码，因为 SWC 支持更多的语法特性、拥有更好的代码压缩率，并且产物具备更好的兼容性。\n\n因此，我们建议你使用 SWC 而不是 esbuild，用法请参考 tools.swc。\n\n\n配置项#\n\n你可以通过 tools.esbuild 配置项来设置 esbuild 编译行为。\n\n\n\nexport default defineConfig({\n  tools: {\n    esbuild: {\n      loader: {\n        target: 'chrome61',\n      },\n      minimize: {\n        target: 'chrome61',\n      },\n    },\n  },\n});\n\n\n完整配置项请参考 Modern.js Builder - esbuild 插件配置。","frontmatter":{"sidebar_label":"esbuild"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/esbuild.mdx","_relativePath":"zh/configure/app/tools/esbuild.mdx"},{"id":481,"title":"tools.htmlPlugin","routePath":"/configure/app/tools/html-plugin","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":688},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":859},{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":1192}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.htmlPlugin。\n\n * 类型： false | Object | Function\n * 默认值：\n\nconst defaultHtmlPluginOptions = {\n  inject, // 对应 html.inject 配置项\n  favicon, // 对应 html.favicon 配置项\n  filename, // 基于 output.distPath 和 entryName 生成\n  template, // 默认为内置的 HTML 模板路径\n  templateParameters, // 对应 html.templateParameters 配置项\n  chunks: [entryName],\n  minify: {\n    removeComments: false,\n    useShortDoctype: true,\n    keepClosingSlash: true,\n    collapseWhitespace: true,\n    removeRedundantAttributes: true,\n    removeScriptTypeAttributes: true,\n    removeStyleLinkTypeAttributes: true,\n  },\n};\n\n\n通过 tools.htmlPlugin 可以修改 html-webpack-plugin 或 @rspack/plugin-html 的配置项。\n\n\nObject 类型#\n\n当 tools.htmlPlugin 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\nexport default {\n  tools: {\n    htmlPlugin: {\n      scriptLoading: 'blocking',\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当 tools.htmlPlugin 为 Function 类型时：\n\n * 第一个参数是默认配置的对象，可以直接修改该对象。\n * 第二个参数是也是一个对象，包含了 entry 的名称和 entry 的值。\n * 函数可以 return 一个新的对象作为最终的配置。\n\nexport default {\n  tools: {\n    htmlPlugin(config, { entryName, entryValue }) {\n      if (entryName === 'main') {\n        config.scriptLoading = 'blocking';\n      }\n    },\n  },\n};\n\n\n\nBoolean 类型#\n\n将 tools.htmlPlugin 配置为 false，可以禁用默认的 html-webpack-plugin 插件。\n\nexport default {\n  tools: {\n    htmlPlugin: false,\n  },\n};\n","frontmatter":{"sidebar_label":"htmlPlugin"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/html-plugin.mdx","_relativePath":"zh/configure/app/tools/html-plugin.mdx"},{"id":482,"title":"tools.inspector","routePath":"/configure/app/tools/inspector","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":289},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":466}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.inspector。\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n你可以通过 tools.inspector 开启或者配置 webpack 调试工具 webpack inspector。\n\n当配置不为 undefined 时，则表示开启了 webpack-inspector，此时 tools.inspector 的类型可以为 Object 或者\nFunction。\n\n\nObject 类型#\n\n当 tools.inspector 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。比如：\n\nexport default {\n  tools: {\n    inspector: {\n      // 默认端口为 3333\n      port: 3334,\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当 tools.inspector 为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。比如：\n\nexport default {\n  tools: {\n    inspector(config) {\n      // 修改端口号\n      config.port = 3333;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"inspector"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/inspector.mdx","_relativePath":"zh/configure/app/tools/inspector.mdx"},{"id":483,"title":"tools.jest","routePath":"/configure/app/tools/jest","lang":"zh","toc":[],"domain":"","content":"#\n\n * 类型： Object | Function\n * 默认值： {}\n\n注意\n\n需要先通过 pnpm run new 启用 单元测试 功能。\n\n对应 Jest 的配置，当为 Object 类型时，可以配置 Jest 所支持的所有底层配置 。\n\nexport default defineConfig({\n  tools: {\n    jest: {\n      testTimeout: 10000,\n    },\n  },\n});\n\n\n值为 Function 类型时，默认配置作为第一个参数传入，需要返回新的 Jest 配置对象。\n\nexport default defineConfig({\n  tools: {\n    jest: options => {\n      return {\n        ...options,\n        testTimeout: 10000,\n      };\n    },\n  },\n});\n","frontmatter":{"sidebar_label":"jest"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/jest.mdx","_relativePath":"zh/configure/app/tools/jest.mdx"},{"id":484,"title":"tools.less","routePath":"/configure/app/tools/less","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":261},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":495},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":765},{"text":"addExcludes","id":"addexcludes","depth":4,"charIndex":772}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.less。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  lessOptions: {\n    javascriptEnabled: true,\n  },\n  // 默认在开发环境下启用 CSS 的 Source Map\n  sourceMap: isDev,\n};\n\n\n你可以通过 tools.less 修改 less-loader 的配置。\n\n\nObject 类型#\n\n当 tools.less 的值为 Object 类型时，会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，lessOptions 会通过\ndeepMerge 进行深层合并。\n\nexport default {\n  tools: {\n    less: {\n      lessOptions: {\n        javascriptEnabled: false,\n      },\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当 tools.less 为 Function\n类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果，第二个参数提供了一些可以直接调用的工具函数：\n\nexport default {\n  tools: {\n    less(config) {\n      // 修改 lessOptions 配置\n      config.lessOptions = {\n        javascriptEnabled: false,\n      };\n    },\n  },\n};\n\n\n\n工具函数#\n\naddExcludes#\n\n * 类型： (excludes: RegExp | RegExp[]) => void\n\n用来指定 less-loader 不编译哪些文件，你可以传入一个或多个正则表达式来匹配 less 文件的路径。例如：\n\nexport default {\n  tools: {\n    less(config, { addExcludes }) {\n      addExcludes(/node_modules/);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"less"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/less.mdx","_relativePath":"zh/configure/app/tools/less.mdx"},{"id":485,"title":"tools.minifyCss","routePath":"/configure/app/tools/minify-css","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":394},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":652}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.minifyCss。\n\n * 类型： Object | Function | undefined\n * 默认值：\n\nconst defaultOptions = {\n  minimizerOptions: {\n    preset: [\n      'default',\n      {\n        mergeLonghand: false,\n      },\n    ],\n  },\n};\n\n\n * 打包工具： 仅支持 webpack\n\n在生产环境构建时，Builder 会通过 css-minimizer-webpack-plugin 对 CSS 代码进行压缩优化。可以通过\ntools.minifyCss 修改 css-minimizer-webpack-plugin 的配置。\n\n\nObject 类型#\n\n当 tools.minifyCss 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\n例如下面修改 cssnano 的 preset 配置：\n\nexport default {\n  tools: {\n    minifyCss: {\n      minimizerOptions: {\n        preset: require.resolve('cssnano-preset-simple'),\n      },\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当 tools.minifyCss 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\nexport default {\n   tools: {\n    minifyCss: options => {\n      options.minimizerOptions = {\n        preset: require.resolve('cssnano-preset-simple'),\n      },\n    }\n  }\n};\n","frontmatter":{"sidebar_label":"minifyCss"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/minify-css.mdx","_relativePath":"zh/configure/app/tools/minify-css.mdx"},{"id":486,"title":"tools.postcss","routePath":"/configure/app/tools/postcss","lang":"zh","toc":[{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":629},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":1445},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":1756},{"text":"addPlugins","id":"addplugins","depth":4,"charIndex":1763}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.postcss。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  postcssOptions: {\n    plugins: [\n      require('postcss-flexbugs-fixes'),\n      require('postcss-custom-properties'),\n      require('postcss-initial'),\n      require('postcss-page-break'),\n      require('postcss-font-variant'),\n      require('postcss-media-minmax'),\n      require('postcss-nesting'),\n      require('autoprefixer')({\n        flexbox: 'no-2009',\n      }),\n    ],\n    // 默认在开发环境下启用 CSS 的 Source Map\n    sourceMap: isDev,\n  },\n};\n\n\nBuilder 默认集成 PostCSS，你可以通过 tools.postcss 对 postcss-loader 进行配置。\n\n\nFunction 类型#\n\n值为 Function 类型时，内部默认配置作为第一参数传入，可以直接修改配置对象不做返回，也可以返回一个对象作为最终结果；第二个参数为修改\npostcss-loader 配置的工具函数集合。\n\n例如，需要在原有插件的基础上新增一个 PostCSS 插件，在 postcssOptions.plugins 数组中 push 一个新的插件即可：\n\nexport default {\n  tools: {\n    postcss: opts => {\n      opts.postcssOptions.plugins.push(require('postcss-px-to-viewport'));\n    },\n  },\n};\n\n\n需要给 PostCSS 插件传递参数时，可以通过函数参数的形式进行传入：\n\nexport default {\n  tools: {\n    postcss: opts => {\n      const viewportPlugin = require('postcss-px-to-viewport')({\n        viewportWidth: 375,\n      });\n      opts.postcssOptions.plugins.push(viewportPlugin);\n    },\n  },\n};\n\n\ntools.postcss 可以返回一个配置对象，并完全替换默认配置：\n\nexport default {\n  tools: {\n    postcss: () => {\n      return {\n        postcssOptions: {\n          plugins: [require('postcss-px-to-viewport')],\n        },\n      };\n    },\n  },\n};\n\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。注意 Object.assign 是浅拷贝，会完全覆盖内置的 plugins\n数组，请谨慎使用。\n\nexport default {\n  tools: {\n    postcss: {\n      // 由于使用 `Object.assign` 合并，因此默认的 postcssOptions 会被覆盖。\n      postcssOptions: {\n        plugins: [require('postcss-px-to-viewport')],\n      },\n    },\n  },\n};\n\n\n\n工具函数#\n\naddPlugins#\n\n * 类型： (plugins: PostCSSPlugin | PostCSSPlugin[]) => void\n\n用于添加额外的 PostCSS 插件，你可以传入单个 PostCSS 插件，也可以传入 PostCSS 插件数组。\n\nexport default {\n  tools: {\n    postcss: (config, { addPlugins }) => {\n      // 添加一个插件\n      addPlugins(require('postcss-preset-env'));\n      // 批量添加插件\n      addPlugins([require('postcss-preset-env'), require('postcss-import')]);\n    },\n  },\n};\n\n\nTIP\n\nBuilder 中使用的 PostCSS 版本为 v8，当你引入社区中的 PostCSS 插件时，请注意版本是否适配，部分旧版本插件可能无法在 PostCSS\nv8 下运行。","frontmatter":{"sidebar_label":"postcss"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/postcss.mdx","_relativePath":"zh/configure/app/tools/postcss.mdx"},{"id":487,"title":"tools.pug","routePath":"/configure/app/tools/pug","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":127},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":296},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":464}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.pug。\n\n * 类型： true | Object | Function | undefined\n * 默认值： false\n\n配置 Pug 模板引擎。\n\n\nBoolean 类型#\n\nBuilder 默认不启用 Pug 模板引擎，你可以将 tools.pug 设置为 true 来启用它。\n\nexport default {\n  tools: {\n    pug: true,\n  },\n};\n\n\n启用后，你可以在 html.template 中指定使用 index.pug 作为模板文件。\n\n\nObject 类型#\n\n当 tools.terser 的值为 Object 类型时，可以配置 Pug 模板引擎的选项：\n\nexport default {\n  tools: {\n    pug: {\n      doctype: 'xml',\n    },\n  },\n};\n\n\n详细参数请查看 Pug API Reference。\n\n\nFunction 类型#\n\n当 tools.pug 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\nexport default {\n  tools: {\n    pug(config) {\n      config.doctype = 'xml';\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"pug"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/pug.mdx","_relativePath":"zh/configure/app/tools/pug.mdx"},{"id":488,"title":"tools.rspack","routePath":"/configure/app/tools/rspack","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":165},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":415},{"text":"工具集合","id":"工具集合","depth":3,"charIndex":721},{"text":"env","id":"env","depth":4,"charIndex":764},{"text":"isProd","id":"isprod","depth":4,"charIndex":1072},{"text":"target","id":"target","depth":4,"charIndex":1308},{"text":"isServer","id":"isserver","depth":4,"charIndex":1562},{"text":"isWebWorker","id":"iswebworker","depth":4,"charIndex":1787},{"text":"addRules","id":"addrules","depth":4,"charIndex":2033},{"text":"prependPlugins","id":"prependplugins","depth":4,"charIndex":2560},{"text":"appendPlugins","id":"appendplugins","depth":4,"charIndex":2910},{"text":"removePlugin","id":"removeplugin","depth":4,"charIndex":3259},{"text":"mergeConfig","id":"mergeconfig","depth":4,"charIndex":3516},{"text":"getCompiledPath","id":"getcompiledpath","depth":4,"charIndex":3778}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.rspack。\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 Rspack\n\ntools.rspack 选项用于配置原生的 Rspack。\n\n\nObject 类型#\n\ntools.rspack 可以配置为一个对象，这个对象将会和内置的 Rspack 配置通过 webpack-merge 进行深层合并。\n\n比如添加 resolve.alias 配置：\n\nexport default {\n  tools: {\n    rspack: {\n      resolve: {\n        alias: {\n          '@util': 'src/util',\n        },\n      },\n    },\n  },\n};\n\n\n\nFunction 类型#\n\ntools.rspack 也可以配置为一个函数，这个函数接收一个参数，即内置的 Rspack 配置对象，你可以对这个对象进行修改，然后返回一份新的配置。比如：\n\nexport default {\n  tools: {\n    rspack: config => {\n      config.resolve.alias['@util'] = 'src/util';\n      return config;\n    },\n  },\n};\n\n\nTIP\n\ntools.rspack 函数返回的对象会直接作为最终使用的 Rspack 配置，不会再与内置的 Rspack 配置进行合并。\n\n\n工具集合#\n\n这个函数的第二个参数是一个对象，包含了一些工具函数和属性，详情如下：\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\nexport default {\n  tools: {\n    rspack: (config, { env }) => {\n      if (env === 'development') {\n        config.devtool = 'cheap-module-eval-source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\nexport default {\n  tools: {\n    rspack: (config, { isProd }) => {\n      if (isProd) {\n        config.devtool = 'source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\nexport default {\n  tools: {\n    rspack: (config, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\nexport default {\n  tools: {\n    rspack: (config, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\nexport default {\n  tools: {\n    rspack: (config, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\naddRules#\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 Rspack rules。\n\n示例：\n\nexport default {\n  tools: {\n    rspack: (config, { addRules }) => {\n      // 添加单条规则\n      addRules({\n        test: /\\.foo/,\n        loader: require.resolve('foo-loader'),\n      });\n\n      // 以数组形式添加多条规则\n      addRules([\n        {\n          test: /\\.foo/,\n          loader: require.resolve('foo-loader'),\n        },\n        {\n          test: /\\.bar/,\n          loader: require.resolve('bar-loader'),\n        },\n      ]);\n    },\n  },\n};\n\n\nprependPlugins#\n\n * 类型： (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\n在内部 Rspack 插件数组头部添加额外的插件，数组头部的插件会优先执行。\n\nexport default {\n  tools: {\n    rspack: (config, { prependPlugins }) => {\n      // 添加单个插件\n      prependPlugins(new PluginA());\n\n      // 以数组形式添加多个插件\n      prependPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\nappendPlugins#\n\n * 类型： (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\n在内部 Rspack 插件数组尾部添加额外的插件，数组尾部的插件会在最后执行。\n\nexport default {\n  tools: {\n    rspack: (config, { appendPlugins }) => {\n      // 添加单个插件\n      appendPlugins([new PluginA()]);\n\n      // 以数组形式添加多个插件\n      appendPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\nremovePlugin#\n\n * 类型： (name: string) => void\n\n删除内部的 Rspack 插件，参数为该插件的 constructor.name。\n\n例如，删除内部的 webpack-bundle-analyzer：\n\nexport default {\n  tools: {\n    rspack: (config, { removePlugin }) => {\n      removePlugin('BundleAnalyzerPlugin');\n    },\n  },\n};\n\n\nmergeConfig#\n\n * 类型： (...configs: RspackConfig[]) => RspackConfig\n\n用于合并多份 Rspack 配置，等价于 webpack-merge。\n\nexport default {\n  tools: {\n    rspack: (config, { mergeConfig }) => {\n      return mergeConfig(config, {\n        devtool: 'eval',\n      });\n    },\n  },\n};\n\n\ngetCompiledPath#\n\n * 类型： (name: string) => string\n\n获取 builder 内置依赖的所在路径，例如：\n\n * sass\n * sass-loader\n * less\n * less-loader\n * babel-loader\n * url-loader\n * file-loader\n * ...\n\n该方法通常在需要与 builder 复用同一份依赖时会被用到。\n\nTIP\n\nBuilder 内部依赖会随着版本迭代而发生变化，例如产生大版本变更。在非必要的情况下，请避免使用此 API。\n\nexport default {\n  tools: {\n    rspack: (config, { getCompiledPath }) => {\n      const loaderPath = getCompiledPath('less-loader');\n      // ...\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"rspack"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/rspack.mdx","_relativePath":"zh/configure/app/tools/rspack.mdx"},{"id":489,"title":"tools.sass","routePath":"/configure/app/tools/sass","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":210},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":403},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":689},{"text":"addExcludes","id":"addexcludes","depth":4,"charIndex":696}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.sass。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  // 默认在开发环境下启用 CSS 的 Source Map\n  sourceMap: isDev,\n};\n\n\n你可以通过 tools.sass 修改 sass-loader 的配置。\n\n\nObject 类型#\n\n当 tools.sass 的值为 Object 类型时，会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，sassOptions 会通过\ndeepMerge 进行深层合并。\n\nexport default {\n  tools: {\n    sass: {\n      sourceMap: true,\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当 tools.sass 为 Function\n类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果，第二个参数提供了一些可以直接调用的工具函数：\n\nexport default {\n  tools: {\n    sass(config) {\n      // 修改 sourceMap 配置\n      config.additionalData = async (content, loaderContext) => {\n        // ...\n      };\n    },\n  },\n};\n\n\n\n工具函数#\n\naddExcludes#\n\n * 类型： (excludes: RegExp | RegExp[]) => void\n\n用来指定 sass-loader 不编译哪些文件，你可以传入一个或多个正则表达式来匹配 sass 文件的路径。例如：\n\nexport default {\n  tools: {\n    sass(config, { addExcludes }) {\n      addExcludes(/node_modules/);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"sass"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/sass.mdx","_relativePath":"zh/configure/app/tools/sass.mdx"},{"id":490,"title":"tools.styleLoader","routePath":"/configure/app/tools/style-loader","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":242},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":387}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.styleLoader。\n\n * 类型： Object | Function\n * 默认值： {}\n * 打包工具： 仅支持 webpack\n\n通过 tools.styleLoader 可以设置 style-loader 的配置项。\n\n值得注意的是，Builder 默认不会开启 style-loader，你可以通过 output.disableCssExtract 配置项来开启它。\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。比如：\n\nexport default {\n  tools: {\n    styleLoader: {\n      insert: 'head',\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\nexport default {\n  tools: {\n    styleLoader: config => {\n      config.insert = 'head';\n      return config;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"styleLoader"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/style-loader.mdx","_relativePath":"zh/configure/app/tools/style-loader.mdx"},{"id":491,"title":"tools.styledComponents","routePath":"/configure/app/tools/styled-components","lang":"zh","toc":[],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.styledComponents。\n\n * 类型： Object | Function\n * 默认值：\n\n{\n  displayName: true,\n  // 在 SSR 构建中 isSSR 为 true\n  ssr: isSSR,\n  // 在生产环境构建时启用 `pure` 来优化包体积\n  pure: isProd,\n  transpileTemplateLiterals: true,\n}\n\n\n * 打包工具： 仅支持 webpack\n\n对应 babel-plugin-styled-components 的配置。 值为 Object 类型时，利用 Object.assign\n函数与默认配置合并。比如:\n\nexport default {\n  tools: {\n    styledComponents: {\n      pure: false,\n    },\n  },\n};\n\n\n值为 Function 类型时，第一个参数为默认配置，第二个参数提供了一些可以直接调用的工具函数：\n\nexport default {\n  tools: {\n    styledComponents(config) {\n      // 修改 pure 配置\n      config.pure = false;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"styledComponents"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/styled-components.mdx","_relativePath":"zh/configure/app/tools/styled-components.mdx"},{"id":492,"title":"tools.swc","routePath":"/configure/app/tools/swc","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":36},{"text":"安装","id":"安装","depth":2,"charIndex":331},{"text":"配置项","id":"配置项","depth":2,"charIndex":562}],"domain":"","content":"#\n\n * 类型： Object\n * 默认值： undefined\n\n\n介绍#\n\nSWC (Speedy Web Compiler) 是基于 Rust 语言编写的高性能 JavaScript 和 TypeScript 转译和压缩工具。在\nPolyfill 和语法降级方面可以和 Babel 提供一致的能力，并且性能比 Babel 高出一个数量级。\n\nModern.js Builder 提供了开箱即用的 SWC 插件，可以为你的 Web 应用提供语法降级、Polyfill 以及压缩，并且移植了一些额外常见的\nBabel 插件。\n\nTIP\n\n在使用 Rspack 作为打包工具时，默认会使用 SWC 进行转译和压缩，因此你不需要再安装和配置 SWC 插件。\n\n\n安装#\n\n首先，你需要执行 pnpm run new 启用 SWC 编译：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「SWC 编译」\n\n\n执行完成后，你只需在 modern.config.ts 文件中注册 Modern.js 的 SWC 插件，即可启用 SWC 编译和压缩能力。\n\n\n\n\nexport default defineConfig({\n  plugins: [appTools(), swcPlugin()],\n});\n\n\n\n配置项#\n\n你可以通过 tools.swc 配置项来设置 SWC 编译行为。\n\n\n\nexport default defineConfig({\n  tools: {\n    swc: {\n      jsMinify: {\n        compress: {},\n        mangle: true,\n      },\n    },\n  },\n});\n\n\n完整配置项请参考 Modern.js Builder - SWC 插件配置。","frontmatter":{"sidebar_label":"swc"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/swc.mdx","_relativePath":"zh/configure/app/tools/swc.mdx"},{"id":493,"title":"tools.tailwindcss","routePath":"/configure/app/tools/tailwindcss","lang":"zh","toc":[{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":386},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":608},{"text":"限制","id":"限制","depth":3,"charIndex":904}],"domain":"","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\nconst tailwind = {\n  content: [\n    './config/html/**/*.html',\n    './config/html/**/*.ejs',\n    './config/html/**/*.hbs',\n    './src/**/*.js',\n    './src/**/*.jsx',\n    './src/**/*.ts',\n    './src/**/*.tsx',\n    './storybook/**/*',\n  ],\n  // 使用 source.designSystem 配置作为 Tailwind CSS Theme 配置\n  theme: source.designSystem,\n};\n\n\n对应 TailwindCSS 的配置。\n\n\nFunction 类型#\n\n当 tools.tailwindcss 为 Function 类型时，默认配置会作为第一个参数传入，你可以直接修改配置对象，也可以返回一个值作为最终结果：\n\nexport default {\n  tools: {\n    tailwindcss(config) {\n      config.content.push('./some-folder/**/*.{js,ts}');\n    },\n  },\n};\n\n\n\nObject 类型#\n\n当 tools.tailwindcss 的值为 Object 类型时，会与默认配置通过 Object.assign 浅合并。\n\nexport default {\n  tools: {\n    tailwindcss: {\n      plugins: [\n        require('@tailwindcss/forms'),\n        require('@tailwindcss/aspect-ratio'),\n        require('@tailwindcss/typography'),\n      ],\n    },\n  },\n};\n\n\n\n限制#\n\n注意，该配置中不允许使用 theme 配置项，否则会构建失败。在 Modern.js 中，请使用 source.designSystem 作为 Tailwind\nCSS Theme 配置。\n\n其他配置的使用方式和 Tailwind CSS 一致，请参考 tailwindcss - Configuration。","frontmatter":{"sidebar_label":"tailwindcss"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/tailwindcss.mdx","_relativePath":"zh/configure/app/tools/tailwindcss.mdx"},{"id":494,"title":"tools.terser","routePath":"/configure/app/tools/terser","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":342},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":526}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.terser。\n\n * 类型： Object | Function | undefined\n * 默认值：\n\nconst defaultTerserOptions = {\n  terserOptions: {\n    mangle: {\n      safari10: true,\n    },\n  },\n};\n\n\n * 打包工具： 仅支持 webpack\n\n在生产环境构建时，Builder 会通过 terser-webpack-plugin 对 JavaScript 代码进行压缩优化。可以通过\ntools.terser 修改 terser-webpack-plugin 的配置。\n\n\nObject 类型#\n\n当 tools.terser 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\n例如通过 exclude 排除部分文件的压缩：\n\nexport default {\n  tools: {\n    terser: {\n      exclude: /\\/excludes/,\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当 tools.terser 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\nexport default {\n  tools: {\n    terser: opts => {\n      opts.exclude = /\\/excludes/;\n    },\n  },\n};\n\n\n禁用代码压缩\n\n如果你需要禁用代码压缩，可以使用 output.disableMinimize 配置项。","frontmatter":{"sidebar_label":"terser"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/terser.mdx","_relativePath":"zh/configure/app/tools/terser.mdx"},{"id":495,"title":"tools.tsChecker","routePath":"/configure/app/tools/ts-checker","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":764},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":820}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.tsChecker。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  typescript: {\n    // avoid OOM issue\n    memoryLimit: 8192,\n    // use tsconfig of user project\n    configFile: tsconfigPath,\n    // use typescript of user project\n    typescriptPath: require.resolve('typescript'),\n  },\n  issue: {\n    exclude: [\n      { file: '**/*.(spec|test).ts' },\n      { file: '**/node_modules/**/*' },\n    ],\n  },\n  logger: {\n    log() {\n      // do nothing\n      // we only want to display error messages\n    },\n    error(message: string) {\n      console.error(message.replace(/ERROR/g, 'Type Error'));\n    },\n  },\n},\n\n\n默认情况下，Builder 会开启 fork-ts-checker-webpack-plugin 进行类型检查。你可以通过\noutput.disableTsChecker 配置项来关闭类型检查。\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。","frontmatter":{"sidebar_label":"tsChecker"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/ts-checker.mdx","_relativePath":"zh/configure/app/tools/ts-checker.mdx"},{"id":496,"title":"tools.tsLoader","routePath":"/configure/app/tools/ts-loader","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":238},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":567},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":780},{"text":"addIncludes","id":"addincludes","depth":4,"charIndex":836},{"text":"addExcludes","id":"addexcludes","depth":4,"charIndex":1117}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.tsLoader。\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n项目中默认不开启 ts-loader，当 tools.tsLoader 不为 undefined 则表示开启 ts-loader，同时禁用\nbabel-loader 对 TypeScript 的编译。\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。\n\n默认配置如下:\n\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"ESNext\"\n  },\n  \"transpileOnly\": true,\n  \"allowTsInNodeModules\": true\n}\n\n\n你可以通过 tools.tsLoader 配置项来覆盖默认配置:\n\nexport default {\n  tools: {\n    tsLoader: {\n      allowTsInNodeModules: false,\n    },\n  },\n};\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一参数传入，可以直接修改配置对象，也可以返回一个对象作为最终配置；第二个参数为修改 ts-loader\n配置工具函数集合：\n\nexport default {\n  tools: {\n    tsLoader: opts => {\n      opts.allowTsInNodeModules = false;\n    },\n  },\n};\n\n\n\n工具函数#\n\ntools.tsLoader 的值为 Function 类型时，第二个参数可用的工具函数如下：\n\naddIncludes#\n\n * 类型： (includes: string | RegExp | Array) => void\n\n默认情况下只会编译 src 目录下的业务代码，使用 addIncludes 可以指定 ts-loader 编译 node_modules 下的一些文件。比如:\n\nexport default {\n  tools: {\n    tsLoader: (config, { addIncludes }) => {\n      addIncludes([/node_modules\\/react/]);\n    },\n  },\n};\n\n\naddExcludes#\n\n * 类型： (excludes: string | RegExp | Array) => void\n\n和 addIncludes 相反，指定 ts-loader 编译时排除某些文件。\n\n例如不编译 src/example 目录下的文件：\n\nexport default {\n  tools: {\n    tsLoader: (config, { addExcludes }) => {\n      addExcludes([/src\\/example\\//]);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"tsLoader"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/ts-loader.mdx","_relativePath":"zh/configure/app/tools/ts-loader.mdx"},{"id":497,"title":"tools.webpackChain","routePath":"/configure/app/tools/webpack-chain","lang":"zh","toc":[{"text":"工具集合","id":"工具集合","depth":3,"charIndex":500},{"text":"env","id":"env","depth":4,"charIndex":507},{"text":"isProd","id":"isprod","depth":4,"charIndex":797},{"text":"target","id":"target","depth":4,"charIndex":1015},{"text":"isServer","id":"isserver","depth":4,"charIndex":1253},{"text":"isWebWorker","id":"iswebworker","depth":4,"charIndex":1462},{"text":"webpack","id":"webpack","depth":4,"charIndex":1692},{"text":"HtmlWebpackPlugin","id":"htmlwebpackplugin","depth":4,"charIndex":1915},{"text":"getCompiledPath","id":"getcompiledpath","depth":4,"charIndex":2152},{"text":"CHAIN_ID","id":"chain_id","depth":4,"charIndex":2604},{"text":"CHAIN_ID.ONE_OF","id":"chain_idone_of","depth":3,"charIndex":2996},{"text":"CHAIN_ID.USE","id":"chain_iduse","depth":3,"charIndex":3275},{"text":"CHAIN_ID.PLUGIN","id":"chain_idplugin","depth":3,"charIndex":3998},{"text":"CHAIN_ID.MINIMIZER","id":"chain_idminimizer","depth":3,"charIndex":5376},{"text":"常用 WebpackChain 使用示例","id":"常用-webpackchain-使用示例","depth":3,"charIndex":5623},{"text":"新增/修改/删除 loader","id":"新增/修改/删除-loader","depth":4,"charIndex":5703},{"text":"新增/修改/删除 plugin","id":"新增/修改/删除-plugin","depth":4,"charIndex":6263}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.webpackChain。\n\n * 类型： Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n你可以通过 tools.webpackChain 来修改默认的 webpack 配置，它的值为 Function 类型，接收两个参数：\n\n * 第一个参数为 webpack-chain 对象实例，你可以通过这个实例来修改默认的 webpack 配置。\n * 第二个参数为一个工具集合，包括env、isProd、CHAIN_ID 等。\n\n相比于 tools.webpack，webpack-chain 不仅支持链式调用，而且能够基于别名来定位到内置的 Rule 或\nPlugin，从而实现精准的配置修改。我们推荐使用 tools.webpackChain 来代替 tools.webpack。\n\n> tools.webpackChain 的执行时机早于 tools.webpack，因此会被 tools.webpack 中的修改所覆盖。\n\n\n工具集合#\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\nexport default {\n  tools: {\n    webpackChain: (chain, { env }) => {\n      if (env === 'development') {\n        chain.devtool('cheap-module-eval-source-map');\n      }\n    },\n  },\n};\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\nexport default {\n  tools: {\n    webpackChain: (chain, { isProd }) => {\n      if (isProd) {\n        chain.devtool('source-map');\n      }\n    },\n  },\n};\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\nexport default {\n  tools: {\n    webpackChain: (chain, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n    },\n  },\n};\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\nexport default {\n  tools: {\n    webpackChain: (chain, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n    },\n  },\n};\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\nexport default {\n  tools: {\n    webpackChain: (chain, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n    },\n  },\n};\n\n\nwebpack#\n\n * 类型： typeof import('webpack')\n\n通过这个参数你可以拿到 webpack 实例。比如：\n\nexport default {\n  tools: {\n    webpackChain: (chain, { webpack }) => {\n      chain.plugin('my-progress').use(webpack.ProgressPlugin);\n    },\n  },\n};\n\n\nHtmlWebpackPlugin#\n\n * 类型： typeof import('html-webpack-plugin')\n\n通过这个参数你可以拿到 HtmlWebpackPlugin 实例。\n\nexport default {\n  tools: {\n    webpackChain: (chain, { HtmlWebpackPlugin }) => {\n      console.log(HtmlWebpackPlugin);\n    },\n  },\n};\n\n\ngetCompiledPath#\n\n * 类型： (name: string) => string\n\n获取 builder 内置依赖的所在路径，例如：\n\n * sass\n * sass-loader\n * less\n * less-loader\n * css-loader\n * babel-loader\n * url-loader\n * file-loader\n * ...\n\n该方法通常在需要与 builder 复用同一份依赖时会被用到。\n\nTIP\n\nBuilder 内部依赖会随着版本迭代而发生变化，例如产生大版本变更。在非必要的情况下，请避免使用此 API。\n\nexport default {\n  tools: {\n    webpackChain: (chain, { getCompiledPath }) => {\n      const loaderPath = getCompiledPath('less-loader');\n      // ...\n    },\n  },\n};\n\n\nCHAIN_ID#\n\nBuilder 中预先定义了一些常用的 Chain ID，你可以通过这些 ID 来定位到内置的 Rule 或 Plugin。\n\nCHAIN_ID.RULE#\n\nID           描述\nRULE.MJS     处理 mjs 的规则\nRULE.JS      处理 js 的规则\nRULE.TS      处理 ts 的规则\nRULE.CSS     处理 css 的规则\nRULE.LESS    处理 less 的规则\nRULE.SASS    处理 sass 的规则\nRULE.PUG     处理 pug 的规则\nRULE.TOML    处理 toml 的规则\nRULE.YAML    处理 yaml 的规则\nRULE.FONT    处理字体的规则\nRULE.IMAGE   处理图片的规则\nRULE.MEDIA   处理媒体资源的规则\n\n\nCHAIN_ID.ONE_OF#\n\n通过 ONE_OF.XXX 可以匹配到规则数组中的某一类规则。\n\nID                  描述\nONE_OF.SVG          处理 SVG 的规则，在 data URI 和单独文件之间自动选择\nONE_OF.SVG_URL      处理 SVG 的规则，输出为单独文件\nONE_OF.SVG_INLINE   处理 SVG 的规则，作为 data URI 内联到 bundle 中\nONE_OF.SVG_ASSETS   处理 SVG 的规则，在 data URI 和单独文件之间自动选择\n\n\nCHAIN_ID.USE#\n\n通过 USE.XXX 可以匹配到对应的 loader。\n\nID                     描述\nUSE.TS                 对应 ts-loader\nUSE.CSS                对应 css-loader\nUSE.LESS               对应 less-loader\nUSE.SASS               对应 sass-loader\nUSE.PUG                对应 pug-loader\nUSE.TOML               对应 toml-loader\nUSE.YAML               对应 yaml-loader\nUSE.FILE               对应 file-loader\nUSE.URL                对应 url-loader\nUSE.SVGR               对应 @svgr/webpack\nUSE.BABEL              对应 babel-loader\nUSE.STYLE              对应 style-loader\nUSE.POSTCSS            对应 postcss-loader\nUSE.MARKDOWN           对应 markdown-loader\nUSE.CSS_MODULES_TS     对应 css-modules-typescript-loader\nUSE.MINI_CSS_EXTRACT   对应 mini-css-extract-plugin.loader\n\n\nCHAIN_ID.PLUGIN#\n\n通过 PLUGIN.XXX 可以匹配到对应的 plugin。\n\nID                             描述\nPLUGIN.HMR                     对应 HotModuleReplacementPlugin\nPLUGIN.COPY                    对应 CopyWebpackPlugin\nPLUGIN.HTML                    对应 HtmlWebpackPlugin，使用时需要拼接 entry\n                               名称：${PLUGIN.HTML}-${entryName}\nPLUGIN.DEFINE                  对应 DefinePlugin\nPLUGIN.IGNORE                  对应 IgnorePlugin\nPLUGIN.BANNER                  对应 BannerPlugin\nPLUGIN.PROGRESS                对应 Webpackbar\nPLUGIN.APP_ICON                对应 AppIconPlugin\nPLUGIN.LOADABLE                对应 LoadableWebpackPlugin\nPLUGIN.MANIFEST                对应 WebpackManifestPlugin\nPLUGIN.TS_CHECKER              对应 ForkTsCheckerWebpackPlugin\nPLUGIN.INLINE_HTML             对应 InlineChunkHtmlPlugin\nPLUGIN.BUNDLE_ANALYZER         对应 WebpackBundleAnalyzer\nPLUGIN.BOTTOM_TEMPLATE         对应 BottomTemplatePlugin\nPLUGIN.MINI_CSS_EXTRACT        对应 MiniCssExtractPlugin\nPLUGIN.REACT_FAST_REFRESH      对应 ReactFastRefreshPlugin\nPLUGIN.NODE_POLYFILL_PROVIDE   对应处理 node polyfill 的 ProvidePlugin\nPLUGIN.INSPECTOR               对应 @modern-js/inspector-webpack-plugin\nPLUGIN.SUBRESOURCE_INTEGRITY   对应 webpack-subresource-integrity\nPLUGIN.ASSETS_RETRY            对应 Builder 中的 webpack 静态资源重试插件 WebpackAssetsRetryPlugin\nPLUGIN.AUTO_SET_ROOT_SIZE      对应 Builder 中的自动设置根字体大小插件 AutoSetRootSizePlugin\n\n\nCHAIN_ID.MINIMIZER#\n\n通过 MINIMIZER.XXX 可以匹配到对应的压缩工具。\n\nID                  描述\nMINIMIZER.JS        对应 TerserWebpackPlugin\nMINIMIZER.CSS       对应 CssMinimizerWebpackPlugin\nMINIMIZER.ESBUILD   对应 ESBuildPlugin\nMINIMIZER.SWC       对应 SwcWebpackPlugin\n\n\n常用 WebpackChain 使用示例#\n\n以下是一些常见的配置示例，完整的 webpack-chain API 请见 webpack-chain 文档。\n\n新增/修改/删除 loader#\n\nexport default {\n  tools: {\n    webpackChain: (chain, { CHAIN_ID }) => {\n      // 新增 loader\n      chain.module\n        .rule('md')\n        .test(/\\.md$/)\n        .use('md-loader')\n        .loader('md-loader');\n\n      // 修改 loader\n      chain.module\n        .rule(CHAIN_ID.RULE.JS)\n        .use(CHAIN_ID.USE.BABEL)\n        .tap(options => {\n          options.plugins.push('babel-plugin-xxx');\n          return options;\n        });\n\n      // 删除 loader\n      chain.module.rule(CHAIN_ID.RULE.JS).uses.delete(CHAIN_ID.USE.BABEL);\n    },\n  },\n};\n\n\n新增/修改/删除 plugin#\n\nexport default {\n  tools: {\n    webpackChain: (chain, { webpack, CHAIN_ID }) => {\n      // 新增插件\n      chain.plugin('custom-define').use(webpack.DefinePlugin, [\n        {\n          'process.env': {\n            NODE_ENV: JSON.stringify(process.env.NODE_ENV),\n          },\n        },\n      ]);\n\n      // 修改插件\n      chain.plugin(CHAIN_ID.PLUGIN.HMR).tap(options => {\n        options[0].fullBuildTimeout = 200;\n        return options;\n      });\n\n      // 删除插件\n      chain.plugins.delete(CHAIN_ID.PLUGIN.HMR);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"webpackChain"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/webpack-chain.mdx","_relativePath":"zh/configure/app/tools/webpack-chain.mdx"},{"id":498,"title":"tools.webpack","routePath":"/configure/app/tools/webpack","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":245},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":498},{"text":"工具集合","id":"工具集合","depth":3,"charIndex":809},{"text":"env","id":"env","depth":4,"charIndex":852},{"text":"isProd","id":"isprod","depth":4,"charIndex":1161},{"text":"target","id":"target","depth":4,"charIndex":1398},{"text":"isServer","id":"isserver","depth":4,"charIndex":1653},{"text":"isWebWorker","id":"iswebworker","depth":4,"charIndex":1879},{"text":"webpack","id":"webpack","depth":4,"charIndex":2126},{"text":"HtmlWebpackPlugin","id":"htmlwebpackplugin","depth":4,"charIndex":2360},{"text":"addRules","id":"addrules","depth":4,"charIndex":2597},{"text":"prependPlugins","id":"prependplugins","depth":4,"charIndex":3126},{"text":"appendPlugins","id":"appendplugins","depth":4,"charIndex":3564},{"text":"removePlugin","id":"removeplugin","depth":4,"charIndex":4001},{"text":"mergeConfig","id":"mergeconfig","depth":4,"charIndex":4273},{"text":"getCompiledPath","id":"getcompiledpath","depth":4,"charIndex":4539}],"domain":"","content":"#\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.webpack。\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\ntools.webpack 选项用于配置原生的 webpack。\n\n> tools.webpackChain 同样可以修改 webpack 配置，并且功能更加强大，建议优先使用 tools.webpackChain。\n\n\nObject 类型#\n\ntools.webpack 可以配置为一个对象，这个对象将会和内置的 webpack 配置通过 webpack-merge 进行深层合并。\n\n比如添加 resolve.alias 配置：\n\nexport default {\n  tools: {\n    webpack: {\n      resolve: {\n        alias: {\n          '@util': 'src/util',\n        },\n      },\n    },\n  },\n};\n\n\n\nFunction 类型#\n\ntools.webpack 也可以配置为一个函数，这个函数的第一个入参为内置的 webpack 配置对象，你可以对这个对象进行修改，然后返回一份新的配置。比如：\n\nexport default {\n  tools: {\n    webpack: config => {\n      config.resolve.alias['@util'] = 'src/util';\n      return config;\n    },\n  },\n};\n\n\nTIP\n\ntools.webpack 函数返回的对象会直接作为最终使用的 webpack 配置，不会再与内置的 webpack 配置进行合并。\n\n\n工具集合#\n\n这个函数的第二个参数是一个对象，包含了一些工具函数和属性，详情如下：\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\nexport default {\n  tools: {\n    webpack: (config, { env }) => {\n      if (env === 'development') {\n        config.devtool = 'cheap-module-eval-source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\nexport default {\n  tools: {\n    webpack: (config, { isProd }) => {\n      if (isProd) {\n        config.devtool = 'source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\nexport default {\n  tools: {\n    webpack: (config, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\nexport default {\n  tools: {\n    webpack: (config, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\nexport default {\n  tools: {\n    webpack: (config, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nwebpack#\n\n * 类型： typeof import('webpack')\n\n通过这个参数你可以拿到 webpack 实例。比如：\n\nexport default {\n  tools: {\n    webpack: (config, { webpack }) => {\n      config.plugins.push(new webpack.ProgressPlugin());\n      return config;\n    },\n  },\n};\n\n\nHtmlWebpackPlugin#\n\n * 类型： typeof import('html-webpack-plugin')\n\n通过这个参数你可以拿到 HtmlWebpackPlugin 实例。\n\nexport default {\n  tools: {\n    webpackChain: (chain, { HtmlWebpackPlugin }) => {\n      console.log(HtmlWebpackPlugin);\n    },\n  },\n};\n\n\naddRules#\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 webpack rules。\n\n示例：\n\nexport default {\n  tools: {\n    webpack: (config, { addRules }) => {\n      // 添加单条规则\n      addRules({\n        test: /\\.foo/,\n        loader: require.resolve('foo-loader'),\n      });\n\n      // 以数组形式添加多条规则\n      addRules([\n        {\n          test: /\\.foo/,\n          loader: require.resolve('foo-loader'),\n        },\n        {\n          test: /\\.bar/,\n          loader: require.resolve('bar-loader'),\n        },\n      ]);\n    },\n  },\n};\n\n\nprependPlugins#\n\n * 类型： (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\n在内部 webpack 插件数组头部添加额外的插件，数组头部的插件会优先执行。\n\nexport default {\n  tools: {\n    webpack: (config, { prependPlugins, webpack }) => {\n      // 添加单个插件\n      prependPlugins(\n        new webpack.BannerPlugin({\n          banner: 'hello world!',\n        }),\n      );\n\n      // 以数组形式添加多个插件\n      prependPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\nappendPlugins#\n\n * 类型： (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\n在内部 webpack 插件数组尾部添加额外的插件，数组尾部的插件会在最后执行。\n\nexport default {\n  tools: {\n    webpack: (config, { appendPlugins, webpack }) => {\n      // 添加单个插件\n      appendPlugins([\n        new webpack.BannerPlugin({\n          banner: 'hello world!',\n        }),\n      ]);\n\n      // 以数组形式添加多个插件\n      appendPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\nremovePlugin#\n\n * 类型： (name: string) => void\n\n删除内部的 webpack 插件，参数为该插件的 constructor.name。\n\n例如，删除内部的 fork-ts-checker-webpack-plugin：\n\nexport default {\n  tools: {\n    webpack: (config, { removePlugin }) => {\n      removePlugin('ForkTsCheckerWebpackPlugin');\n    },\n  },\n};\n\n\nmergeConfig#\n\n * 类型： (...configs: WebpackConfig[]) => WebpackConfig\n\n用于合并多份 webpack 配置，等价于 webpack-merge。\n\nexport default {\n  tools: {\n    webpack: (config, { mergeConfig }) => {\n      return mergeConfig(config, {\n        devtool: 'eval',\n      });\n    },\n  },\n};\n\n\ngetCompiledPath#\n\n * 类型： (name: string) => string\n\n获取 builder 内置依赖的所在路径，等价于 webpackChain#getCompiledPath。","frontmatter":{"sidebar_label":"webpack"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/tools/webpack.mdx","_relativePath":"zh/configure/app/tools/webpack.mdx"},{"id":499,"title":"配置使用","routePath":"/configure/app/usage","lang":"zh","toc":[{"text":"在配置文件中配置","id":"在配置文件中配置","depth":2,"charIndex":311},{"text":"modern.config.ts（推荐）","id":"modernconfigts（推荐）","depth":3,"charIndex":435},{"text":"modern.config.js","id":"modernconfigjs","depth":3,"charIndex":871},{"text":"导出配置函数","id":"导出配置函数","depth":3,"charIndex":1169},{"text":"导出异步函数","id":"导出异步函数","depth":3,"charIndex":1662},{"text":"指定配置文件","id":"指定配置文件","depth":3,"charIndex":1885},{"text":"在 package.json 中配置（不推荐）","id":"在-packagejson-中配置（不推荐）","depth":2,"charIndex":2191},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":2481},{"text":"本地调试配置","id":"本地调试配置","depth":2,"charIndex":2634},{"text":"示例","id":"示例","depth":3,"charIndex":2752},{"text":"注意事项","id":"注意事项-1","depth":3,"charIndex":3159},{"text":"合并多份配置","id":"合并多份配置","depth":2,"charIndex":3578},{"text":"示例","id":"示例-1","depth":3,"charIndex":3751},{"text":"配置类型定义","id":"配置类型定义","depth":2,"charIndex":4204}],"domain":"","content":"#\n\nModern.js 中有两种配置，分别是编译时配置和服务端运行时配置。\n\n编译时配置可以在两个位置进行配置：\n\n * 根路径下的 modern.config.(ts|js|mjs) 文件\n * package.json 文件\n\nINFO\n\nModern.js 不支持同时在 package.json 中和 modern.config.ts 中配置同一个配置项，推荐在 modern.config.ts\n中进行配置。如果 Modern.js 检测到重复配置导致的冲突，将会抛出警告。\n\n服务端运行时配置可以在根路径下的 modern.server-runtime.config.(ts|js|mjs) 中进行配置。\n\n\n在配置文件中配置#\n\nModern.js 的配置文件定义在项目的根目录下，支持 .ts, .js 和 .mjs 格式：\n\n * modern.config.ts\n * modern.config.js\n * modern.config.mjs\n\n\nmodern.config.ts（推荐）#\n\n我们推荐使用 .ts 格式的配置文件，它提供了友好的 TypeScript 类型提示，从而帮助你避免配置中的错误。\n\n从 @modern-js/app-tools 中导入 defineConfig 工具函数, 它会帮助你进行配置的类型推导和类型补全：\n\n\n\nexport default defineConfig({\n  source: {\n    alias: {\n      '@common': './src/common',\n    },\n  },\n});\n\n\n当你使用 Rspack 作为打包工具时，由于 webpack 和 Rspack 的配置类型存在一些差异，需要为 defineConfig 指定\n<'rspack'> 泛型：\n\n- export default defineConfig({\n+ export default defineConfig<'rspack'>({\n  // ...\n});\n\n\n\nmodern.config.js#\n\n如果你在开发一个非 TypeScript 项目，可以使用 .js 格式的配置文件：\n\nexport default {\n  source: {\n    alias: opts => {\n      opts['@common'] = './src/common';\n    },\n  },\n};\n\n\n你也可以通过 process.env.NODE_ENV，根据环境做不同配置：\n\nexport default {\n  server: {\n    ssr: process.env.NODE_ENV === 'development',\n  },\n};\n\n\n\n导出配置函数#\n\nModern.js 支持在配置文件中导出一个函数，你可以在函数中动态计算配置，并返回给 Modern.js。\n\n\n\nexport default defineConfig(({ env, command }) => ({\n  source: {\n    alias: {\n      '@foo': env === 'development' ? './src/foo.dev.ts' : './src/foo.prod.ts',\n    },\n  },\n}));\n\n\n该函数接受以下入参：\n\n * env：对应 process.env.NODE_ENV 的值。\n   * 当运行 modern dev 或 modern start 时，env 的值为 development。\n   * 当运行 modern build 或 modern serve 时，env 的值为 production。\n   * 当运行 modern test 时，env 的值为 test。\n * command：对应当前运行的命令，如 dev、start、build、serve。\n\n\n导出异步函数#\n\nModern.js 也支持在配置文件中导出一个异步函数，你可以在函数中进行一些异步操作：\n\n\n\nexport default defineConfig(async ({ env, command }) => {\n  const result = await someAsyncFunction();\n\n  return {\n    html: {\n      title: result,\n    },\n  };\n});\n\n\n\n指定配置文件#\n\nModern.js 命令行支持通过 --config 选项来指定配置文件的名称。\n\n例如，你需要在执行 build 命令时使用 modern.prod.config.ts 文件，可以在 package.json 中添加如下配置：\n\n{\n  \"scripts\": {\n    \"dev\": \"modern modern\",\n    \"build\": \"modern build --config modern.prod.config.ts\"\n  }\n}\n\n\n你也可以将 --config 选项缩写为 -c：\n\n$ modern build -c modern.prod.config.js\n\n\n\n在 package.json 中配置（不推荐）#\n\n除了配置文件外，你也可以在 package.json 中的 modernConfig 字段下设置配置项，如：\n\n{\n  \"modernConfig\": {\n    \"source\": {\n      \"alias\": {\n        \"@common\": \"./src/common\"\n      }\n    }\n  }\n}\n\n\n由于 JSON 文件格式的限制，package.json 中只能定义数字、字符串、布尔值、数组等简单类型的值，当我们需要设置函数类型的值时，建议在\nModern.js 配置文件中进行设置。\n\n\n注意事项#\n\n * 不建议同时使用 package.json 和 modern.config.js 进行配置。如果同时使用了两者并出现配置冲突，Modern.js\n   会在命令行进行提示错误。\n * @modern-js/runtime 导出了同名的 defineConfig API，请注意区分。\n\n\n本地调试配置#\n\n为了便于本地调试配置，Modern.js 支持在项目根目录下创建 modern.config.local.(ts|js|mjs) 文件，用于覆盖\nmodern.config.(ts|js|mjs) 中的配置选项。\n\n\n示例#\n\n比如，项目的 modern.config.ts 中配置了端口号为 3000:\n\n\n\nexport default defineConfig({\n  server: {\n    port: 3000,\n  },\n});\n\n\n如果你在本地调试时需要将端口号修改为 3001，但是又不希望修改当前项目的 modern.config.ts 文件，那么可以创建一个\nmodern.config.local.ts 文件，并添加以下配置：\n\n\n\nexport default defineConfig({\n  server: {\n    port: 3001,\n  },\n});\n\n\nmodern.config.local.ts 文件中的配置会与 modern.config.ts 中的配置进行深层合并，并覆盖 modern.config.ts\n中的配置选项，因此 server.port 会被覆盖为 3001。\n\n\n注意事项#\n\n在使用 modern.config.local.ts 时，请注意以下事项：\n\n * modern.config.local.ts 文件仅会在执行 modern dev 或 modern start 命令时被加载，当执行 modern\n   build 时不会被加载。\n * modern.config.local.ts 文件的优先级不仅高于 modern.config.ts，也高于 package.json 中的\n   modernConfig 字段。\n * 由于 modern.config.local.ts 仅在本地调试时使用，因此不建议将其提交到代码仓库中，请确保项目的 .gitignore 文件中包含\n   modern.config.local.ts 等文件。\n\nmodern.config.local.ts\nmodern.config.local.js\nmodern.config.local.mjs\n\n\n\n合并多份配置#\n\n在某些情况下，你可能需要将多份配置合并为一份配置，此时你可以使用 mergeConfig 工具函数来合并多个配置。\n\nmergeConfig 函数接受一个数组作为参数，数组中的每一项都是一个配置对象，mergeConfig\n会将数组中的每一项配置对象进行深层合并，自动将多个函数项合并为数组，最终返回一个合并后的配置对象。\n\n\n示例#\n\n\n\nconst config1 = {\n  dev: {\n    port: 3000,\n  },\n  tools: {\n    postcss: () => console.log('config1');\n  },\n};\nconst config2 = {\n  dev: {\n    port: 3001,\n  },\n  tools: {\n    postcss: () => console.log('config2');\n  },\n};\n\nconst mergedConfig = mergeConfig([config1, config2]);\n\n\n在以上示例中，合并后的配置对象为：\n\nconst mergedConfig = {\n  dev: {\n    port: 3001,\n  },\n  tools: {\n    postcss: [() => console.log('config1'), () => console.log('config2')],\n  },\n};\n\n\n\n配置类型定义#\n\nModern.js 导出了 AppUserConfig 类型，对应 Modern.js 配置对象的类型：\n\n\n\nconst config: AppUserConfig = {\n  tools: {\n    webpack: {},\n  },\n};\n\n\n当你使用 Rspack 作为打包工具时，由于 webpack 和 Rspack 的配置类型存在一些差异，需要为 AppUserConfig 指定\n<'rspack'> 泛型：\n\n\n\nconst config: AppUserConfig<'rspack'> = {\n  tools: {\n    rspack: {},\n  },\n};\n","frontmatter":{"sidebar_position":0},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/configure/app/usage.mdx","_relativePath":"zh/configure/app/usage.mdx"},{"id":500,"title":"使用 BFF 代理","routePath":"/guides/advanced-features/bff/bff-proxy","lang":"zh","toc":[],"domain":"","content":"#\n\n通过配置 BFF 代理，无需手动写码，即可对 API 请求进行转发。\n\nCAUTION\n\n使用 BFF 代理需确保请求能进入 BFF handler。（例如请求路径必须包含 bff prefix）\n\n在 modern.server-runtime.config.js 文件中编写以下 BFF 代理配置，会将发送到\nhttp://localhost:8080/api/v1/topics 的请求代理到 https://cnodejs.org/api/v1/topics。\n\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api/v1/topics': 'https://cnodejs.org',\n    },\n  },\n};\n\n\nNOTE\n\n详细 API 请查看 BFF 代理。更多 Modern.js 代理的能力可查看调试代理。","frontmatter":{"sidebar_position":5,"title":"使用 BFF 代理"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/bff/bff-proxy.mdx","_relativePath":"zh/guides/advanced-features/bff/bff-proxy.mdx"},{"id":501,"title":"运行时框架","routePath":"/guides/advanced-features/bff/frameworks","lang":"zh","toc":[{"text":"函数写法","id":"函数写法","depth":2,"charIndex":81},{"text":"框架写法","id":"框架写法","depth":2,"charIndex":1500},{"text":"Express","id":"express","depth":3,"charIndex":1561},{"text":"Koa","id":"koa","depth":3,"charIndex":1958}],"domain":"","content":"#\n\nModern.js 的 BFF 支持不同的运行时框架，当前 Modern.js 的 BFF 支持两种运行时框架 Express.js 和 Koa.js。\n\n\n函数写法#\n\n在函数写法下，各类运行时框架仅中间件写法存在差异，其他实现基本相同。这里以 Express 为例，介绍如何在 api/_app.ts\n中，手写一个中间件，添加权限校验：\n\n\n\n\nexport default hook(({ addMiddleware }) => {\n  addMiddleware(async (req: Request, res: Response, next: NextFunction) => {\n    if (req.url !== '/api/login') {\n      const sid = req?.cookies?.sid;\n      if (!sid) {\n        res.status(400);\n        res.json({ code: -1, message: 'need login' });\n      } else {\n        next();\n      }\n    } else {\n      next();\n    }\n  });\n});\n\n\n然后添加一个普通的 BFF 函数 /api/hello.ts：\n\nexport default async () => {\n  return 'Hello Modern.js';\n};\n\n\n最后在前端 src/App.tsx 添加接口的访问代码，直接使用一体化的方式调用：\n\n\n\n\nexport default () => {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    async function fetchMyApi() {\n      const { message } = await hello();\n      setText(message);\n    }\n\n    fetchMyApi();\n  }, []);\n\n  return \n\n{text};\n};\n\n\n然后 pnpm run dev 启动项目，访问 http://localhost:8080/ 会发现 /api/hello 的请求被拦截了：\n\n\n\n最后再修改前端代码 src/App.tsx，在访问 /api/hello 前先调用登录接口：\n\n\n\n\n\nexport default () => {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    async function fetchAfterLogin() {\n      const { code } = await login();\n      if (code === 0) {\n        const { message } = await hello();\n        setText(message);\n      }\n    }\n    fetchAfterLogin();\n  }, []);\n\n  return \n\n{text};\n};\n\n\n刷新页面，可以看到 /api/hello 访问成功：\n\n\n\n以上代码模拟了在 /api/_app.ts 中添加中间件的方式，实现了简易的登录功能。同样，可以在这个钩子文件中实现其他功能来扩展 BFF Server。\n\n\n框架写法#\n\n框架写法下，Modern.js 不会收集 api/_app.ts 中的中间件，运行流程由插件自行控制。\n\n\nExpress#\n\nExpress 的框架写法支持可在 api/app.[tj]s 定义 API Server\n的启动逻辑，执行应用的初始化工作，添加全局中间件，声明路由，甚至扩展原有框架等。\n\nBFF 函数定义的路由会在 app.ts 文件定义的路由之后注册，所以在这里你也可以拦截 BFF 函数定义的路由，进行预处理或是提前响应。\n\n\n\nconst app = express();\n\napp.put('/user', function (req, res) {\n  res.send('Got a PUT request at /user');\n});\n\napp.use(async (req, res, next) => {\n  console.info(`access url: ${req.url}`);\n  next();\n});\n\nexport default app;\n\n\n\nKoa#\n\nKoa 框架写法与 Express 类似，支持在 app.[tj]s 定义 API Server\n的启动逻辑，执行应用的初始化工作，添加全局中间件，声明路由，扩展原有框架等。\n\nBFF 函数定义的路由会在 app.ts 文件定义的路由之后注册，所以在这里你也可以拦截 BFF 函数定义的路由，进行预处理或是提前响应。\n\n注意\n\n在框架写法下，当没有 app.ts 的时候，Modern.js 默认会添加 koa-body；当有 app.ts 时，如果开发者希望使用带有 Body 的\nBFF 函数，需要确保 koa-body 中间件已经添加。\n\n\n\nconst app = new Koa();\n\napp.put('/user', function (req, res) {\n  res.send('Got a PUT request at /user');\n});\n\napp.use(async (ctx, next) => {\n  console.info(`access url: ${ctx.url}`);\n  await next();\n});\n\nexport default app;\n","frontmatter":{"sidebar_position":3,"title":"运行时框架"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/bff/frameworks.mdx","_relativePath":"zh/guides/advanced-features/bff/frameworks.mdx"},{"id":502,"title":"基础用法","routePath":"/guides/advanced-features/bff/function","lang":"zh","toc":[{"text":"启用 BFF","id":"启用-bff","depth":2,"charIndex":87},{"text":"BFF 函数","id":"bff-函数","depth":2,"charIndex":172},{"text":"函数路由","id":"函数路由","depth":2,"charIndex":781},{"text":"默认路由","id":"默认路由","depth":3,"charIndex":1023},{"text":"多层路由","id":"多层路由","depth":3,"charIndex":1131},{"text":"动态路由","id":"动态路由","depth":3,"charIndex":1256},{"text":"白名单","id":"白名单","depth":3,"charIndex":1462},{"text":"RESTful API","id":"restful-api","depth":2,"charIndex":1677},{"text":"函数具名导出","id":"函数具名导出","depth":3,"charIndex":1926},{"text":"函数参数规则","id":"函数参数规则","depth":3,"charIndex":2566},{"text":"Dynamic Path","id":"dynamic-path","depth":4,"charIndex":2682},{"text":"RequestOption","id":"requestoption","depth":4,"charIndex":3079}],"domain":"","content":"#\n\n通过 Modern.js 开发的应用，可以在 api/\n目录下定义接口函数，前端可以调用这些接口函数，即可发起请求，无需写前后端胶水层代码，同时保证前后端类型安全。\n\n\n启用 BFF#\n\n 1. 执行 pnpm new，选择启用 BFF\n\n 2. 根据选择的运行时框架，将下面的代码添加到 modern.config.[tj]s 中：\n\n\nBFF 函数#\n\n允许通过一体化调用的函数，称为 BFF 函数。这里写一个最简单的 BFF 函数，创建 api/hello.ts 文件：\n\nCAUTION\n\n如果是框架模式（有 api/lambda 目录），需要创建 api/lambda/hello.ts\n\nexport const get = async () => 'Hello Modern.js';\n\n\n接着在 src/App.tsx 中直接引入函数并调用：\n\n\n\n\nexport default () => {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    hello().then(setText);\n  }, []);\n  return \n{text};\n};\n\n\nINFO\n\nModern.js 生成器已经在 tsconfig.json 中配置 @api 别名，因此可以直接通过别名的方式引入函数。\n\n在 src/App.tsx 中引入的函数，会自动转换成接口调用，不需要再去通过 fetch 去调用接口。\n\n执行 pnpm run dev 打开 http://localhost:8080/ 可以看到页面已经展示了 BFF 函数返回的内容，在 Network\n中可以看到页面向 http://localhost:8080/api/hello 发送了请求：\n\n\n\n\n函数路由#\n\nModern.js 中，BFF 函数对应的路由系统是基于文件系统实现的，也是一种约定式路由。\n\n函数写法下 api/ 下的所有文件中的每个 BFF 函数都会映射为一个接口。框架写法下 api/lambda 下的所有文件中的每个 BFF\n函数都会映射为一个接口。\n\nNOTE\n\n函数写法和框架写法会在下一节详细介绍。\n\n所有 BFF 函数生成的路由都带有统一的前缀，默认值为 /api。可以通过 bff.prefix 设置公共路由的前缀。\n\n下面介绍几种路由的约定。\n\n\n默认路由#\n\n以 index.[jt]s 命名的文件会被映射到上一层目录。\n\n * api/index.ts -> {prefix}/\n * api/user/index.ts -> {prefix}/user\n\n\n多层路由#\n\n支持解析嵌套的文件，如果创建嵌套文件夹结构，文件仍会以相同方式自动解析路由。\n\n * api/hello.ts -> {prefix}/hello\n * api/user/list.ts -> {prefix}/user/list\n\n\n动态路由#\n\n同样的，创建命名带有 [xxx] 的文件夹或者文件，支持动态的命名路由参数。动态路由的函数参数规则可以看 dynamac-path\n\n * api/user/[username]/info.ts -> {prefix}/user/:username/info\n * api/user/username/[action].ts -> {prefix}/user/username/:action\n\n\n白名单#\n\n默认 api/ 目录下所有文件都会当作 BFF 函数文件去解析，但以下文件不会被解析：\n\n * 命名以 _ 开头的文件。例如：_utils.ts。\n * 命名以 _ 开头的文件夹下所有文件。例如：_utils/index.ts、_utils/cp.ts。\n * 测试文件。例如：foo.test.ts。\n * TypeScript 类型文件。例如：hello.d.ts。\n * node_module 下的文件。\n\n\nRESTful API#\n\nModern.js 的 BFF 函数需要遵循 RESTful API 标准来定义, 遵循 HTTP Method 规范，并且不允许自由定义参数。\n\nINFO\n\n假设函数允许自由定义参数，产出的路由必然由私有协议进行调用（原因是无法区分请求参数与请求体），而无法实现任意的 RESTful API。\n\n如果服务仅用于应用本身不存在问题，但它不标准的接口定义无法融入更大的体系。 在多个系统共同工作的情况下（例如 BFF\n低码搭建），会导致其他系统也需要遵循私有协议。\n\n\n函数具名导出#\n\nModern.js BFF 函数的导出名决定了函数对应接口的 Method，如 get，post 等。\n\n例如，按照以下例子，可导出一个 GET 接口。\n\nexport const get = async () => {\n  return {\n    name: 'Modern.js',\n    desc: '现代 web 工程方案',\n  };\n};\n\n\n按照以下例子，则可导出一个 POST 接口\n\nexport const post = async () => {\n  return {\n    name: 'Modern.js',\n    desc: '现代 web 工程方案',\n  };\n};\n\n\n * 对应 HTTP Method，Modern.js 也支持了 9\n   种定义，即：GET、POST、PUT、DELETE、CONNECT、TRACE、PATCH、OPTIONS、HEAD，即可以用这些 Method\n   作为函数导出的名字。\n\n * 名字是大小不敏感的，如果是 GET，写成 get、Get、GEt、GET，都可以准确识别。而默认导出，即 export default xxx\n   则会被映射为 Get。\n\n * 可以在一个文件中定义多个不同 Method 的函数，但如果定义多个相同 Method 的函数，则只有第一个会生效。\n\nINFO\n\n需要注意的是，定义的函数都应该是异步的，与函数调用时类型有关，后面会提到。\n\n\n函数参数规则#\n\n如上所述，为了满足 RESTful API 的设计标准，因此 Modern.js 中 BFF 函数需要遵循一定的入参规则。\n\n函数参数分为两块，分别是请求路径中的动态部分和请求选项 RequestOption。\n\nDynamic Path#\n\n动态路由会作为函数第一部分的入参，每个入参对应一段动态路由。例如以下示例，uid 会作为前两个参数传递到函数中：\n\nexport default async (level: number, id: number) => {\n  const userData = await queryUser(level, uid);\n  return userData;\n};\n\n\n在调用时直接传入动态参数：\n\n\n\n\nexport default () => {\n  const [name, setName] = useState('');\n\n  useEffect(() => {\n    getUser(6, 001).then(userData => setName(userData.name));\n  }, []);\n\n  return \n{name};\n};\n\n\nRequestOption#\n\nDynamic Path 之后的参数是包含 querystring、request body 的对象 RequestOption，这个字段用来定义 data 和\nquery 的类型。\n\n在不存在动态路由的普通函数中，可以从第一个入参中获取传入的 data 和 query，例如：\n\n\n\nexport async function post({\n  query,\n  data,\n}: RequestOption, Record>) {\n  // do somethings\n}\n\n\n这里你也可以使用自定义类型：\n\n\n\ntype IQuery = {\n  // some types\n};\ntype IData = {\n  // some types\n};\n\nexport async function post({ query, data }: { query: IQuery; data: IData }) {\n  // do somethings\n}\n\n\n当函数文件使用动态路由规则时，动态路由会在 RequestOption 对象参数前。\n\nexport async function post(\n  sku: string,\n  id: string,\n  {\n    data,\n    query,\n  }: RequestOption, Record>,\n) {\n  // do somethings\n}\n\n\n调用时也按照函数定义，传入对应的参数即可：\n\n\n\nexport default () => {\n  const addSku = () => {\n    post('0001' /* sku */, '1234' /* id */, {\n      query: {\n        /* ... */\n      },\n      data: {\n        /* ... */\n      },\n    });\n  };\n\n  return \n添加 SKU;\n};\n\n\n之前提到，定义的函数都应该是异步的，是因为在前端调用时会自动转换成 HTTP 接口调用，所以为了保持类型定义与实际调用体验统一，需要在定义 BFF\n函数时将它设置为异步。","frontmatter":{"sidebar_position":1,"title":"基础用法"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/bff/function.mdx","_relativePath":"zh/guides/advanced-features/bff/function.mdx"},{"id":503,"title":"BFF","routePath":"/guides/advanced-features/bff/","lang":"zh","toc":[],"domain":"","content":"#\n\n在前后端分离概念出现后一段时间发展中，前端部分能够做的事越来越多，前端需要一些面向 UI 的数据接口，因此业界引入了 BFF（Backends for\nFrontends）这一概念。\n\n它主要为了解决的问题包括：\n\n * 根据自身业务需求，对更底层 API 的聚合、映射、裁剪、代理。\n * 对一些特定场景的数据进行缓存，提高性能，进而提升用户体验。\n * 根据已有接口快速开发新产品。\n * 与第三方系统对接，例如登陆鉴权。\n\nModern.js 官方支持了 BFF，并提供了一体化 BFF 方案来进一步强化 BFF 能力，主要包括以下能力：\n\n * 快速开发调试上线，在同一项目中运行、构建、部署 BFF 代码。\n * 极简的纯函数调用，在前端直接 import BFF 函数，调用时能自动转换成 HTTP 请求。\n * 无私有协议，遵循 RESTful API 规范，所有 BFF 接口都是标准化的。\n * 完善的 TypeScript 支持。\n * 满足用户使用偏好，支持多框架扩展写法。","frontmatter":{"title":"BFF"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/bff/index.mdx","_relativePath":"zh/guides/advanced-features/bff/index.mdx"},{"id":504,"title":"函数写法 & 框架写法","routePath":"/guides/advanced-features/bff/type","lang":"zh","toc":[{"text":"函数写法","id":"函数写法","depth":2,"charIndex":198},{"text":"框架写法","id":"框架写法","depth":2,"charIndex":435}],"domain":"","content":"#\n\n运行时框架支持也是 BFF 中重要的一环。Modern.js 支持通过插件扩展 BFF\n的运行时框架，并提供了一系列内置插件，开发者可以直接使用对应框架的约定和生态。\n\n插件中兼容了这些框架大部分的规范，每一种框架都需要提供两类扩展写法 BFF 函数的方式，分别是函数写法和框架写法。\n\nNOTE\n\n当前 api/ 目录结构是否为框架写法由对应的插件决定，Modern.js 并不关心。\n\n\n函数写法#\n\n当插件认为当前为函数写法时，必须支持在 api/_app.ts 中编写中间件，用来扩展 BFF 函数。\n\nModern.js 会收集 api/_app.ts 中的中间件，并传递给插件，由插件将中间件注入运行时，例如：\n\n\n\nexport default hook(({ addMiddleware }) => {\n  addMiddleware(myMiddleware);\n});\n\n\nNOTE\n\n不同插件的中间件的写法不一定相同，详情可见运行时框架。\n\n\n框架写法#\n\n框架写法是一种使用框架结构来扩展 BFF 函数的方式。和函数写法相比，框架写法虽然能够利用更多框架的结构，在复杂场景下让整个 BFF Server\n更加清晰，但也相的更加复杂，需要关心更多框架层面的内容。\n\n框架写法中，所有的 BFF 函数都需要写在 api/lambda/ 目录下，并且无法使用钩子文件 _app.[tj]s。\n\n多数情况下，函数写法就能覆盖大多数 BFF 函数的定制需求。只有当你的项目服务端逻辑比较复杂，代码需要分层，或者需要使用更多框架的元素时，才需要使用框架写法。\n\nNOTE\n\n不同插件框架写法的目录结构不一定相同，详情可见运行时框架。","frontmatter":{"sidebar_position":2,"title":"函数写法 & 框架写法"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/bff/type.mdx","_relativePath":"zh/guides/advanced-features/bff/type.mdx"},{"id":505,"title":"代码分割","routePath":"/guides/advanced-features/code-split","lang":"zh","toc":[{"text":"import","id":"import","depth":2,"charIndex":145},{"text":"React.lazy","id":"reactlazy","depth":2,"charIndex":275},{"text":"Loadable","id":"loadable","depth":2,"charIndex":734}],"domain":"","content":"#\n\n代码分割是优化前端资源加载的一种常用手段，本文将介绍 Modern.js 支持的三种代码分割方式：\n\nINFO\n\n使用 Modern.js 约定式路由时，默认会根据路由组件做代码分割，无需自行进行代码分割。\n\n * import\n * React.lazy\n * loadable\n\n\nimport#\n\n使用动态 import() 语法，传入的 JS 模块将会被被打包到单独的 JS 文件中。例如：\n\nimport('./math').then(math => {\n  console.log(math.add(16, 26));\n});\n\n\n\nReact.lazy#\n\nReact 官方提供的组件代码分割的方式。\n\nCAUTION\n\nReact.lazy 通常配合 使用，因此仅在 CSR 或 React 18 Streaming SSR 中可用。\n\n对于使用传统 SSR（字符串渲染）的项目，不支持 React.lazy，请使用 Loadable API。\n\n\n\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\nconst AnotherComponent = React.lazy(() => import('./AnotherComponent'));\n\nfunction MyComponent() {\n  return (\n    \n\n      Loading...}>\n        \n\n          \n          \n        \n      \n    \n  );\n}\n\n\nReact.lazy 更多用法请见 React 官网文档。\n\n\nLoadable#\n\n在 Modern.js 中，可以从 @modern-js/runtime/loadable 中导出使用 Loadable API，示例如下：\n\n\n\nconst OtherComponent = loadable(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return ;\n}\n\n\nModern.js 开箱即用的支持在 SSR 中使用 loadable，无需再添加 Babel 插件，或是在 SSR 时向 HTML 中注入脚本。\n\n但需要注意的是，任何 Loadable API 在 SSR 中都不支持配合 使用。\n\nINFO\n\n如果希望在 React 17 及以下的 CSR 项目中使用 ，可以用 loadable.lazy 代替 React.lazy。\n\n更多用法请见 Loadable API。","frontmatter":{"title":"代码分割","sidebar_position":6},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/code-split.mdx","_relativePath":"zh/guides/advanced-features/code-split.mdx"},{"id":506,"title":"浏览器兼容性","routePath":"/guides/advanced-features/compatibility","lang":"zh","toc":[{"text":"Browserslist 配置","id":"browserslist-配置","depth":2,"charIndex":3},{"text":"Polyfill","id":"polyfill","depth":2,"charIndex":295},{"text":"编译时 Polyfill","id":"编译时-polyfill","depth":3,"charIndex":307},{"text":"运行时按需 Polyfill","id":"运行时按需-polyfill","depth":3,"charIndex":601}],"domain":"","content":"#\n\n\nBrowserslist 配置#\n\nModern.js 支持设置 Web 应用需要兼容的浏览器范围，你可以在 .browserslistrc 文件里设置 Browserslist 的值。\n\n当你创建一个新的 Modern.js 项目时，默认会包含一份 .browserslistrc 配置，这表示 JavaScript 代码会被编译至 ES6 格式。\n\nchrome >= 51\nedge >= 15\nfirefox >= 54\nsafari >= 10\nios_saf >= 10\n\n\nTIP\n\n请查看 Modern.js Builder - 设置浏览器范围 来了解更多内容。\n\n\nPolyfill#\n\n\n编译时 Polyfill#\n\nModern.js 在编译时默认通过 core-js 引入对应的 Polyfill 代码。\n\n默认情况下会根据项目 Browserslist 的设置情况引入所需的 Polyfill 代码， 这样基本不用再担心项目源码和第三方依赖的 Polyfill\n问题了，但是因为包含了一些没有用到的 Polyfill 代码，所以最终的包大小可能会有所增加。\n\nINFO\n\n对于明确第三方依赖不需要 Polyfill 的场景，可以设置 output.polyfill 为 usage, 这样 Babel\n编译时只会根据代码中使用到的语法引入 Polyfill 代码。\n\n\n运行时按需 Polyfill#\n\nModern.js 中还提供了基于浏览器 UA 信息的运行时按需 Polyfill 方案，相比于 Babel 优势如下：\n\n * 不会插入到代码中，只根据访问页面的设备，按需下发 Polyfill 代码 ，减少整体代码体积。\n * 相同浏览器会公用一份 Polyfill 代码。因此，随着项目越来越多，基于 UA 的 Polyfill 代码下发速度会越来越快，综合速度超过常规方案。\n\n可以通过微生成器开启该功能：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「基于 UA 的 Polyfill」功能\n\n\n执行命令后，在 modern.config.ts 中注册 Polyfill 插件:\n\n\n\nexport default defineConfig({\n  plugins: [..., polyfillPlugin()],\n});\n\n\n配置 output.polyfill 为 ua 并且执行 pnpm run build && pnpm run serve 启动服务器后，访问页面可以看到\nHTML 产物中包含如下脚本:\n\n\n\n\n在 Chrome 51 下访问页面可以看到 http://localhost:8080/__polyfill__ 返回内容如下:\n\n\n\n注意\n\n该功能只有在使用 Modern.js 内置的 Web Server 时才会生效。\n\n如果有自定义模版的需求，请参考 HTML 模板。通过 html.template 或 tools.html 手动修改模版时，可能会导致该功能无法正确生效。","frontmatter":{"sidebar_position":5},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/compatibility.mdx","_relativePath":"zh/guides/advanced-features/compatibility.mdx"},{"id":507,"title":"ESLint 规则集","routePath":"/guides/advanced-features/eslint","lang":"zh","toc":[{"text":"Q: 如何处理 Lint","id":"q:-如何处理-lint","depth":2,"charIndex":138},{"text":"实时自动修复","id":"实时自动修复","depth":3,"charIndex":154},{"text":"批量自动修复","id":"批量自动修复","depth":3,"charIndex":300},{"text":"人工修复","id":"人工修复","depth":3,"charIndex":373},{"text":"声明例外情况","id":"声明例外情况","depth":3,"charIndex":441},{"text":"Q: 如何自定义 ESLint 规则","id":"q:-如何自定义-eslint-规则","depth":2,"charIndex":899},{"text":"仓库根目录下 package.json 里的 \\\"eslintConfig\\\" 字段","id":"仓库根目录下-packagejson-里的-\\\"eslintconfig\\\"-字段","depth":3,"charIndex":-1},{"text":"src/.eslintrc.js 文件","id":"src/eslintrcjs-文件","depth":3,"charIndex":1241},{"text":"package.json 里的 eslintIgnore 字段","id":"packagejson-里的-eslintignore-字段","depth":3,"charIndex":1892},{"text":"Q: 如何升级 ESLint 插件的版本","id":"q:-如何升级-eslint-插件的版本","depth":2,"charIndex":2083},{"text":"Q: WebStorm 有时候会报 ESLint 错误","id":"q:-webstorm-有时候会报-eslint-错误","depth":2,"charIndex":2507}],"domain":"","content":"#\n\nModern.js ESLint 规则集是全量的 ESLint 规则集合，包含 @modern-js （对于 Node.js 项目的 Lint 规则）和\n@modern-js-app（对于前端项目的 Lint 规则）。\n\n下面以具体问题介绍更多 ESLint 用法。\n\n\nQ: 如何处理 Lint#\n\n\n实时自动修复#\n\n多数问题会被 ESLint 规则的自动修复功能或 Prettier 的代码格式化功能（已被集成到 ESLint\n里）自动解决，开发者不需要关心问题的细节和解决方式。\n\nINFO\n\n主要在 IDE 保存文件的环节执行这种自动修复，少数漏网之鱼会在提交代码环节被自动修复。\n\n\n批量自动修复#\n\n在少数情况下，比如旧项目迁移的时候，可以执行以下命令，批量修复和检查所有文件：\n\npnpm run lint:error\n\n\n\n人工修复#\n\n对于无法自动修复的问题，可以在 IDE 里点击问题提示框里的规则链接，打开这条规则的文档，查看问题的解释和解决方案。\n\n\n声明例外情况#\n\n目前阶段，有些规则并不能做到足够智能，多数情况下会有很大收益，在少数情况下也许不适用。但如果为了这些少数情况就把整个规则关掉或改掉，得不偿失。\n\n这种情况下可以用 eslint-disable 注释，对符合少数情况的代码块做标注，声明这里是一个例外，应该忽略。比如：\n\n/* eslint-disable filenames/match-exported */\n...\n/* eslint-enable filenames/match-exported */\n\n\nINFO\n\n在 VS Code 编辑器里输入 eslint，会自动出现关于 \"eslint-disable\" 的提示框，选择提示选项生成对应注释对。\n\n【Modern.js ESLint 规则集】要求 eslint-disable\n必须成对使用，必须明确表达要影响的范围，以及在这个范围内明确表达要禁用什么规则，目的是让例外有明确的、最小化的范围，避免 eslint-disable\n被滥用，导致不属于例外的代码也被禁用了规则。\n\n\nQ: 如何自定义 ESLint 规则#\n\n\n仓库根目录下 package.json 里的 \"eslintConfig\" 字段#\n\n这个地方是整个仓库的默认 ESLint 配置，是针对纯 Node.js 代码（只能在 Node.js 里运行）设计的。\n\n如果项目在某些规则上确实有特殊要求或不可避免的兼容问题（不是例外），可以在这里增加规则配置。该配置会优先于默认的【Modern.js ESLint\n规则集】，比如：\n\n \"eslintConfig\": {\n    \"extends\": [\n      \"@modern-js\"\n    ],\n    \"rules\": {\n      \"filenames/match-exported\": \"off\"\n    }\n  },\n\n\n\n\nsrc/.eslintrc.js 文件#\n\nModern.js 的应用工程、模块工程，源代码目录里都会默认有这个配置文件，是针对 Universal JS 代码设计的。\n\nINFO\n\nUniversal JS 代码是既能浏览器端也能在服务器端运行的代码。\n\n如果项目在某些规则上确实有特殊要求或不可避免的兼容问题（不是例外），可以在这里增加规则配置，该配置会优先于默认的【Modern.js ESLint\n规则集】，比如：\n\n// eslint-disable-next-line import/no-commonjs\nmodule.exports = {\n  root: true,\n  extends: ['@modern-js-app'],\n  parserOptions: {\n    tsconfigRootDir: __dirname,\n    project: ['../tsconfig.json'],\n  },\n  rules: {\n    'filenames/match-exported': 'off',\n  },\n};\n\n\n如果有需要，还可以继续在不同的子目录里增加 .eslintrc.js 文件，针对这个子目录里的代码做特殊配置：\n\nmodule.exports = {\n  rules: {\n    'filenames/match-exported': 'off',\n  },\n};\n\n\n提示\n\n注意：没有必要使用 extends 字段，会自动继承父目录的配置。\n\n\npackage.json 里的 eslintIgnore 字段#\n\n把包含 .js、.jsx、.ts、.tsx 文件、但不需要做代码检查和自动修复的目录，添加到 eslintIgnore 里，可以优化 ESLint\n检查的速度，比如：\n\n \"eslintIgnore\": [\n    \"node_modules\",\n    \"dist\",\n    \"output\"\n  ],\n\n\n\nQ: 如何升级 ESLint 插件的版本#\n\n只要不是 Major 版本的变化（不符合 Semver 规则的 ^ 符号），就可以直接在业务项目的 package.json 里指定这个依赖，删除 Lock\n文件（或尝试手动删除 Lock 文件中这个包名的内容），执行 pnpm install 重新安装依赖并且生成新的 Lock 文件。\n\n做完这些操作之后，在业务项目的 ./node_modules 目录里，这个插件应该只存在一份，并且升级到了你指定的版本。\n\n提示\n * Major 版本就是主版本号。更多信息，请阅读 Semantic Versioning。\n * 所有被 Modern.js 封装的上游项目（比如 ESLint、ESLint 插件、React Router 等），也都可以这样升级。\n * Modern.js 也会在每次发版中尽量及时的升级这些上游依赖。\n * Major 版本的升级需要由 Modern.js 来发版。\n\n\nQ: WebStorm 有时候会报 ESLint 错误#\n\n由于 WebStorm 认为 ESLint 执行目录是根据 .eslintrc 文件来决定的。因此 src/.eslintrc 文件位置的放置会导致\ntsconfig.json 文件指定的位置（项目根目录下）在 src/ 目录下找不到。\n\n此时需要手动配置一下：\n\n--parser-options=project:../tsconfig.json\n\n\n","frontmatter":{"title":"ESLint 规则集","sidebar_position":8},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/eslint.mdx","_relativePath":"zh/guides/advanced-features/eslint.mdx"},{"id":508,"title":"配置底层工具","routePath":"/guides/advanced-features/low-level","lang":"zh","toc":[{"text":"使用方式","id":"使用方式","depth":2,"charIndex":3},{"text":"底层配置明细","id":"底层配置明细","depth":2,"charIndex":428}],"domain":"","content":"#\n\n\n使用方式#\n\nModern.js 内部默认集成了 Babel、TypeScript、Webpack、PostCSS、Tailwind CSS\n等工具。通常情况下，默认配置能够满足大多业务开发需求。当有特殊需求时，可以通过底层配置来实现。\n\n以配置 Webpack 为例，只需要在 modern.config.ts 中添加 tools.webpack 即可：\n\nexport default defineConfig({\n  tools: {\n    webpack: config => {},\n  },\n});\n\n\ntools 命名空间下的配置都可以设置为 Object 或者 Function。\n\n值为 Object 时，会与内部默认配置进行合并，具体合并策略参考对应的配置选项文档（见下表）。\n\n值为 Function 时，第一个参数为内部的默认配置对象，可以直接修改这个对象不做返回，也可以返回一个新的对象或者合并后的对象作为最终结果。\n\n\n底层配置明细#\n\n目前提供的底层配置如下表：\n\n底层工具                配置\nDevServer           tools.devServer\nBabel               tools.babel\nstyled-components   tools.styledComponents\nPostCSS             tools.postcss\nLess                tools.less\nSass                tools.sass\nwebpack             tools.webpack\nMinify CSS          tools.minifyCss\nterser              tools.terser\nTailwind CSS        tools.tailwind\nAutoprefixer        tools.autoprefixer","frontmatter":{"title":"配置底层工具","sidebar_position":11},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/low-level.mdx","_relativePath":"zh/guides/advanced-features/low-level.mdx"},{"id":509,"title":"使用 Rspack","routePath":"/guides/advanced-features/rspack-start","lang":"zh","toc":[{"text":"初始化 Rspack 项目","id":"初始化-rspack-项目","depth":2,"charIndex":320},{"text":"开启 Rspack 构建","id":"开启-rspack-构建","depth":2,"charIndex":668},{"text":"配置迁移","id":"配置迁移","depth":2,"charIndex":978},{"text":"Rspack 和 Modern.js 的版本关系","id":"rspack-和-modernjs-的版本关系","depth":2,"charIndex":1026},{"text":"修改内置 Rspack 版本","id":"修改内置-rspack-版本","depth":4,"charIndex":1317}],"domain":"","content":"#\n\n什么是 Rspack\n\nRspack 是一个基于 Rust 的高性能 Web 构建工具，具备与 webpack 生态系统的互操作性，可以被 webpack\n项目低成本集成，并提供更好的构建性能。\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。经过 benchmark\n验证，Rspack 可以带来 5 ～ 10 倍编译性能的提升。\n\nModern.js 提供开箱即用的 Rspack 支持，你可以在成熟的 Webpack 和更快的 Rspack 之间进行切换。\n\n这篇文档会向你介绍如何在 Modern.js 中开启 Rspack 构建模式。\n\n\n初始化 Rspack 项目#\n\nModern.js 生成器会提供一个可交互的问答界面，只需将构建工具选择为 Rspack，即可创建一个 Rspack 项目:\n\n$ npx @modern-js/create@latest myapp\n? 请选择你想创建的工程类型：Web 应用\n? 请选择开发语言：TS\n? 请选择包管理工具：pnpm\n? 请选择构建工具：Rspack\n\n\n项目创建完成后，在项目中执行 pnpm run dev 即可体验项目，更多信息可参考快速上手。\n\nTIP\n\n在使用 Rspack 作为打包工具时，由于部分能力尚在开发中，以下 features 暂时无法使用，我们将在未来提供支持：\n\n * Storybook 调试\n * 客户端渲染（CSR）使用 useLoader\n\n\n开启 Rspack 构建#\n\n在一个已有的 Modern.js 项目中，你可以通过执行 pnpm run new 来启用 Rspack 构建：\n\n$ pnpm run new\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「Rspack 构建」\n\n\n执行以上命令后，在 modern.config.ts 中添加 Rspack 相关配置即可：\n\n\n\n+ export default defineConfig<'rspack'>({\n  plugins: [\n    appTools({\n+     bundler: 'experimental-rspack',\n    }),\n  ],\n});\n\n\n\n配置迁移#\n\n开启 Rspack 构建能力后，还需要参考 配置差异 进行进一步的配置迁移。\n\n\nRspack 和 Modern.js 的版本关系#\n\n通常情况下，Modern.js 内会集成 Rspack 的最新版本，通过 npx modern upgrade 即可将当前项目中的 Modern.js\n相关依赖以及内置的 Rspack 更新至最新版本。\n\n但 Modern.js 对于 Rspack 的依赖方式为锁版本方式(非自动升级)，由于发版周期不同步等原因，可能会出现 Modern.js 内集成的\nRspack 版本落后于 Rspack 最新版本的情况。\n\n当你执行 dev / build 命令时，Modern.js 会自动打印当前使用的 Rspack 版本：\n\n\n\n修改内置 Rspack 版本#\n\n可以使用 pnpm / yarn / npm 等包管理工具自带的依赖升级功能来将 Rspack 强制升级到指定版本。\n\n以 pnpm 为例，可通过 overrides 以下依赖更新 Rspack 版本:\n\n{\n  \"pnpm\": {\n    \"overrides\": {\n      \"@rspack/core\": \"nightly\",\n      \"@rspack/dev-client\": \"nightly\",\n      \"@rspack/plugin-html\": \"nightly\"\n    }\n  }\n}\n\n\nNightly 版本介绍\n\n每天，Rspack 会自动构建基于最新代码的 nightly 版本，用于测试和及早发现错误。\n\n通常情况下，这些版本是可用的。如果发现问题，我们会及时进行修复。但是，如果 Rspack 有一些 break change，需要 Modern.js\n同步修改代码，那么我们建议等待下一个 Modern.js 版本再进行更新。\n\n如果想了解其他包管理工具锁定依赖版本的示例，可以参考：锁定子依赖。","frontmatter":{"title":"使用 Rspack","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/rspack-start.mdx","_relativePath":"zh/guides/advanced-features/rspack-start.mdx"},{"id":510,"title":"静态站点生成（SSG）","routePath":"/guides/advanced-features/ssg","lang":"zh","toc":[{"text":"在约定式路由中使用","id":"在约定式路由中使用","depth":3,"charIndex":304},{"text":"在自控式路由中使用","id":"在自控式路由中使用","depth":3,"charIndex":1298}],"domain":"","content":"#\n\nSSG（Static Site Generation）是一种基于数据与模板，在构建时渲染完整静态网页的技术解决方案。\n\n我们首先需要执行 pnpm run new 启用 SSG 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「SSG」功能\n\n\n执行命令后，在 modern.config.ts 中注册 SSG 插件：\n\n\n\nexport default defineConfig({\n  output: {\n    ssg: true,\n  },\n  plugins: [..., ssgPlugin()],\n});\n\n\nSSG 在约定式路由和自控式路由下的使用方式不同。\n\n\n在约定式路由中使用#\n\n约定式路由中， Modern.js 根据入口下的文件结构生成路由，因此框架能够收集完整的路由信息。\n\n例如，以下是一个使用约定式路由的项目目录结构：\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       ├── page.tsx\n│       └── user\n│           ├── layout.tsx\n│           ├── page.tsx\n│           └── profile\n│               └── page.tsx\n\n\n上述文件目录将会生成以下三条路由：\n\n * /\n * /user\n * /user/profile\n\nNOTE\n\n如果还不了解约定式路由的规则，可以先查看路由。\n\n在 src/routes/page.tsx 中添加组件代码：\n\nexport default () => {\n  return \nIndex Page;\n};\n\n\nSSG 也是在 Node.js 环境渲染页面，因此我们可以在开发阶段开启 SSR，提前在暴露代码问题，验证 SSG 渲染效果：\n\nexport default defineConfig({\n  server: {\n    ssr: process.env.NODE_ENV === 'development',\n  }\n}\n\n\n在项目根路径下执行 pnpm run dev 命令，查看 dist/ 目录，此时只生成一个 HTML 文件 main/index.html。\n\n在项目根路径下执行 pnpm run build 命令，构建完成后，查看 dist/ 目录，此时生成\nmain/index.html、main/user/index.html 和 main/user/profile/index.html 三个 HTML\n文件，内容分别对应上述三条路由。\n\n约定式路由中的每一条路由，都会生成一个单独的 HTML 文件。查看 main/index.html，可以发现包含 Index Page 的文本内容，这正是\nSSG 的效果。\n\n执行 pnpm run serve 启动项目后，访问页面，在浏览器我们工具的 Network 窗口，查看请求返回的文档，文档包含组件渲染后的完整页面内容。\n\n\n在自控式路由中使用#\n\n自控式路由是通过组件代码定义路由，需要应用运行起来才能获取准确的路由信息。因此，无法开箱即用的使用 SSG 功能。此时需要用户提前告知 Modern.js\n框架，哪些路由需要开启 SSG 功能。\n\n例如有以下代码，包含多条路由，设置 output.ssg 为 true 时，默认只会渲染入口路由即 /：\n\n\n\n\n\n\nconst Router = typeof window === 'undefined' ? StaticRouter : BrowserRouter;\n\nexport default () => {\n  const { context } = useRuntimeContext();\n  const pathname = context?.request?.pathname;\n  return (\n    \n      \n        index} />\n        about} />\n      \n    \n  );\n};\n\n\n如果我们希望同时开启 /about 的 SSG 功能，可以配置 output.ssg，告知 Modern.js 开启指定路由的 SSG 功能。\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      routes: ['/', '/about'],\n    },\n  },\n});\n\n\n执行 pnpm run build 与 pnpm run serve 后，访问 http://localhost:8080/about，在 Preview\n视图中可以看到页面已经完成渲染。\n\n查看构建产物文件，可以看到 dist/ 目录中，新增了一个 main/about/index.html 文件。\n\nINFO\n\n以上仅介绍了单入口的情况，更多相关内容可以查看 API 文档。","frontmatter":{"title":"静态站点生成（SSG）","sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/ssg.mdx","_relativePath":"zh/guides/advanced-features/ssg.mdx"},{"id":511,"title":"服务端渲染（SSR）","routePath":"/guides/advanced-features/ssr","lang":"zh","toc":[{"text":"SSR 时的数据获取","id":"ssr-时的数据获取","depth":2,"charIndex":224},{"text":"保持渲染一致","id":"保持渲染一致","depth":2,"charIndex":891},{"text":"关注内存泄漏","id":"关注内存泄漏","depth":2,"charIndex":1605},{"text":"收敛服务端数据","id":"收敛服务端数据","depth":2,"charIndex":2272},{"text":"Serverless Pre-render","id":"serverless-pre-render","depth":2,"charIndex":2553},{"text":"Treeshaking","id":"treeshaking","depth":2,"charIndex":3625},{"text":"环境变量区分","id":"环境变量区分","depth":3,"charIndex":4206},{"text":"文件后缀区分","id":"文件后缀区分","depth":3,"charIndex":4636},{"text":"独立文件","id":"独立文件","depth":3,"charIndex":5100},{"text":"接口请求","id":"接口请求","depth":2,"charIndex":5463},{"text":"流式渲染","id":"流式渲染","depth":2,"charIndex":5705},{"text":"异步获取数据","id":"异步获取数据","depth":3,"charIndex":6013},{"text":"渲染异步数据","id":"渲染异步数据","depth":3,"charIndex":7044},{"text":"错误处理","id":"错误处理","depth":3,"charIndex":8105}],"domain":"","content":"#\n\n在 Modern.js 中，SSR 也是开箱即用的。开发者无需为 SSR 编写复杂的服务端逻辑，也无需关心 SSR\n的运维，或是创建单独的服务。Modern.js 拥有完备的 SSR 降级策略，保证页面能够安全运行。\n\n启用 SSR 非常简单，只需要设置 server.ssr 为 true 即可：\n\n\n\nexport default defineConfig({\n  server: {\n    ssr: true,\n  },\n});\n\n\n\nSSR 时的数据获取#\n\nModern.js 中提供了 Data Loader，方便开发者在 SSR、CSR 下同构的获取数据。每个路由模块，如 layout.tsx 和\npage.tsx 都可以定义自己的 Data Loader：\n\nexport default () => {\n  return {\n    message: 'Hello World',\n  };\n};\n\n\n在组件中可以通过 Hooks API 的方式获取 loader 函数返回的数据：\n\n\nexport default () => {\n  const data = useLoaderData();\n  return \n{data.message};\n};\n\n\nModern.js 打破传统的 SSR 开发模式，提供了用户无感的 SSR 开发体验。并且提供了优雅的降级处理，一旦 SSR\n请求失败，会自动降级在浏览器端重新发起请求。\n\n不过，开发者仍然需要关注数据的兜底处理，例如 null 值或不符合预期的数据返回。避免在 SSR 时产生 React 渲染错误或是返回凌乱的渲染结果。\n\n补充信息\n\n 1. 当以客户端路由的方式请求页面时，Modern.js 会发送一个 HTTP 请求，服务端接收到请求后执行页面对应的 Data Loader\n    函数，然后将执行结果作为请求的响应返回浏览器。\n\n 2. 使用 Data Loader 时，数据获取发生在渲染前，Modern.js 也仍然支持在组件渲染时获取数据。更多相关内容可以查看数据获取。\n\n\n保持渲染一致#\n\n有些业务中，通常需要根据当前的运行容器环境特征做不同的 UI 展示，例如 UA 信息。如果处理不够仔细，此时很有可能出现不符合预期的渲染结果。\n\n这里通过一个例子，演示当 SSR 与 CSR 渲染不一致时出现的问题，在组件中添加以下代码：\n\n{\n  typeof window !== 'undefined' ? \nbrowser content : null;\n}\n\n\n启动应用后，访问页面，会发现浏览器控制台抛出警告信息：\n\nWarning: Expected server HTML to contain a matching \n in \n.\n\n\n这是 React 在客户端执行 hydrate 逻辑时，发现渲染结果与 SSR 渲染结果不一致造成的。虽然页面表现正常，但在复杂应用中，很有可能因此出现 DOM\n层级混乱、样式混乱等问题。\n\nINFO\n\n关于 hydrate (注水)逻辑请参考这里。\n\n应用需要保持 SSR 与 CSR 渲染结果的一致性，如果存在不一致的情况，说明这部分内容无需在 SSR 中进行渲染。Modern.js 为这类在 SSR\n中不需要渲染的内容提供 工具组件：\n\n\n\n\n在不需要进行 SSR 的元素外部，用 NoSSR 组件包裹：\n\n\n  \nclient content\n\n\n\n修改代码后，刷新页发现之前的 Waring 消失。打开浏览器开发者工具的 Network 窗口，查看返回的 HTML 文档是不包含 NoSSR\n组件包裹的内容的。\n\n补充信息\n\nuseRuntimeContext 可以获取完整的请求信息，可以利用它保证 SSR 与 CSR 的渲染结果一致。\n\n\n关注内存泄漏#\n\n警告\n\n在 SSR 场景下，开发者需要特别关注内存泄露问题，即使是微小的内存泄露，在大量的访问后也会对服务造成影响。\n\nSSR\n时，浏览器的每次请求，都会触发服务端重新执行一次组件渲染逻辑。所以，需要避免在全局定义任何可能不断增长的数据结构，或在全局进行事件订阅，或创建不会被销毁的流。\n\n例如以下代码，使用 redux-observable 时，习惯了 CSR 的开发者通常会在组件中这样编码：\n\n/* 代码仅作为示例，不可运行 */\n\n\nconst epicMiddleware = createEpicMiddleware();\nconst rootEpic = combineEpics();\n\nexport default function Test() {\n  epicMiddleware.run(rootEpic);\n  return \nHello Modern.js;\n}\n\n\n在组件外层创建 Middleware 实例 epicMiddleware，并在组件内部调用 epicMiddleware.run。\n\n在浏览器端，这段代码不会造成任何问题，但是在 SSR 时，Middleware 实例会一直无法被销毁。每次渲染组件，调用\nepicMiddleware.run(rootEpic) 时，都会在内部添加新的事件绑定，导致整个对象不断变大，最终对应用性能造成影响。\n\nCSR 中这类问题不易被发觉，因此从 CSR 切换到 SSR 时，如果不确定应用是否存在这类隐患，可以对应用进行压测。\n\n\n收敛服务端数据#\n\n为了保持 SSR 阶段请求的数据，可以在浏览器端直接使用，Modern.js 会将渲染过程中收集的数据与状态注入到 HTML 内。但是，CSR\n应用常常存在接口数据量大、组件状态未收敛的情况，这时如果直接使用 SSR，渲染得到的 HTML 体积可能会存在过大的问题。此时，SSR\n不仅无法为应用带来用户体验上的提升，反而可能起到相反的作用。\n\n因此，使用 SSR 时，开发者需要为应用做合理的瘦身：\n\n 1. 关注首屏，SSR 中可以只请求首屏需要的数据，并在浏览器端渲染剩余的部分。\n 2. 将与渲染无关的数据，从接口返回数据中剔除。\n\n\nServerless Pre-render#\n\nModern.js 提供 Serverless Pre-rendering (SPR) 这一特性来提升 SSR 性能。\n\nSPR 利用预渲染与缓存技术，为 SSR 页面提供静态 Web 的响应性能。它让 SSR 应用拥有静态 Web\n页面的响应速度与稳定性，同时还能保持数据的动态更新。\n\n在 Modern.js 中使用 SPR 非常简单，只需要在组件中新增 PreRender 组件，该组件所在的页面就会自动开启 SPR。\n\n这里模拟一个使用 useLoaderData API 的组件，Data Loader 中的请求需要消耗 2s 时间。\n\n\n\nexport default async () => {\n  await new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(null);\n    }, 2000);\n  });\n\n  return {\n    message: 'Hello Modern.js',\n  };\n};\n\n\nexport default () => {\n  const data = useLoaderData();\n  return \n{data?.message};\n};\n\n\n执行 dev 命令后，打开页面，可以明显的察觉到页面需要等到 2s 后才返回。\n\n接下来使用 PreRender 组件来进行优化，该组件可以直接从 @modern-js/runtime/ssr 中导出：\n\n\n\n\n在路由组件内使用 PreRender 组件，并设置参数 interval，用于表示该次渲染结果的过期时间为 5s：\n\n\n\n\n修改后，执行 pnpm run build && pnpm run serve 启动应用，并打开页面。\n\n首次打开时，和之前的渲染并没有什么不同，同样存在 2s 延迟。点击刷新，页面瞬间打开，但此时，页面数据并没有因为刷新发生变化，这是因为缓存还没有过期。\n\n等待 5s，重新刷新页面，页面的数据仍然没有变化。再一次刷新页面数据发生变化，但是页面仍然几乎是瞬间响应的。 这是因为在之前的请求时，SPR\n已经在后台异步获取了新的渲染结果，本次请求到的页面是已经缓存在服务器中的版本。\n\n可以想象，当 interval 设置为 1 时，用户可以在感知到实时数据的同时，拥有静态页面的响应体验。\n\n补充信息\n\nPreRender 的详细使用可以参考这里。\n\n\nTreeshaking#\n\n开启 SSR 时，Modern.js 会用相同的入口，构建出 SSR Bundle 和 CSR Bundle 两份产物。因此，在 SSR Bundle 中存在\nWeb API，或是在 CSR Bundle 中存在 Node API 时，都可能导致运行出错。\n\n在组件中引入 Web API，通常情况下是要做一些全局监听，或是获取浏览器相关的数据，例如：\n\ndocument.addEventListener('load', () => {\n  console.log('document load');\n});\nconst App = () => {\n  return \nHello World;\n};\nexport default App;\n\n\n在组件文件中引入 Node API，通常情况下是因为使用了 useLoader，例如：\n\n\n\n\nconst App = () => {\n  const { data } = useLoader(async () => {\n    const file = fse.readFileSync('./myfile');\n    return {\n      ...\n    };\n  })\n\n  return \nHello World;\n};\nexport default App;\n\n\n\n环境变量区分#\n\n对于第一种情况，我们可以直接使用 Modern.js 内置的环境变量 MODERN_TARGET 进行判断，在构建时删除无用代码：\n\nif (process.env.MODERN_TARGET === 'browser') {\n  document.addEventListener('load', () => {\n    console.log('document load');\n  });\n}\n\n\n开发环境打包后，SSR 产物和 CSR 产物会被编译成以下内容。因此 SSR 环境中不会再因为 Web API 报错：\n\n// SSR 产物\nif (false) {\n}\n\n// CSR 产物\nif (true) {\n  document.addEventListener('load', () => {\n    console.log('document load');\n  });\n}\n\n\nNOTE\n\n更多内容可以查看环境变量。\n\n\n文件后缀区分#\n\n但例如第二种情况，在代码中引入了 fs-extra，它内部有使用了 Node API 的副作用，如果直接引用到组件中，会造成 CSR 加载报错。\n\n环境变量的方式并不能在这种情况下生效，Modern.js 也支持通过 .node. 后缀的文件来区分 SSR Bundle 和 CSR Bundle\n产物的打包文件。\n\n可以创建同名的 .ts 和 .node.ts 文件做一层代理：\n\nexport const readFileSync: any = () => {};\n\n\nexport { readFileSync } from 'fs-extra';\n\n\n在文件中直接引入 ./compat，此时 SSR 环境下会优先使用 .node.ts 后缀的文件，CSR 环境下会使用 .ts 后缀的文件。\n\n\n\nexport const loader = () => {\n  const file = readFileSync('./myfile');\n  return {\n    ...\n  };\n};\n\n\n\n独立文件#\n\n上述两种方式，都会为开发者带来一些心智负担。在真实的业务中，我们发现大多数的 Node / Web 代码混用都出现在数据请求中。\n\n因此，Modern.js 基于嵌套路由开发设计了更简单的方案来分离 CSR 和 SSR 的代码。\n\n我们可以通过独立文件来分离数据请求与组件代码。在 routes/page.tsx 中编写组件逻辑，在 routes/page.loader.ts\n中编写数据请求逻辑。\n\nexport default Page = () => {\n  return \nHello World\n\n}\n\n\n\nexport default () => {\n  const file = fse.readFileSync('./myfile');\n  return {\n    ...\n  };\n}\n\n\n\n接口请求#\n\n在 SSR 中发起接口请求时，开发者有时自己封装了同构的请求工具。部分接口需要传递用户 Cookie，开发者可以通过 useRuntimeContext API\n获取到请求头来实现。\n\n需要注意的是，此时获取到的是 HTML\n请求的请求头，不一定适用于接口请求，因此千万不能透传所有请求头。并且，一些后端接口，或是通用网关，会根据请求头中的信息做校验，全量透传容易出现各种难以排查的问题\n，推荐按需透传。\n\n如果实在需要透传所有请求头，请务必过滤 host 字段。\n\n\n流式渲染#\n\nModern.js 支持了 React 18 的流式渲染，可以通过如下配置启用：\n\n\n\nexport default defineConfig({\n  server: {\n    ssr: {\n      mode: 'stream',\n    },\n  },\n});\n\n\nModern.js 的流式渲染基于 React Router 实现，主要涉及 API 有：\n\n * defer：在 Data Loader 中使用，用于支持异步获取数据。\n * Await：用于渲染 Data Loader 返回的异步数据。\n * useAsyncValue：用于从最近的父级 Await 组件中获取数据。\n\n\n异步获取数据#\n\n\n\ninterface User {\n  name: string;\n  age: number;\n}\n\nexport interface Data {\n  data: User;\n}\n\nexport default ({ params }: LoaderFunctionArgs) => {\n  const userId = params.id;\n\n  const user = new Promise(resolve => {\n    setTimeout(() => {\n      resolve({\n        name: `user-${userId}`,\n        age: 18,\n      });\n    }, 200);\n  });\n\n  return defer({ data: user });\n};\n\n\nuser 是一个 Promise 类型的对象，表示需要异步获取的数据，通过 defer 处理需要异步获取的 user。注意，defer\n必须接收一个对象类型的参数， 因此， 传入 defer 的参数为：{ data: user }\n\ndefer 还可以同时接收异步数据和同步数据。例如：\n\n// 省略部分代码\n\nexport default ({ params }: LoaderFunctionArgs) => {\n  const userId = params.id;\n\n  const user = new Promise(resolve => {\n    setTimeout(() => {\n      resolve({\n        name: `user-${userId}`,\n        age: 18,\n      });\n    }, 200);\n  });\n\n  const otherData = new Promise(resolve => {\n    setTimeout(() => {\n      resolve('some sync data');\n    }, 200);\n  });\n\n  return defer({\n    data: user,\n    other: await otherData,\n  });\n};\n\n\notherData 前加了 await，所以是同步获取的数据，它可以和异步获取的数据 user 同时传入 defer。\n\n\n渲染异步数据#\n\n通过 Await 组件，可以获取到 Data Loader 中异步返回的数据，然后进行渲染。例如：\n\n\n\n\n\nconst Page = () => {\n  const data = useLoaderData() as Data;\n\n  return (\n    \n\n      User info:\n      loading user data ...}>\n        \n          {user => {\n            return (\n              \n\n                name: {user.name}, age: {user.age}\n              \n            );\n          }}\n        \n      \n    \n  );\n};\n\nexport default Page;\n\n\nAwait 需要包裹在 Suspense 组件内部，Await 的 resolve 传入的是 Data Loader 异步获取的数据，当数据获取完成后， 通过\nRender Props 模式，渲染获取到的数据。在数据的获取阶段，将展示 Suspense 组件 fallback 属性设置的内容。\n\n注意\n\n从 Data Loader 文件导入类型时，需要使用 import type 语法，保证只导入类型信息，这样可以避免 Data Loader\n的代码打包到前端产物的 bundle 文件中。\n\n所以，这里的导入方式为：``;\n\n也可以通过 useAsyncValue 获取 Data Loader 返回的异步数据。例如：\n\n\n\n// 省略部分代码\n\nconst UserInfo = () => {\n  const user = useAsyncValue();\n\n  return (\n    \n\n      name: {user.name}, age: {user.age}\n    \n  );\n};\n\nconst Page = () => {\n  const data = useLoaderData() as Data;\n\n  return (\n    \n\n      User info:\n      loading user data ...}>\n        \n          \n        \n      \n    \n  );\n};\n\nexport default Page;\n\n\n\n错误处理#\n\nAwait 组件的 errorElement 属性，可以用来处理当 Data Loader 执行时，或者子组件渲染时抛出的错误。 例如，我们故意在 Data\nLoader 函数中抛出错误：\n\n\n\nexport default () => {\n  const data = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error('error occurs'));\n    }, 200);\n  });\n\n  return defer({ data });\n};\n\n\n然后通过 useAsyncError 获取错误，并将用于渲染错误信息的组件赋值给 Await 组件的 errorElement 属性：\n\n\n\n\nexport default function Page() {\n  const data = useLoaderData();\n\n  return (\n    \n\n      Error page\n      loading ...}>\n        }>\n          {(data: any) => {\n            return \nnever displayed;\n          }}\n        \n      \n    \n  );\n}\n\nfunction ErrorElement() {\n  const error = useAsyncError() as Error;\n  return \n\nSomething went wrong! {error.message};\n}\n\n\n补充信息\n 1. Deferred Data\n 2. New Suspense SSR Architecture in React 18","frontmatter":{"title":"服务端渲染（SSR）","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/ssr.mdx","_relativePath":"zh/guides/advanced-features/ssr.mdx"},{"id":512,"title":"测试","routePath":"/guides/advanced-features/testing","lang":"zh","toc":[{"text":"测试文件","id":"测试文件","depth":2,"charIndex":319},{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":445},{"text":"transform","id":"transform","depth":2,"charIndex":577}],"domain":"","content":"#\n\nModern.js 默认集成了 Jest 的测试能力。\n\n我们首先需要执行 pnpm run new 启用「单元测试 / 集成测试」功能：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「单元测试 / 集成测试」功能\n\n\n执行上述命令后，package.json 中将会自动添加 \"test\": \"modern test\" 命令。\n\n在 modern.config.ts 中注册 @modern-js/plugin-testing 插件后即可使用测试功能：\n\n\n\nexport default defineConfig({\n  ...,\n  plugins: [..., testPlugin()],\n});\n\n\n\n测试文件#\n\nModern.js 默认识别的测试文件路径为：/src/**/*.test.[jt]s?(x) 和 /tests/**/*.test.[jt]s?(x)。\n\n如果你需要自定义 test 目录，可通过 tools.jest 进行配置。\n\n\n使用姿势#\n\nModern.js test 支持使用 testing-library 相关包 API，可直接通过 @modern-js/runtime/testing\n进行导入:\n\n\n\n\n其他 Modern.js 支持的 testing API 可参考这里。\n\n\ntransform#\n\nModern.js 测试默认使用 babel-jest 进行源码编译，如果你需要使用 ts-jest，可以通过 testing.transform 进行配置。","frontmatter":{"sidebar_position":10},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/testing.mdx","_relativePath":"zh/guides/advanced-features/testing.mdx"},{"id":513,"title":"自定义 Web Server","routePath":"/guides/advanced-features/web-server","lang":"zh","toc":[{"text":"使用 API 扩展 Web Server","id":"使用-api-扩展-web-server","depth":2,"charIndex":389},{"text":"Hook","id":"hook","depth":3,"charIndex":955},{"text":"Middleware","id":"middleware","depth":3,"charIndex":1493},{"text":"通过 BFF 托管页面请求","id":"通过-bff-托管页面请求","depth":2,"charIndex":2114},{"text":"完全自定义的 Web Server","id":"完全自定义的-web-server","depth":2,"charIndex":2522}],"domain":"","content":"#\n\nModern.js\n作为以客户端为中心的开发框架，对服务端的定制能力较弱。而在有些开发场景下，需要定制特殊的服务端逻辑，例如用户鉴权、请求预处理、添加页面渲染骨架等。\n\n一些开发者可能会有疑惑，Modern.js 已经提供了 BFF 能力，为什么还需要自定义 Web Server。\n\n因为在默认情况下，页面路由并不会经过 BFF，它没有办法为页面访问提供服务端的定制逻辑。之所以这样设计，是因为我们不希望控制页面的服务与 BFF\n服务绑定在一起，避免 BFF 的框架限制页面的部署方式。例如将页面与 BFF 分开托管、将页面服务部署到非 Node 的环境上，或是针对部署平台做定制等。\n\n出于上述原因，Modern.js 提供了三种方式，让项目可以在根据需求，渐进式的定制服务端能力。\n\nWARNING\n\n三种扩展方式无法同时工作，开发者需要根据场景选择合适的方式。\n\n\n使用 API 扩展 Web Server#\n\n第一种方式是通过 Modern.js 提供的服务端运行时 API，在特定的生命周期对服务端进行定制。提供这种方式的目的是在部分情况下，开发者并不需要控制完整的\nWeb Server，只需要添加服务端逻辑即可。\n\n这种方式无法控制完整的 Web Server，并且扩展逻辑只在请求页面时生效。因此，它适用于服务端逻辑相对简单，不希望额外创建 BFF 或者 BFF\n和页面无需公用服务端逻辑场景。\n\n可以在项目根目录执行 pnpm run new 命令，开启「自定义 Web Serve」功能：\n\n? 请选择你想要的操作 创建工程元素\n? 请选择创建元素类型 新建「自定义 Web Server」源码目录\n\n\n执行命令后，在 modern.config.ts 中注册 @modern-js/plugin-server 插件:\n\n\n\nexport default defineConfig({\n  plugins: [..., serverPlugin()],\n});\n\n\n开启功能后，项目目录下会自动创建 server/index.ts 文件，可以在这个文件中编写自定义逻辑。Modern.js 提供了 Hook 与\nMiddleware 两类 API 来扩展 Web Server。\n\n\nHook#\n\nModern.js 提供的 Hook 用于控制 Web Server 中的内置逻辑，所有的页面请求都会经过 Hook。\n\n目前提供了两种 Hook，分别是 AfterMatch 和 AfterRender，可以用于修改渲染结果。可以在 server/index.ts 中这样写：\n\nimport type {\n  AfterMatchHook,\n  AfterRenderHook,\n} from '@modern-js/runtime/server';\n\nexport const afterMatch: AfterMatchHook = (ctx, next) => {\n  next();\n};\n\nexport const afterRender: AfterRenderHook = (ctx, next) => {\n  next();\n};\n\n\n项目在使用 Hook 时，应该有以下最佳实践：\n\n 1. 在 afterMatch 中做权限校验。\n 2. 在 afterMatch 做 Rewrite 和 Redirect。\n 3. 在 afterRender 中做 HTML 内容注入。\n\nNOTE\n\n详细 API 和更多用法可以查看 Hook。\n\n\nMiddleware#\n\n对于某些项目，可能在服务端有更多的需求，Modern.js 提供了 Middleware 为 Web Server 添加前置中间件。它只能运行在 Node\n环境下，因此如果项目被部署到其他环境中，如 Worker 环境，则不可以使用 Middleware。\n\nModern.js 默认提供了一套 API 供项目使用：\n\n\n\nexport const middleware: Middlewre = (context, next) => {\n  const {\n    source: { req, res },\n  } = context;\n  console.log(req.url);\n  next();\n};\n\n\nNOTE\n\n详细 API 和更多用法可以查看 Middleware。\n\n项目在使用 Middleware 时，应该有以下最佳实践：\n\n 1. 在 Middleware 中可以直接操作原生的请求、响应对象，做数据打点、注入 SSR 渲染可能用到的 Node 服务（数据库、Redis 等）。\n 2. 在 Middleware 里可以做类似功能打标、爬虫优化等功能。\n 3. 在 Middleware 里可以无视后续默认渲染，自定义渲染流程。\n\n总的来说，CSR 项目中，使用 Hook 基本能满足简单场景的所有需求。SSR 项目中，可以使用 Middleware 做更复杂的 Node 扩展。\n\n\n通过 BFF 托管页面请求#\n\n第二种方式，是利用 BFF 来托管页面渲染，这种方式下，所有的请求都会先打到 BFF 的服务。\n\n因为这种方式可以通过 BFF 统一控制所有请求的服务端逻辑。因此，它适用于服务端逻辑复杂，BFF 和页面需要公用服务端逻辑的场景。但它整体还是依托于\nModern.js 的 Web Server 运行，无法将逻辑运行在已有的服务上。\n\n使用这种方式，我们需要先通过 pnpm new 开启「BFF」功能。然后在配置文件中添加 bff.enableHandleWeb 配置：\n\nexport default defineConfig({\n  bff: {\n    enableHandleWeb: true,\n  },\n});\n\n\n当该值设置为 true 时，页面请求流量也会经过 BFF，并且 Modern.js 内置的页面渲染的逻辑默认会作为 BFF 服务的最后一个中间件运行。\n\n\n完全自定义的 Web Server#\n\nNOTE\n\n敬请期待","frontmatter":{"title":"自定义 Web Server","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/advanced-features/web-server.mdx","_relativePath":"zh/guides/advanced-features/web-server.mdx"},{"id":514,"title":"别名","routePath":"/guides/basic-features/alias","lang":"zh","toc":[],"domain":"","content":"#\n\nModern.js 允许在 JS 和 CSS 中使用别名导入自定义目录下的模块，并内置了以下别名:\n\n{\n  '@': '/src',\n  '@shared': '/shared',\n}\n\n\nINFO\n\n在开启可选功能时，new 命令也会动态的添加内置别名，例如启用 BFF 时默认会添加 @api 别名。\n\n例如从 src/App.tsx 文件中导入 src/common 目录下的模块：\n\n.\n├── common\n│   ├── styles\n│   │   └── base.css\n│   └── utils\n│       └── index.ts\n└── App.tsx\n\n\nsrc/App.tsx 中写法如下：\n\n\nimport '@/src/common/styles/base.css';\n\n\nModern.js 也提供了自定义别名的方式，以添加 @common 别名为例：\n\n对于 TypeScript 项目，只需要在项目根目录 tsconfig.json 下配置 compilerOptions.paths：\n\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./src/*\"],\n      \"@/common/*\": [\"./src/common/*\"]\n    }\n  }\n}\n\n\nJavaScript 项目可以在 modern.config.js 中配置 source.alias：\n\nexport default defineConfig({\n  source: {\n    alias: {\n      '@common': './src/common',\n    },\n  },\n});\n\n\n对于别名配置的具体用法，请参考 source.alias 文档。","frontmatter":{"title":"别名","sidebar_position":8},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/basic-features/alias.mdx","_relativePath":"zh/guides/basic-features/alias.mdx"},{"id":515,"title":"CSS 开发方案","routePath":"/guides/basic-features/css","lang":"zh","toc":[{"text":"使用 Less、Sass 和 Stylus","id":"使用-less、sass-和-stylus","depth":2,"charIndex":106},{"text":"使用 PostCSS","id":"使用-postcss","depth":2,"charIndex":352},{"text":"使用 CSS Modules","id":"使用-css-modules","depth":2,"charIndex":445},{"text":"使用 CSS-in-JS","id":"使用-css-in-js","depth":2,"charIndex":508},{"text":"使用 Tailwind CSS","id":"使用-tailwind-css","depth":2,"charIndex":1228},{"text":"Tailwind CSS 版本","id":"tailwind-css-版本","depth":3,"charIndex":1944},{"text":"浏览器兼容性","id":"浏览器兼容性","depth":3,"charIndex":2219},{"text":"Theme 配置","id":"theme-配置","depth":3,"charIndex":2406}],"domain":"","content":"#\n\nModern.js 内置多种常用的 CSS 开发方案，包括 Less / Sass / Stylus 预处理器、PostCSS、CSS\nModules、CSS-in-JS 和 Tailwind CSS。\n\n\n使用 Less、Sass 和 Stylus#\n\nModern.js 内置了社区流行的 CSS 预处理器，包括 Less 和 Sass。\n\n默认情况下，你不需要对 Less 和 Sass 进行任何配置。如果你有自定义 loader 配置的需求，可以通过配置 tools.less、tools.sass\n来进行设置。\n\n你也可以在 Modern.js 中使用 Stylus，只需要安装 Modern.js Builder 提供的 Stylus 插件即可，使用方式请参考\nStylus 插件。\n\n\n使用 PostCSS#\n\nModern.js 内置了 PostCSS 来转换 CSS 代码。\n\n请阅读 Modern.js Builder - 使用 PostCSS 了解更多用法。\n\n\n使用 CSS Modules#\n\n请阅读 使用 CSS Modules 章节来了解 CSS Modules 的完整用法。\n\n\n使用 CSS-in-JS#\n\nCSS-in-JS 是一种可以将 CSS 样式写在 JS 文件里的技术。\n\nModern.js 集成了社区常用的 CSS-in-JS 实现库 styled-components，它使用 JavaScript 的新特性 Tagged\ntemplate 编写组件的 CSS 样式。可以直接从 @modern-js/runtime/styled 引入 styled-components 的 API\n进行使用。\n\n当需要编写一个内部字体为红色的 div 组件时，可以如下实现：\n\n\n\nconst RedDiv = styled.div`\n  color: red;\n`;\n\n\n当需要根据组件的 props 动态设置组件样式时，例如 props 的属性 primary 为 true 时，按钮的颜色为白色，其他情况为红色，实现代码如下：\n\n\n\nconst Button = styled.button`\n  color: ${props => (props.primary ? 'white' : 'red')};\n  font-size: 1em;\n`;\n\n\n关于 styled-components 的更多用法，请参考 styled-components 官网。\n\nModern.js 内部集成了 Babel 的 babel-plugin-styled-components 插件，你可以通过\ntools.styledComponents 对插件进行配置。\n\n提示\n\n如果需要使用 styled-jsx、Emotion 等其他 CSS-in-JS 库，需要先安装对应库的依赖。具体使用方式请参考对应库的官网。\n\n\n使用 Tailwind CSS#\n\nTailwind CSS 是一个以 Utility Class 为基础的 CSS 框架和设计系统，可以快速地为组件添加常用样式，同时支持主题样式的灵活扩展。在\nModern.js 中使用 Tailwind CSS，只需要在项目根目录下执行 pnpm run new 并开启。\n\n按照如下进行选择：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用 「Tailwind CSS」 支持\n\n\n在 modern.config.ts 中注册 Tailwind 插件:\n\n\n\nexport default defineConfig({\n  plugins: [..., tailwindcssPlugin()],\n});\n\n\n使用时在入口的根组件(如 src/App.jsx)添加如下代码：\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\n\n\n然后即可在各个组件中使用 Tailwind CSS 提供的 Utility Class 了：\n\nconst App = () => (\n  \n\n    \n\nhello world\n  \n);\n\n\n补充信息\n\n根据需求不同，你可以选择性的导入 Tailwind CSS 提供的 CSS 文件。由于使用 @tailwind 与直接导入 CSS 文件的作用等价，因此关于\nTailwind CSS 提供的 CSS 文件的用途，可以参考 @tailwind 的使用 文档中注释里的内容。\n\n\nTailwind CSS 版本#\n\nModern.js 同时支持 Tailwind CSS v2 和 v3 版本，框架会识别项目 package.json 中的 tailwindcss\n依赖版本，并启用相应的配置。默认情况下，我们会为你安装 Tailwind CSS v3 版本。\n\n如果你的项目仍在使用 Tailwind CSS v2，我们推荐你升级到 v3 以支持 JIT 等能力。关于 Tailwind CSS v2 与 v3\n版本之间的差异，请参考以下文章：\n\n * Tailwind CSS v3.0\n * Upgrade Guide\n\n\n浏览器兼容性#\n\nTailwind CSS v2 和 v3 均不支持 IE 11 浏览器，相关背景请参考：\n\n * Tailwind CSS v3 - Browser Support。\n * Tailwind CSS v2 - Browser Support\n\n如果你在 IE 11 浏览器上使用 Tailwind CSS，可能会出现部分样式不可用的现象，请谨慎使用。\n\n\nTheme 配置#\n\n当需要自定义 Tailwind CSS 的 theme 配置的时候，可以在配置 source.designSystem 中修改，例如，颜色主题中增加一个\nprimary：\n\nexport default defineConfig({\n  source: {\n    designSystem: {\n      extend: {\n        colors: {\n          primary: '#5c6ac4',\n        },\n      },\n    },\n  },\n});\n\n\n当需要对 Tailwind CSS 做 theme 以外的其他特殊配置时，可以在 tools.tailwindcss 中配置，例如设置 variants：\n\nexport default defineConfig({\n  tools: {\n    tailwindcss: {\n      variants: {\n        extend: {\n          backgroundColor: ['active'],\n        },\n      },\n    },\n  },\n});\n\n\n> 当你为项目配置 Tailwind CSS 的时候，source.designSystem 和 tools.tailwindcss\n> 这两个配置的组合等价于单独配置了一个 tailwindcss.config.js 文件。其中 source.designSystem 等效于\n> Tailwind CSS 的 theme 配置。","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/basic-features/css.mdx","_relativePath":"zh/guides/basic-features/css.mdx"},{"id":516,"title":"数据获取","routePath":"/guides/basic-features/data-fetch","lang":"zh","toc":[{"text":"Data Loader(推荐)","id":"data-loader(推荐)","depth":2,"charIndex":117},{"text":"基础示例","id":"基础示例","depth":3,"charIndex":346},{"text":"loader 函数","id":"loader-函数","depth":3,"charIndex":1379},{"text":"params","id":"params","depth":4,"charIndex":1408},{"text":"request","id":"request","depth":4,"charIndex":1722},{"text":"返回值","id":"返回值","depth":4,"charIndex":2004},{"text":"请求 API","id":"请求-api","depth":3,"charIndex":2488},{"text":"错误处理","id":"错误处理","depth":3,"charIndex":2718},{"text":"获取上层组件的数据","id":"获取上层组件的数据","depth":3,"charIndex":3284},{"text":"(WIP)Loading UI","id":"(wip)loading-ui","depth":3,"charIndex":4090},{"text":"错误用法","id":"错误用法","depth":3,"charIndex":4813},{"text":"常见问题","id":"常见问题","depth":3,"charIndex":5990},{"text":"useLoader（旧版）","id":"useloader（旧版）","depth":2,"charIndex":6170}],"domain":"","content":"#\n\nModern.js 中提供了开箱即用的数据获取能力，开发者可以通过这些 API，在 CSR 和 SSR 环境同构的进行开发。\n\n需要注意的是，这些 API 并不帮助应用发起请求，而是帮助开发者更好地管理数据，提升项目的性能。\n\n\nData Loader(推荐)#\n\nModern.js 推荐使用约定式路由做路由的管理，通过 Modern.js 的约定式（嵌套）路由，每个路由组件(layout.ts 或\npage.ts)可以有一个同名的 loader 文件，该 loader 文件需要导出一个函数，函数会在组件渲染之前执行，为路由组件提供数据。\n\nINFO\n\nModern.js v1 支持通过 useLoader 获取数据，这已经不是我们推荐的用法，除迁移过程外，不推荐两者混用。\n\n\n基础示例#\n\n路由组件如 layout.ts 或 page.ts，可以定义同名的 loader 文件，loader\n文件中导出一个函数，该函数提供组件所需的数据，然后在路由组件中通过 useLoaderData 函数获取数据，如下面示例：\n\n.\n└── routes\n    ├── layout.tsx\n    └── user\n        ├── layout.tsx\n        ├── layout.loader.ts\n        ├── page.tsx\n        └── page.loader.ts\n\n\n在文件中定义以下代码：\n\n\n\n\nexport default function UserPage() {\n  const profileData = useLoaderData() as ProfileData;\n  return \n{profileData};\n}\n\n\nexport type ProfileData = {\n  /*  some types */\n};\n\nexport default async (): Promise => {\n  const res = await fetch('https://api/user/profile');\n  return await res.json();\n};\n\n\nCAUTION\n\n这里路由组件和 loader 文件共享类型，要使用 import type 语法。\n\n在 CSR 环境下，loader 函数会在客户端执行，loader 函数内可以使用浏览器的 API（但通常不需要，也不推荐）。\n\n在 SSR 环境下，不管是首屏，还是在客户端的导航，loader 函数只会在服务端执行，这里可以调用任意的 Node.js\nAPI，同时这里使用的任何依赖和代码都不会包含在客户端的 bundle 中。\n\nINFO\n\n在以后的版本中，Modern.js 可能会支持在 CSR 环境下，loader 函数也在服务端运行，以提高性能和安全性，所以这里建议尽可能地保证 loader\n的纯粹，只做数据获取的场景。\n\n当在客户端导航时，基于 Modern.js 的约定式路由，所有的 loader 函数会并行执行（请求），即当访问 /user/profile 时，/user 和\n/user/profile 下的 loader 函数都会并行执行（请求），以提高客户端的性能。\n\n\nloader 函数#\n\nloader 函数有两个入参：\n\nparams#\n\n当路由文件通过 [] 时，会作为动态路由，动态路由片段会作为参数传入 loader 函数：\n\n// routes/user/[id]/page.loader.ts\n\n\nexport default async ({ params }: LoaderFunctionArgs) => {\n  const { id } = params;\n  const res = await fetch(`https://api/user/${id}`);\n  return res.json();\n};\n\n\n当访问 /user/123 时，loader 函数的参数为 { params: { id: '123' } }。\n\nrequest#\n\nrequest 是一个 Fetch Request 实例。\n\n一个常见的使用场景是通过 request 获取查询参数：\n\n// routes/user/[id]/page.loader.ts\n\n\nexport default async ({ request }: LoaderFunctionArgs) => {\n  const url = new URL(request.url);\n  const userId = url.searchParams.get('id');\n  return queryUser(userId);\n};\n\n\n返回值#\n\nloader 函数的返回值可以是任何可序列化的内容，也可以是一个 Fetch Response 实例：\n\nconst loader = async (): Promise => {\n  return {\n    message: 'hello world',\n  };\n};\nexport default loader;\n\n\n默认情况下，loader 返回的响应 Content-type 是 application/json，status 为 200，你可以通过自定义\nResponse 来设置：\n\nconst loader = async (): Promise => {\n  const data = { message: 'hello world' };\n  return new Response(JSON.stringify(data), {\n    status: 200,\n    headers: {\n      'Content-Type': 'application/json; utf-8',\n    },\n  });\n};\n\n\n\n请求 API#\n\nModern.js 对 fetch API 做了 polyfill, 用于发起请求，该 API 与浏览器的 fetch API 一致，但是在服务端也能使用该\nAPI 发起请求，这意味着不管是 CSR 还是 SSR，都可以使用统一的 fetch API 进行数据获取：\n\nasync function loader() {\n  const res = await fetch('https://api/user/profile');\n}\n\n\n\n错误处理#\n\n在 loader 函数中，可以通过 throw error 或者 throw response 的方式处理错误，当 loader\n函数中有错误被抛出时，Modern.js 会停止执行当前 loader 中的代码，并将前端 UI 切换到定义的 ErrorBoundary 组件：\n\n// routes/user/profile/page.loader.ts\nexport default async function loader() {\n  const res = await fetch('https://api/user/profile');\n  if (!res.ok) {\n    throw res;\n  }\n  return res.json();\n}\n\n// routes/user/profile/error.tsx\n\nconst ErrorBoundary = () => {\n  const error = useRouteError() as Response;\n  return (\n    \n\n      \n\n\n{error.status}\n      \n\n\n{error.statusText}\n    \n  );\n};\n\nexport default ErrorBoundary;\n\n\n\n获取上层组件的数据#\n\n很多场景下，子组件需要获取到祖先组件 loader 中的数据，你可以通过 useRouteLoaderData 方便地获取到祖先组件的数据：\n\n// routes/user/profile/page.tsx\n\n\nexport default function UserLayout() {\n  // 获取 routes/user/layout.loader.ts 中 `loader` 返回的数据\n  const data = useRouteLoaderData('user/layout');\n  return (\n    \n\n      \n\n\n{data.name}\n      \n\n\n{data.age}\n    \n  );\n}\n\n\nuserRouteLoaderData 接受一个参数 routeId，在使用约定式路由时，Modern.js 会为你自动生成routeId，routeId\n的值是对应组件相对于 src/routes 的路径，如上面的例子中，子组件想要获取 routes/user/layout.tsx 中 loader\n返回的数据，routeId 的值就是 user/layout。\n\n在多入口（MPA） 场景下，routeId 的值需要加上对应入口的名称，入口名称非指定情况下一般是入口的目录名，如以下目录结构：\n\n.\n└── src\n    ├── entry1\n    │     └── routes\n    │           └── layout.tsx\n    └── entry2\n          └── routes\n                └── layout.tsx\n\n\n如果想获取 entry1/routes/layout.tsx 中 loader 返回的数据，routeId 的值就是 entry1_layout。\n\n\n(WIP)Loading UI#\n\nINFO\n\n此功能目前是实验性质，后续 API 可能有调整。\n\n目前仅支持 CSR，敬请期待 Streaming SSR。\n\n创建 user/layout.loader.ts，并添加以下代码：\n\n\n\nconst loader = () =>\ndefer({\n  userInfo: new Promise((resolve) => {\n      setTimeout(() => {\n        resolve({\n          age: 1,\n          name: 'user layout'\n        })\n      }, 1000)\n    })\n  })\n\nexport default loader;\n\n\n在 user/layout.tsx 中添加以下代码：\n\n\n\nexport default function UserLayout() {\n  const { userInfo } = useLoaderData() as { userInfo: Promise };\n  return (\n    \n\n      Loading...\n\n}>\n         (\n            \n\n\n              {userInfo.name}\n              {userInfo.age}\n              \n            \n          )}\n        >\n      \n    \n  );\n}\n\n\nINFO\n\nAwait 组件的具体用法请查看 Await\n\ndefer 的具体用法请查看 defer\n\n\n错误用法#\n\n 1. loader 中只能返回可序列化的数据，在 SSR 环境下，loader 函数的返回值会被序列化为 JSON\n    字符串，然后在客户端被反序列化为对象。因此，loader 函数中不能返回不可序列化的数据（如函数）。\n\nWARNING\n\n目前 CSR 下没有这个限制，但我们强烈推荐你遵循该限制，且未来我们可能在 CSR 下也加上该限制。\n\n// This won't work!\nexport default () => {\n  return {\n    user: {},\n    method: () => {},\n  };\n};\n\n\n 2. Modern.js 会帮你调用 loader 函数，你不应该自己调用 loader 函数：\n\n// This won't work!\nexport default async () => {\n  const res = fetch('https://api/user/profile');\n  return res.json();\n};\n\n\nexport default function RouteComp() {\n  const data = loader();\n}\n\n\n 3. 不能从路由组件中引入 loader 文件，也不能从 loader 文件引入路由组件中的变量，如果需要共享类型的话，应该使用 import type\n\n// Not allowed\n// routes/layout.tsx\n\n // should use \"import type\" instead\n\nexport const fetch = wrapFetch(fetch);\n\nexport default function UserPage() {\n  const profileData = useLoaderData() as ProfileData;\n  return \n{profileData};\n}\n\n// routes/layout.loader.ts\n // should not be imported from the routing component\nexport type ProfileData = {\n  /*  some types */\n};\n\nexport default async (): Promise => {\n  const res = await fetch('https://api/user/profile');\n  return await res.json();\n};\n\n\n 4. 在服务端运行时，loader 函数会被打包为一个统一的 bundle，所以我们不推荐服务端的代码使用 __filename 和 __dirname。\n\n\n常见问题#\n\n 1. loader 和 BFF 函数的关系\n\n在 CSR 项目中，loader 在客户端执行，在 loader 可以直接调用 BFF 函数进行接口请求。\n\n在 SSR 项目中，每个 loader 也是一个服务端接口，我们推荐使用 loader 替代 http method 为 get 的 BFF\n函数，作为接口层，避免多一层转发和执行。\n\n\nuseLoader（旧版）#\n\nuseLoader 是 Modern.js 老版本中的 API。该 API 是一个 React Hook，专门提供给 SSR\n应用使用，让开发者能同构的在组件中获取数据。\n\nTIP\n\nCSR 的项目没有必要使用 useLoader 获取数据。\n\n以下是一个最简单的例子：\n\n\n\nexport default () => {\n  const { data } = useLoader(async () => {\n    console.log('fetch in useLoader');\n\n    // 这里没有发送真实的请求，只是返回了一个写死的数据。\n    // 真实项目中，应该返回从远端获取的数据。\n    return {\n      name: 'Modern.js',\n    };\n  });\n\n  return \nHello, {data?.name};\n};\n\n\n上述代码启动后，访问页面。可以看到在终端输出了日志，而在浏览器终端却没有打印日志。\n\n这是因为 Modern.js 在服务端渲染时，在会收集 useLoader 返回的数据，并将数据注入到响应的 HTML 中。如果 SSR 渲染成功，在 HTML\n中可以看到如下代码片段：\n\n\n\n\n在这全局变量中，记录了每一份数据，而在浏览器端渲染的过程中，会优先使用这份数据。如果数据不存在，则会重新执行 useLoader 函数。\n\nNOTE\n\n在构建阶段，Modern.js 会自动为每个 useLoader 生成一个 Loader ID，并注入到 SSR 和 CSR 的 JS Bundle\n中，用来关联 Loader 和数据。\n\n相比于 Next.js 中的 getServerSideProps，在渲染前预先获取数据。使用 useLoader，可以在组件中获取局部 UI\n所需要的数据，而不用将数据层层传递。同样，也不会因为不同路由需要不同数据请求，而在最外层的数据获取函数中添加冗余的逻辑。当然 useLoader\n也存在一些问题，例如服务端代码 Treeshaking 困难，服务端需要多一次预渲染等。\n\nModern.js 在新版本中，设计了全新的 Loader 方案。新方案解决了这些问题，并能够配合嵌套路由，对页面性能做优化。\n\nNOTE\n\n详细 API 可以查看 useLoader。","frontmatter":{"title":"数据获取","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/basic-features/data-fetch.mdx","_relativePath":"zh/guides/basic-features/data-fetch.mdx"},{"id":517,"title":"环境变量","routePath":"/guides/basic-features/env-vars","lang":"zh","toc":[{"text":"内置的环境变量","id":"内置的环境变量","depth":2,"charIndex":46},{"text":"ASSET_PREFIX","id":"asset_prefix","depth":3,"charIndex":57},{"text":"NODE_ENV","id":"node_env","depth":3,"charIndex":99},{"text":"MODERN_ENV","id":"modern_env","depth":3,"charIndex":290},{"text":"MODERN_TARGET","id":"modern_target","depth":3,"charIndex":402},{"text":"自定义环境变量","id":"自定义环境变量","depth":2,"charIndex":1096},{"text":"通过 shell 指定","id":"通过-shell-指定","depth":3,"charIndex":1140},{"text":"通过 .env 文件指定","id":"通过-env-文件指定","depth":3,"charIndex":1212},{"text":"使用环境变量","id":"使用环境变量","depth":2,"charIndex":1550},{"text":"约定命名","id":"约定命名","depth":3,"charIndex":1560},{"text":"任意命名","id":"任意命名","depth":3,"charIndex":1833},{"text":"使用全局替换","id":"使用全局替换","depth":2,"charIndex":2132}],"domain":"","content":"#\n\nModern.js 提供了对环境变量的支持，包含内置的环境变量和自定义的环境变量。\n\n\n内置的环境变量#\n\n\nASSET_PREFIX#\n\n表示当前资源文件的路径前缀，是只读的的环境变量。\n\n\nNODE_ENV#\n\n表示当前的执行环境，是只读的的环境变量，其值在不同的执行命令下具有不同的值：\n\n * production：执行 modern build、modern serve 命令时的默认值。\n * test：执行 modern test 命令时的默认值。\n * development：执行 modern dev 命令时的默认值，同时也是其他所有情况下的默认值。\n\n\nMODERN_ENV#\n\n手动设置当前的执行环境。除了上述 NODE_ENV 对应的值之外，这里支持自定义环境名称，例如 staging、boe 等。\n\nTIP\n\nMODERN_ENV 的优先级高于 NODE_ENV。\n\n\nMODERN_TARGET#\n\n使用 @modern-js/runtime 时，Modern.js 会自动注入 MODERN_TARGET，用于区分 SSR 与 CSR 环境。\n\n你可以在代码中通过 process.env.MODERN_TARGET 来判断环境，并执行相应的逻辑。\n\nfunction App() {\n  if (process.env.MODERN_TARGET === 'browser') {\n    console.log(window.innerHeight);\n  }\n}\n\n\n在开发环境构建完成后，可以看到 SSR 产物和 CSR 产物如下：\n\n// SSR 产物\nfunction App() {\n  if (false) {\n  }\n}\n\n\n// CSR 产物\nfunction App() {\n  if (true) {\n    console.log(window.innerHeight);\n  }\n}\n\n\n这种方式可以针对不同客户端提供不同的产物，保证代码体积最小化；也便于处理不同环境下代码中的一些副作用。\n\n死代码移除\n\n在生产环境，Terser 和 SWC 等代码压缩工具会分析代码，并将 dead code 移除，从而减少产物体积，这个过程被称为死代码移除（DCE）。\n\n例如，上述 if (false) 语句包含的代码会被移除，而 if (true) 包含的代码将被保留。\n\n如果你未按照上述写法来使用 process.env.MODERN_TARGET，代码压缩工具可能会无法分析出 dead code，从而导致产物体积增大。\n\n\n自定义环境变量#\n\n环境变量支持通过 shell 和 .env 文件两种方式指定。\n\n\n通过 shell 指定#\n\n在命令前添加自定义环境变量：\n\nREACT_APP_FOO=123 BAR=456 pnpm run dev\n\n\n\n通过 .env 文件指定#\n\n在项目根目录创建 .env 文件，并添加自定义环境变量，这些环境变量会默认添加到启动项目的 Node.js 进程中，例如：\n\nREACT_APP_FOO=123\nBAR=456\n\n\n.env 文件遵循以下规则加载规则：\n\n * .env：默认加载。\n * .env.{ MODERN_ENV | NODE_ENV }：针对具体环境设置环境变量，会覆盖 .env 中的设置。\n\n当需要根据环境使用不同的配置时，可以把环境变量定义到对应环境名称的 .env 文件中，并在启动项目时手动设置执行环境。例如使用以下命令启动项目时，将会加载\n.env 和 .env.staging:\n\nMODERN_ENV=staging pnpm run dev\n\n\n\n使用环境变量#\n\n\n约定命名#\n\n在前端代码中可以直接使用 NODE_ENV 环境变量。另外，以 MODERN_ 开头的自定义环境变量，也可以在代码中直接使用。\n\n例如:\n\nif (process.env.NODE_ENV === 'development') {\n  // do something\n}\n\n\n执行 pnpm run dev 命令之后可以看到如下构建产物：\n\nif (true) {\n  // do something\n}\n\n\n同样在自定义的 HTML 模板中，也可以直接使用这类环境变量。如 config/html/head.html:\n\n\n\n\n\n任意命名#\n\n如果需要在代码中使用任意名称的环境变量，可以在 source.globalVars 配置指定, 例如：\n\nexport default defineConfig({\n  source: {\n    globalVars: {\n      'process.env.VERSION': process.env.VERSION,\n    }.\n  },\n});\n\n\n此时，在代码中的 process.env.VERSION，将会被替换为环境变量中 VERSION 的值。\n\nNOTE\n\nsource.globalVars 也支持将其他表达式或字符串替换为指定的值，不仅限于环境变量。\n\n\n使用全局替换#\n\n除了环境变量，Modern.js 也支持将代码中的变量替换成其它值或者表达式，可以用于在代码逻辑中区分开发环境与生产环境等场景。\n\n例如将代码中的 TWO 转换为 1 + 1 的表达式：\n\nexport default {\n  source: {\n    define: {\n      TWO: '1 + 1',\n    },\n  },\n};\n\n\nconst foo = TWO;\n\n// ⬇️ Turn into being...\nconst foo = 1 + 1;\n\n\n在大多数情况下，source.globalVars 已经能满足替换变量的需求。但 source.globalVars 传入的值都会默认被 JSON\n序列化，因此无法做出像上面例子中 1 + 1 的替换，此时就需要使用 source.define。","frontmatter":{"title":"环境变量","sidebar_position":7},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/basic-features/env-vars.mdx","_relativePath":"zh/guides/basic-features/env-vars.mdx"},{"id":518,"title":"HTML 模板","routePath":"/guides/basic-features/html","lang":"zh","toc":[{"text":"JSX 语法","id":"jsx-语法","depth":2,"charIndex":-1},{"text":"HTML 组件","id":"html-组件","depth":3,"charIndex":-1},{"text":"模板参数","id":"模板参数","depth":3,"charIndex":-1},{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"Html 语法","id":"html-语法","depth":2,"charIndex":-1},{"text":"自定义 HTML 片段","id":"自定义-html-片段","depth":3,"charIndex":-1},{"text":"完全自定义 HTML 模板","id":"完全自定义-html-模板","depth":3,"charIndex":-1},{"text":"模板参数","id":"模板参数-1","depth":3,"charIndex":-1},{"text":"按入口设置","id":"按入口设置","depth":3,"charIndex":-1}],"domain":"","content":"以下为构建时传过来的参数：\n\n\nentryName：{entryName}\n\n\ntitle：{htmlConfig.title}\n\n\nrootId: {templateParams.mountId}\n\n\nbottom\n\n\n以下为构建时传过来的参数：\n\n\nentryName：sub\n\n\ntitle：\n\n\nrootId: root\n\n\nbottom\n\nWe're sorry but react app doesn't work properly without JavaScript enabled.\nPlease enable it to continue.\n\n<%= bodyTemplate %> {/* webpack inject js */} {/* */}","frontmatter":{"title":"HTML 模板","sidebar_position":9},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/basic-features/html.mdx","_relativePath":"zh/guides/basic-features/html.mdx"},{"id":519,"title":"数据模拟","routePath":"/guides/basic-features/mock","lang":"zh","toc":[{"text":"启用 Mock","id":"启用-mock","depth":2,"charIndex":55},{"text":"编写 Mock 文件","id":"编写-mock-文件","depth":2,"charIndex":215},{"text":"返回随机数据","id":"返回随机数据","depth":2,"charIndex":790},{"text":"延迟响应","id":"延迟响应","depth":2,"charIndex":1076},{"text":"按需使用 Mock 服务","id":"按需使用-mock-服务","depth":2,"charIndex":1273}],"domain":"","content":"#\n\nModern.js 提供了快速生成 Mock 数据的功能，能够让前端独立自主开发，不被后端接口阻塞。\n\n\n启用 Mock#\n\n约定当 config/mock 目录下存在 index.[jt]s 时，会自动开启 Mock 功能，如下：\n\n.\n├── config\n│   └── mock\n│       └── index.ts\n├── src\n│   └── App.tsx\n└── modern.config.ts\n\n\n\n编写 Mock 文件#\n\nconfig/mock/index.ts 文件只需要导出一个包含所有 Mock API 的对象，对象的属性由请求配置 method 和 url\n组成，对应的属性值可以为 Object、Array、Function：\n\nexport default {\n  /* 属性为具体的 method 和 请求 url，值为 object 或 array 作为请求的结果 */\n  'GET /api/getInfo': { data: [1, 2, 3, 4] },\n\n  /* method 默认为 GET */\n  '/api/getExample': { id: 1 },\n\n  /* 可以使用自定义函数根据请求动态返回数据, req & res 都是 Node.js HTTP 原生对象 */\n  'POST /api/addInfo': (req, res, next) => {\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.end('200');\n  },\n};\n\n\n代码中访问 http://localhost:8080/api/getInfo 时，接口会返回 JSON 格式数据：{ \"data\": [1, 2, 3, 4]\n}。\n\n\n返回随机数据#\n\n可以在 config/mock/index.js 中自主引入 Mock.js 等库生成随机数据，例如：\n\nconst Mock = require('mockjs');\n\nmodule.exports = {\n  '/api/getInfo': Mock.mock({\n    'data|1-10': [{ name: '@cname' }],\n  }) /* => {data: [{name: \"董霞\"}, {name: \"魏敏\"},  {name: \"石磊\"}} */,\n};\n\n\n更多随机数据生成库\n * Chancejs\n * Mock\n\n\n延迟响应#\n\n * 可以使用浏览器「 弱网模拟 」的功能实现。\n * 可以通过 setTimeout 为单个接口设置延迟，例如：\n\nmodule.exports = {\n  'api/getInfo': (req, res) => {\n    setTimeout(() => {\n      res.end('delay 2000ms');\n    }, 2000);\n  },\n};\n\n\n\n按需使用 Mock 服务#\n\nconfig/mock/index.ts 下还可以到处 config 对象，更精细的控制 Mock 服务。\n\ntype MockConfig = {\n  enable: ((req: IncomingMessage, res: ServerResponse) => boolean) | boolean;\n};\n\nexport const config = {\n  enable: false\n}\n\n\n目前仅支持 enable 配置，开发者可以通过该配置控制是否执行 Mock。\n\nNOTE\n\n修改 config 后无需重启服务，即刻生效。","frontmatter":{"title":"数据模拟","sidebar_position":6},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/basic-features/mock.mdx","_relativePath":"zh/guides/basic-features/mock.mdx"},{"id":520,"title":"代理","routePath":"/guides/basic-features/proxy","lang":"zh","toc":[{"text":"本地代理","id":"本地代理","depth":2,"charIndex":3},{"text":"全局代理","id":"全局代理","depth":2,"charIndex":395},{"text":"设置代理规则","id":"设置代理规则","depth":3,"charIndex":515},{"text":"代理服务器 UI 界面","id":"代理服务器-ui-界面","depth":3,"charIndex":638},{"text":"BFF 代理","id":"bff-代理","depth":2,"charIndex":954}],"domain":"","content":"#\n\n\n本地代理#\n\nModern.js 在 tools.devServer 中提供了配置开发环境代理的方式。例如，将本地开发接口，代理到线上某个地址：\n\n\n\nexport default defineConfig({\n  tools: {\n    devServer: {\n      proxy: {\n        '/go/api': {\n          target: 'http://www.example.com/',\n          changeOrigin: true,\n        },\n      },\n    },\n  },\n});\n\n\n请求 http://localhost:8080/go/api 时，会从 http://www.example.com/ 返回响应内容。\n\n补充信息\n\n配置格式可参考：http-proxy-middleware。\n\n\n全局代理#\n\nModern.js 提供了开箱即用的全局代理插件 @modern-js/plugin-proxy，该插件底层基于 whistle，可用来查看、修改\nHTTP/HTTPS 的请求和响应，也可作为 HTTP 代理服务器使用。\n\n\n设置代理规则#\n\n引入代理插件并填写规则后，执行 pnpm run dev，Modern.js 会在开发服务器启动之后，自动启用代理服务器。\n\n具体代理规则，可通过 dev.proxy 选项或 config/proxy.js 文件进行设置。\n\n\n代理服务器 UI 界面#\n\n安装代理插件并配置代理规则后， 执行 pnpm run dev 命令：\n\n  App running at:\n\n  Local:    http://localhost:8080/\n  Network:  http://192.168.0.1:8080/\n\nℹ  info      Starting the proxy server.....\n✔  success   Proxy Server start on localhost:8899\n\n\n在控制台中可以看到代理服务器成功启动。\n\n访问 http://localhost:8899，显示下图所示的 UI 界面后，即可通过界面设置规则。\n\n\n\n\nBFF 代理#\n\n通过配置 bff.proxy 可以代理 BFF API 请求到指定的服务上，上述两种代理不同，它同样可以用在生产环境：\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api/v1': 'https://cnodejs.org',\n    },\n  },\n});\n\n\n例如代码中使用一体化 BFF 调用时，最终请求 http://localhost:8080/api/v1/topics 会自动代理到\nhttps://cnodejs.org/api/v1/topics：\n\n\n\ngetTopics();\n","frontmatter":{"title":"代理","sidebar_position":5},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/basic-features/proxy.mdx","_relativePath":"zh/guides/basic-features/proxy.mdx"},{"id":521,"title":"路由","routePath":"/guides/basic-features/routes","lang":"zh","toc":[{"text":"约定式路由","id":"约定式路由","depth":2,"charIndex":127},{"text":"路由文件约定","id":"路由文件约定","depth":3,"charIndex":725},{"text":"Layout","id":"layout","depth":4,"charIndex":1378},{"text":"Page","id":"page","depth":4,"charIndex":2169},{"text":"动态路由","id":"动态路由","depth":3,"charIndex":2232},{"text":"动态可选路由","id":"动态可选路由","depth":3,"charIndex":2537},{"text":"通配路由","id":"通配路由","depth":3,"charIndex":2895},{"text":"无路径布局","id":"无路径布局","depth":3,"charIndex":3364},{"text":"无布局路径","id":"无布局路径","depth":3,"charIndex":3752},{"text":"(WIP)Loading","id":"(wip)loading","depth":3,"charIndex":4080},{"text":"路由重定向","id":"路由重定向","depth":3,"charIndex":4728},{"text":"错误处理","id":"错误处理","depth":3,"charIndex":4972},{"text":"运行时配置","id":"运行时配置","depth":3,"charIndex":5428},{"text":"渲染前的钩子","id":"渲染前的钩子","depth":3,"charIndex":5725},{"text":"预加载","id":"预加载","depth":3,"charIndex":6700},{"text":"常见问题","id":"常见问题","depth":4,"charIndex":7310},{"text":"自控式路由","id":"自控式路由","depth":2,"charIndex":7501},{"text":"其他路由方案","id":"其他路由方案","depth":2,"charIndex":7800}],"domain":"","content":"#\n\nModern.js 的路由基于 React Router 6，并提供了多种类型的路由模式。根据不同 入口\n类型，将路由分为三种模式，分别是约定式路由，自控式路由和其他路由方案。\n\nNOTE\n\n本小节提到的路由，都是客户端路由，即 SPA 路由。\n\n\n约定式路由#\n\n以 routes/ 为约定的入口，Modern.js 会自动基于文件系统，生成对应的路由结构。\n\nModern.js 支持了业界流行的约定式路由模式：嵌套路由，使用嵌套路由时，页面的路由 与 UI 结构是相呼应的，我们将会详细介绍这种路由模式。\n\n/user/johnny/profile                  /user/johnny/posts\n+------------------+                  +-----------------+\n| User             |                  | User            |\n| +--------------+ |                  | +-------------+ |\n| | Profile      | |  +------------>  | | Posts       | |\n| |              | |                  | |             | |\n| +--------------+ |                  | +-------------+ |\n+------------------+                  +-----------------+\n\n\n\n路由文件约定#\n\n在routes/ 目录下，目录名会作为路由 url 的映射，Modern.js 有两个文件约定 layout.[jt]sx 和\npage.[jt]sx（后面简写为 .tsx）。这两个文件决定了应用的布局层次，其中 layout.tsx 中作为布局组件，page.tsx\n作为内容组件，是整条路由的叶子节点（一条路由有且仅有一个叶子节点，且必须以叶子节点结尾）。\n\n例如以下目录结构：\n\n.\n└── routes\n    ├── page.tsx\n    └── user\n        └── page.tsx\n\n\n会产出下面两条路由：\n\n * /\n * /user\n\n当添加 layout.tsx 后， 假设有以下目录\n\nINFO\n\n这里 routes/layout.tsx 会作为 / 路由下所有组件的布局组件使用， routes/user/layout.tsx 会作为 /user\n路由下所有路由组件的布局组件使用。\n\n.\n└── routes\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n当路由为 / 时，会有以下 UI 布局：\n\n\n  \n\n\n\n同样，routes/user/layout.tsx 会作为 /user 路由下所有组件的布局组件使用。当路由为 /user 时， 会有以下 UI 布局：\n\n\n  \n    \n  \n\n\n\nLayout#\n\n组件是指 routes/ 目录下所有 layout.tsx 文件，它们表示对应路由片段的布局，使用 表示子组件。\n\n\n\nexport default () => {\n  return (\n    <>\n      \n    </>\n  );\n};\n\n\nNOTE\n\n是 React Router 6 中新的 API，详情可以查看 Outlet.\n\n为了方便介绍 与 的关系，以下面的文件目录举例：\n\n.\n└── routes\n    ├── blog\n    │   └── page.tsx\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n 1. 当路由为 / 时，routes/layout.tsx 中的 代表的是 routes/page.tsx 中导出的组件，生成以下 UI 结构：\n\n\n  \n\n\n\n 2. 当路由为 /blog 时，routes/layout.tsx 中的 代表的是 routes/blog/page.tsx 中导出的组件，生成以下 UI\n    结构：\n\n\n  \n\n\n\n 3. 当路由为 /user 时，routes/layout.tsx 中的 代表的是 routes/user/layout.tsx\n    中导出的组件。routes/user/layout.tsx 中的 代表的是 routes/user/page.tsx 中导出的组件。生成以下 UI\n    结构：\n\n\n  \n    \n  \n\n\n\n总结而言，如果子路由的文件目录下存在 layout.tsx，上一级 layout.tsx 中的 即为子路由文件目录下的 layout.tsx\n，否则为子路由文件目录下的 page.tsx。\n\nPage#\n\n所有的路由，理论上都应该由 组件结束。在 page.tsx 文件内，如果开发者引入 组件，不会有任何效果。\n\n\n动态路由#\n\n通过 [] 命名的文件目录，生成的路由会作为动态路由。例如以下文件目录：\n\n└── routes\n    ├── [id]\n    │   └── page.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\nroutes/[id]/page.tsx 文件会转为 /:id 路由。除了可以确切匹配的 /blog 路由，其他所有 /xxx 都会匹配到该路由。\n\n在组件中，可以通过 useParams 获取对应命名的参数。\n\n在 loader 中，params 会作为 loader 的入参，通过 params.xxx 可以获取。\n\n\n动态可选路由#\n\n通过 [$] 命名的文件目录，生成的路由会作为动态路由。例如以下文件目录：\n\n└── routes\n    ├── user\n    │   └── [id$]\n    │       └── page.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\nroutes/user/[id$]/page.tsx 文件会转为 /user/:id? 路由。/user 下的所有路由都会匹配到该路由，并且 id\n参数可选存在。通常在区分创建于编辑时，可以使用该路由。\n\n在组件中，可以通过 useParams 获取对应命名的参数。\n\n在 loader 中，params 会作为 loader 的入参，通过 params.xxx 可以获取。\n\n\n通配路由#\n\n如果在 routes 目录下创建 $.tsx 文件，该文件会作为通配路由组件，当没有匹配的路由时，会渲染该路由组件。\n\nNOTE\n\n$.tsx 可以认为是一种特殊的 page 路由组件，当前目录下有 layout 组件时，$.tsx，会作为 layout 的子组件渲染。\n\n例如以下目录结构：\n\n└── routes\n    ├── $.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\n当访问任何匹配不到的路径时，都会渲染 routes/$.tsx 组件，同样，$.tsx 中可以使用 useParams 捕获 url 的剩余部分。\n\n\n// 当 path 是 `/aaa/bbb` 时\nconst params = useParams();\nparams['*']; // => 'aaa/bbb'\n\n\n$.tsx 可以加入到 routes 目录下的任意目录中，一个常见的使用示例是添加 routes/$.tsx 文件去定制任意层级的 404 页面。\n\n\n无路径布局#\n\n当目录名以 __ 开头时，对应的目录名不会转换为实际的路由路径，例如以下文件目录：\n\n.\n└── routes\n    ├── __auth\n    │   ├── layout.tsx\n    │   ├── login\n    │   │   └── page.tsx\n    │   └── signup\n    │       └── page.tsx\n    ├── layout.tsx\n    └── page.tsx\n\n\nModern.js 会生成 /login 和 /sign 两条路由，__auth/layout.tsx 组件会作为 login/page.tsx 和\nsignup/page.tsx 的布局组件，但__auth 不会作为路由路径片段。\n\n当需要为某些类型的路由，做独立的布局，或是想要将路由做归类时，这一功能非常有用。\n\n\n无布局路径#\n\n有些情况下，项目需要较为复杂的路由，但这些路由又不存在独立的 UI 布局，如果像普通文件目录那边创建路由会导致目录层级较深。\n\n因此 Modern.js 支持了通过 . 来分割路由片段，代替文件目录。例如，当需要 /user/profile/2022/edit 时，可以直接创建如下文件：\n\n└── routes\n    ├── user.profile.[id].edit\n    │      └── page.tsx\n    ├── layout.tsx\n    └── page.tsx\n\n\n访问路由时，将得到如下 UI 布局：\n\n\n   // routes/user.profile.[id].edit/page.tsx\n\n\n\n\n(WIP)Loading#\n\nroutes/ 下每一层目录中，开发者可以创建 loading.tsx 文件，默认导出一个 组件。\n\n当路由目录下存在该组件和 layout 组件时，这一级子路由下所有的路由切换时，都会以该 组件作为 JS Chunk 加载时的 Fallback\nUI。例如以下文件目录：\n\n.\n└── routes\n    ├── blog\n    │   ├── [id]\n    │   │   └── page.tsx\n    │   └── page.tsx\n    ├── layout.tsx\n    ├── loading.tsx\n    └── page.tsx\n\n\n当定义 loading.tsx 时，就相当于以下布局：\n\n\n  }>\n    \n  \n\n\n\n\n  }>\n    \n  \n\n\n\n\n  }>\n    \n  \n\n\n\nINFO\n\n当目录的 Layout 组件不存在时，该目录下的 Loading 组件也不会生效。\n\nModern.js 建议必须有根 Layout 和根 Loading。\n\n当路由从 / 跳转到 /blog 时，如果 blog/page 组件的 JS Chunk 还未加载，则会先展示 loading.tsx 中导出的组件 UI。\n\n同理，当路由从 / 或者 /blog 跳转到 /blog/123 时，如果 blog/[id]/page 组件的 JS Chunk 还未加载，也会先展示\nloading.tsx 中导出的组件 UI。\n\n\n路由重定向#\n\n可以通过创建 Data Loader 文件做路由的重定向，如有文件 routes/user/page.tsx，想对这个文件对应的路由做重定向，可以创建\nroutes/user/page.loader.ts 文件：\n\n\n\nexport default () => {\n  const user = await getUser();\n  if (!user) {\n    return redirect('/login');\n  }\n  return null;\n};\n\n\n\n错误处理#\n\nroutes/ 下每一层目录中，开发者同样可以定义一个 error.tsx 文件，默认导出一个 组件。\n\n当有路由目录下存在该组件时，组件渲染出错会被 ErrorBoundary 组件捕获。当目录未定义 layout.tsx 文件时， 组件不会生效。\n\n可以返回出错时的 UI 视图，当前层级未声明\n组件时，错误会向上冒泡到更上层的组件，直到被捕获或抛出错误。同时，当组件出错时，只会影响捕获到该错误的路由组件及子组件，其他组件的状态和视图不受影响，可以继续交\n互。\n\n在 组件内，可以使用 useRouteError 获取的错误的具体信息：\n\n\nconst ErrorBoundary = () => {\n  const error = useRouteError();\n  return (\n    \n\n      \n\n\n{error.status}\n      \n\n\n{error.message}\n    \n  );\n};\nexport default ErrorBoundary;\n\n\n\n运行时配置#\n\n在每个根 Layout 组件中(routes/layout.ts)，可以动态地定义运行时配置：\n\n// 定义运行时配置\n\n\nexport const config = (): AppConfig => {\n  return {\n    router: {\n      createRoutes() {\n        return [\n          {\n            path: 'modern',\n            element: \nmodern,\n          },\n        ];\n      },\n    },\n  };\n};\n\n\n\n渲染前的钩子#\n\n在有些场景下，需要在应用渲染前做一些操作，可以在 routes/layout.tsx 中定义 init 钩子，init\n在客户端和服务端均会执行，基本使用示例如下：\n\n\n\nexport const init = (context: RuntimeContext) => {\n  // do something\n};\n\n\n通过 init 钩子可以挂载一些全局的数据，在应用的其他地方可以访问 runtimeContext 变量：\n\nNOTE\n\n该功能在应用需要页面前置的数据、自定义数据注入或是框架迁移（如 Next.js）时会非常有用。\n\n\n\nexport const init = (context: RuntimeContext) => {\n  return {\n    message: 'Hello World',\n  };\n};\n\n\n\n\nexport default () => {\n  const { context } = useRuntimeContext();\n  const { message } = context.getInitData();\n\n  return \n{message};\n};\n\n\n配合 SSR 功能时，浏览器端可以获取到 SSR 时 init 返回的数据，开发者可以自行判断是否要在浏览器端重新获取数据来覆盖 SSR 数据，例如：\n\n\n\nexport const init = (context: RuntimeContext) => {\n  if (process.env.MODERN_TARGET === 'node') {\n    return {\n      message: 'Hello World By Server',\n    };\n  } else {\n    const { context } = runtimeContext;\n    const data = context.getInitData();\n    // 如果没有获取到期望的数据\n    if (!data.message) {\n      return {\n        message: 'Hello World By Client',\n      };\n    }\n  }\n};\n\n\n\n预加载#\n\n在约定式路由下， Modern.js\n会根据路由，自动地对路由进行分片，当用户访问具体的路由时，会自动加载对应的分片，这样可以有效地减少首屏加载的时间。但这也带来了一个问题，当用户访问一个路由时，如\n果该路由对应的分片还未加载完成，就会出现白屏的情况。 这种情况下你可以通过定义 Loading 组件，在静态资源加载完成前，展示一个自定义的 Loading\n组件。\n\n为了进一步提升用户体验，减少 loading 的时间，Modern.js 支持在 Link 组件上定义 prefetch\n属性，可以提前对静态资源和数据进行加载：\n\n\n\n\nINFO\n * 该功能目前仅在 Webpack 项目中支持，Rspack 项目暂不支持。\n * 对数据的预加载目前只会预加载 SSR 项目中 Data Loader 中返回的数据。\n\nprefetch 属性有三个可选值：\n\n * none， 默认值，不会做 prefetch，没有任何额外的行为。\n * intent，这是我们推荐大多数场景下使用的值，当你把鼠标放在 Link 上时，会自动开始加载对应的分片和 Data Loader\n   中定义的数据，当鼠标移开时，会自动取消加载。在我们的测试中，即使是快速点击，也能减少大约 200ms 的加载时间。\n * render，当 Link 组件渲染时，就会加载对应的分片和 Data Loader 中定义的数据。\n\n常见问题#\n\n 1. 使用 render 和不根据路由做静态资源分片的区别？\n\n * 使用 render 可以指定哪些路由在首屏时，进行加载，同时你可以通过对渲染的控制，仅当 Link 组件进入到可视区域时，才对 Link 组件进行渲染。\n\n * 使用 render，仅在空闲时对静态资源进行加载，不会与首屏静态资源抢占网络。\n\n * 在 SSR 场景下，也会对数据进行预取。\n\n\n自控式路由#\n\n以 src/App.tsx 为约定的入口，Modern.js 不会对路由做额外的操作，开发者可以自行使用 React Router 6 的 API\n进行开发，例如：\n\n\n\nexport default () => {\n  return (\n    \n      \n        index} />\n        about} />\n      \n    \n  );\n};\n\n\nNOTE\n\nModern.js 默认对约定式路由做了一系列资源加载及渲染上的优化，并且提供了开箱即用的 SSR\n能力，而这些能力，在使用自控路由时，都需要开发者自行封装，推荐开发者使用约定式路由。\n\n\n其他路由方案#\n\n默认情况下，Modern.js 会开启内置的路由方案，即 React Router。\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n});\n\n\n如上述配置，当开启 runtime.router 配置时，Modern.js 会从 @modern-js/runtime/router 命名空间导出 React\nRouter 的 API 供开发者使用，保证开发者和 Modern.js 中使用同一份代码，并自动根据 router 配置包裹 Provider\n组件。另外，这种情况下，React Router 的代码会被打包到 JS 产物中。\n\n如果项目已经有自己的路由方案，或者不需要使用客户端路由，可以关闭这个功能。\n\nexport default defineConfig({\n  runtime: {\n    router: false,\n  },\n});\n\n\n如上述配置， 如果关闭了 runtime.router 配置，并直接使用 react-router-dom 进行项目路由管理时，还需要根据 React\nRouter 文档自行包裹 Provider。","frontmatter":{"title":"路由","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/basic-features/routes.mdx","_relativePath":"zh/guides/basic-features/routes.mdx"},{"id":522,"title":"构建引擎","routePath":"/guides/concept/builder","lang":"zh","toc":[{"text":"构建架构","id":"构建架构","depth":2,"charIndex":200},{"text":"构建文档","id":"构建文档","depth":2,"charIndex":322},{"text":"构建配置","id":"构建配置","depth":2,"charIndex":513},{"text":"构建能力","id":"构建能力","depth":2,"charIndex":833}],"domain":"","content":"#\n\nModern.js 的构建能力由 Modern.js Builder 提供。\n\nModern.js Builder 是 Modern.js 体系的核心组件之一，它是一个面向 Web 开发场景的构建引擎，可以脱离 Modern.js\n被独立使用。Modern.js Builder 同时支持 webpack 和 Rspack 等多种打包工具，默认情况下使用最成熟的 webpack 进行打包。\n\n\n构建架构#\n\n从构建的角度看，Modern.js 分为三层架构，从上到下依次是：\n\n * 上层研发框架：Modern.js。\n * 通用构建引擎：Modern.js Builder。\n * 底层打包工具：webpack 和 Rspack。\n\n\n构建文档#\n\n由于 Modern.js Builder 是一个可独立使用的模块，我们为它提供了单独的文档，文档地址为：modernjs.dev/builder。\n\n在该文档中，你可以了解到 Modern.js Builder\n的详细介绍，同时也可以找到各个构建能力的完整使用指南。当你遇到构建方面的需求或问题时，建议你优先阅读 Modern.js Builder 文档来解决。\n\n\n构建配置#\n\nModern.js 的配置继承自 Modern.js Builder，因此你可以在 Modern.js 中使用 Modern.js Builder\n提供的所有构建配置。\n\n以 Modern.js Builder 的 html.title 配置项为例，你可以直接在 modern.config.ts\n文件中使用该配置项，它会被自动传递给 Modern.js Builder。\n\nexport default defineConfig({\n  html: {\n    title: 'example',\n  },\n});\n\n\n关于构建配置的详细说明，请参考 「Modern.js Builder - Builder 配置」。\n\n\n构建能力#\n\nModern.js Builder 提供了丰富的构建能力，包括 JavaScript 编译、CSS 编译、静态资源处理、代码热更新、代码压缩、TS\n类型检查等几十种能力。\n\n我们推荐你阅读 「Modern.js Builder - 功能导航」 来了解 Modern.js Builder 提供的所有构建能力。","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/concept/builder.mdx","_relativePath":"zh/guides/concept/builder.mdx"},{"id":523,"title":"入口","routePath":"/guides/concept/entries","lang":"zh","toc":[{"text":"什么是入口（Entry）","id":"什么是入口（entry）","depth":2,"charIndex":45},{"text":"单入口与多入口","id":"单入口与多入口","depth":2,"charIndex":255},{"text":"入口类型","id":"入口类型","depth":2,"charIndex":1109},{"text":"框架模式入口","id":"框架模式入口","depth":3,"charIndex":1504},{"text":"约定式路由","id":"约定式路由","depth":4,"charIndex":1677},{"text":"自控式路由","id":"自控式路由","depth":4,"charIndex":1917},{"text":"自定义 Bootstrap","id":"自定义-bootstrap","depth":4,"charIndex":2107},{"text":"构建模式入口","id":"构建模式入口","depth":3,"charIndex":2875},{"text":"使用配置指定入口","id":"使用配置指定入口","depth":2,"charIndex":3256},{"text":"禁用默认入口扫描","id":"禁用默认入口扫描","depth":3,"charIndex":3607}],"domain":"","content":"#\n\n通过本章节，你可以了解到 Modern.js 中的入口约定，以及如何自定义入口。\n\n\n什么是入口（Entry）#\n\n入口指的是一个页面的起始模块。\n\n在 Modern.js 项目中，每一个入口对应一个独立的页面，也对应一条服务端路由。默认情况下，Modern.js\n会基于目录约定来自动确定页面的入口，同时也支持通过配置项来自定义入口。\n\nModern.js 提供的很多配置项都是以入口为维度进行划分的，比如页面标题、HTML 模板、页面 Meta 信息、是否开启 SSR/SSG、服务端路由规则等。\n\n\n单入口与多入口#\n\nModern.js 初始化的项目是单入口的（SPA），项目结构如下：\n\n.\n├── src\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n├── package.json\n├── modern.config.ts\n└── tsconfig.json\n\n\n在 Modern.js 项目中，你可以很方便的将单入口切换成多入口，直接在项目下执行 pnpm run new，根据提示创建入口即可：\n\n? 请选择你想要的操作 创建工程元素\n? 请选择创建元素类型 新建「应用入口」\n? 请填写入口名称 new-entry\n\n\n执行后，Modern.js 会自动生成一个新的入口目录，此时可以看到 src/ 目录变成如下结构：\n\n.\n├── myapp    # 原入口\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n└── new-entry # 新入口\n    └── routes\n        ├── index.css\n        ├── layout.tsx\n        └── page.tsx\n\n\n原本的入口代码被移动到了和 package.json 中 name 同名的目录下，并创建了 new-entry 入口目录。\n\n执行 pnpm run dev 后，可以看到新增了一条名为 /new-entry 的路由，并且被迁移的代码路由并未发生变化。\n\nTIP\n\nModern.js 会将与 package.json 文件中 name 字段同名的入口作为主入口，主入口的路由为 /，其他入口的路由为\n/{entryName}。\n\n比如，package.json 中的 name 为 myapp 时，src/myapp 会作为项目的主入口。\n\n\n入口类型#\n\n不同的入口类型具有不同的编译和运行时行为。\n\n默认情况下，Modern.js 启动项目前会对 src/ 下的文件进行扫描，识别入口，并生成对应的服务端路由。\n\nTIP\n\n可以通过 source.entriesDir 修改页面的入口识别目录。\n\n并非 src/ 下所有的一级目录都会成为项目入口, 入口所在目录必须满足以下四个条件之一：\n\n 1. 具有 routes/ 目录。\n 2. 具有 App.[jt]sx? 文件。\n 3. 具有 index.[jt]sx? 文件。\n 4. 具有 pages/ 目录（兼容 Modern.js 1.0）。\n\n当 src/ 目录满足入口特征时，Modern.js 会认为当前项目为单入口应用。\n\nTIP\n\n在单入口应用中，默认的入口名为 main。\n\n当项目不是单入口应用时，Modern.js 会进一步查看 src/ 下的一级目录。\n\n\n框架模式入口#\n\n框架模式指需要使用 Modern.js 框架能力，例如 Router、SSR、一体化调用等。这类入口约定下，开发者定义的入口并不是真正的 webpack\n编译入口。Modern.js 在启动时会生成一个封装过的入口，可以在 node_modules/.modern/{entryName}/index.js\n找到真正的入口。\n\n约定式路由#\n\n如果入口中存在 routes/ 目录，Modern.js 会在启动时扫描 routes/\n下的文件，基于文件约定，自动生成客户端路由（react-router）。例如：\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       └── page.tsx\n\n\n上述目录中，layout.tsx 中导出的组件会作为最外层的组件，page.tsx 中导出的组件会作为 / 路由的组件。\n\n详细内容可以参考路由。\n\n自控式路由#\n\n如果入口中存在 App.[jt]sx? 文件，开发者可以在这个文件中通过代码的方式，设置客户端路由，或者不设置客户端路由。\n\n\n\nexport default () => {\n  return (\n    \n      \n        index} />\n        about} />\n      \n    \n  );\n};\n\n\n详细内容可以参考路由。\n\n自定义 Bootstrap#\n\n如果入口中存在 index.[jt]sx 文件，并且当文件默认导出函数时，Modern.js 会将默认的 bootstrap\n函数作为入参传入，并用导出的函数替代默认的 bootstrap，这样开发者可以自定义将组件挂载到 DOM 节点上，或在挂载前添加自定义行为。例如：\n\nexport default (App: React.ComponentType, bootstrap: () => void) => {\n  // do something before bootstrap...\n  initSomething().then(() => {\n    bootstrap();\n  })\n};\n\n\n此时，Modern.js 生成的文件内容如下：\n\n\n\n\n\n\n\nconst IS_BROWSER = typeof window !== 'undefined' && window.name !== 'nodejs';\nconst MOUNT_ID = 'root';\n\nlet AppWrapper = null;\nlet root = null;\n\nfunction render() {\n  AppWrapper = createApp({\n    // runtime 的插件参数...\n  })(App);\n  if (IS_BROWSER) {\n    customBootstrap(AppWrapper, () => bootstrap(AppWrapper, MOUNT_ID, root, ReactDOM));\n  }\n  return AppWrapper;\n}\n\nAppWrapper = render();\n\nexport default AppWrapper;\n\n\n\n构建模式入口#\n\n构建模式是指不使用任何 Modern.js 运行时的能力，完全由开发者自己定义项目 webpack 的入口。\n\n如果入口中存在 index.[jt]sx ，并且没有默认导出函数时，这时候该文件就是真正的 webpack 入口文件。这里和 Create React App\n类似，需要自己将组件挂载到 DOM 节点、添加热更新代码等。例如:\n\n\n\n\n\nReactDOM.render(, document.getElementById('root'));\n\n\nModern.js 不推荐新项目使用这种方式，这种方式丧失了框架的一些能力，如 modern.config.js 文件中的 runtime\n配置将不会再生效。但是在项目从其他框架迁移到 Modern.js，例如 CRA，或是自己手动搭建的 webpack 时，这种方式会非常有用。\n\n\n使用配置指定入口#\n\n大部分存量项目并不是按照 Modern.js 的目录结构来搭建的。如果要改成 Modern.js 约定的目录结构，会存在一定的迁移成本。\n\n在这种情况下，除了使用文件约定生成入口外，你可以在 modern.config.[jt]s 中手动配置入口。\n\nexport default defineConfig({\n  source: {\n    entries: {\n      // 指定一个名称为 entry_customize 的新入口\n      entry_customize: './src/home/test/index.ts',\n    },\n    // 禁用默认入口扫描\n    disableDefaultEntries: true,\n  },\n});\n\n\n\n禁用默认入口扫描#\n\n当使用自定义入口时，项目的部分结构可能恰巧命中了 Modern.js 的目录约定，但实际上这部分目录并不是真实的入口。\n\nModern.js 提供了 disableDefaultEntries 配置，来禁用默认的入口扫描规则。当你需要自定义入口时，一般需要将\ndisableDefaultEntries 与 entries 结合使用。这样，一些存量项目可以在不修改目录结构的情况下，快速地进行迁移。\n\nexport default defineConfig({\n  source: {\n    disableDefaultEntries: true,\n  },\n});\n\n\nTIP\n\n详细用法请查看 source.entries 和 source.disableDefaultEntries。","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/concept/entries.mdx","_relativePath":"zh/guides/concept/entries.mdx"},{"id":524,"title":"名词解释","routePath":"/guides/get-started/glossary","lang":"zh","toc":[{"text":"BFF","id":"bff","depth":2,"charIndex":3},{"text":"Bundler","id":"bundler","depth":2,"charIndex":174},{"text":"Builder","id":"builder","depth":2,"charIndex":348},{"text":"CSR","id":"csr","depth":2,"charIndex":598},{"text":"Garfish","id":"garfish","depth":2,"charIndex":794},{"text":"Rspack","id":"rspack","depth":2,"charIndex":926},{"text":"SSR","id":"ssr","depth":2,"charIndex":1135},{"text":"SSG","id":"ssg","depth":2,"charIndex":1450},{"text":"SWC","id":"swc","depth":2,"charIndex":1746}],"domain":"","content":"#\n\n\nBFF#\n\nBFF 是 \"Backend For Frontend\"（前端的后端） 的缩写。它是一种架构模式，表示为前端应用程序创建一个专门的后台服务。\n\nBFF 服务作为前端应用程序和服务端 API 之间的中介，可以为前端提供定制的 API\n供其使用。这允许前端开发者对需要的数据和功能有更多的控制，而不必依赖后端服务提供相应的能力。\n\n\nBundler#\n\n指 webpack、Rspack 等模块打包工具。\n\n打包工具的主要目标是将 JavaScript、CSS 等文件打包在一起，打包后的文件可以在浏览器、Node.js 等环境中使用。当 Bundler 处理 Web\n应用时，它会构建一个依赖关系图，其中包含应用需要的各个模块，然后将所有模块打包成一个或多个 bundle。\n\n\nBuilder#\n\nBuilder 指的是构建引擎，它的目标是「复用构建工具的最佳实践」。\n\n因为 webpack 等打包工具是比较底层的，如果我们基于 webpack 来构建一个项目，需要充分理解 webpack\n的各个配置项和三方插件，并进行繁琐的配置组合和调试工作。\n\n而 Builder 比 Bundler 的封装程度更高，并默认集成代码转换、代码压缩等能力。通过接入 Builder，你可以快速获得构建 Web 应用的能力。\n\nModern.js Builder 内部的分层如下：\n\n\n\n\nCSR#\n\nCSR 是 \"Client-Side Rendering\"（客户端渲染）的缩写。它表示页面是在浏览器中通过 JavaScript\n渲染的，数据获取、模板和路由等逻辑都在浏览器端完成，而不是在服务器上。\n\n在 CSR 中，服务器会向浏览器端发送一个空的 HTML 外壳和一些 JavaScript 脚本，然后由浏览器端从服务器的 API\n中拉取数据，并将动态内容渲染到页面中。\n\n\nGarfish#\n\nGarfish 是一套微前端解决方案，主要用于解决 web 应用的跨团队协作、技术体系多样化等问题。\n\n它从架构层面出发，将多个独立交付的前端应用组成整体，这些前端应用能够独立开发、独立测试、独立部署，但是在用户视角仍然是内聚的单个产品。\n\n\nRspack#\n\nRspack 是一个基于 Rust 的高性能 Web 构建工具，具备与 webpack 生态系统的互操作性，可以被 webpack\n项目低成本集成，并提供更好的构建性能。\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。经过 benchmark\n验证，Rspack 可以带来 5 ～ 10 倍编译性能的提升。\n\n\nSSR#\n\nSSR 是 \"Server-Side Rendering\"（服务器端渲染）的缩写。它表示由服务器生成网页的 HTML，并将其发送给客户端，而不是只发送一个空的\nHTML 外壳，并依赖 JavaScript 来生成页面内容。\n\n在传统的客户端渲染中，服务器会向客户端发送一个空的 HTML 外壳和一些 JavaScript 脚本，然后从服务器的 API\n中获取数据，并用动态内容填充页面。这会导致页面的初始加载时间较慢，不利于用户体验和 SEO。\n\n使用 SSR 后，服务器会生成已经包含动态内容的 HTML，并将其发送给客户端。这使得首屏加载速度更快，并对 SEO\n更加友好，因为搜索引擎可以爬取到渲染后的页面。\n\n\nSSG#\n\nSSG 是 \"Static Site Generation\"（静态网站生成）的缩写。它表示网页被预先渲染成静态的\nHTML，然后直接提供给客户端，而不需要服务器实时生成 HTML。\n\n在传统的 SSR 中，每当用户请求一个页面时，服务器就会实时生成 HTML。有了 SSG，HTML 可以在构建过程中被提前生成，并被托管在 CDN\n或其他静态资源服务中。\n\n与传统的 SSR 相比，SSG 可以提供更快的加载速度以及更少的服务端开销，因为不需要维护一个服务器来实时生成 HTML。然而，SSG\n不适合需要动态内容的网站，因为 HTML 是在构建过程中生成的，不支持实时更新。\n\n\nSWC#\n\nSWC (Speedy Web Compiler) 是基于 Rust 语言编写的高性能 JavaScript 和 TypeScript 转译和压缩工具。在\nPolyfill 和语法降级方面可以和 Babel 提供一致的能力，并且性能比 Babel 高出一个数量级。\n\nModern.js Builder 提供了开箱即用的 SWC 插件，可以为你的 Web 应用提供语法降级、Polyfill 以及压缩，并且移植了一些额外常见的\nBabel 插件。","frontmatter":{"sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/get-started/glossary.mdx","_relativePath":"zh/guides/get-started/glossary.mdx"},{"id":525,"title":"介绍","routePath":"/guides/get-started/introduction","lang":"zh","toc":[{"text":"关于文档","id":"关于文档","depth":2,"charIndex":203},{"text":"Modern.js 框架","id":"modernjs-框架","depth":2,"charIndex":466},{"text":"下一步","id":"下一步","depth":2,"charIndex":1121}],"domain":"","content":"#\n\nModern.js 是字节跳动 Web 工程体系的开源版本，它提供多个解决方案，来帮助开发者解决不同研发场景下的问题。\n\n目前 Modern.js 包含三个解决方案，分别面向 Web 应用开发场景、npm 包开发场景和文档站开发场景：\n\n作为 Modern.js 工程体系的一部分，以上每个解决方案都可以被单独使用，并且各自部署了独立的文档站点。开发者可以按需选择其中的一个或多个解决方案来使用。\n\n\n关于文档#\n\n当前文档站对应的是 Modern.js 框架，适用于开发 Web 应用。\n\n * 如果你需要开发一个 npm 包，请移步至 Modern.js Module 文档。\n * 如果你需要开发一个文档站点，请移步至 Modern.js Doc 文档。\n * 如果你需要基于 Modern.js 的构建引擎来实现一个 Web 开发框架，请移步至 Modern.js Builder 文档。\n\nTIP\n\n由于 Modern.js 框架的使用最为广泛，在本文档站中，我们会省略「框架」，直接称其为 Modern.js。\n\n\nModern.js 框架#\n\nModern.js 框架是一个基于 React 的渐进式 Web 开发框架。在字节跳动内部，我们将 Modern.js 封装为上层框架，并支撑了数千个 Web\n应用的研发。\n\nModern.js 能为开发者提供极致的开发体验（Development Experience），让应用拥有更好的用户体验（User Experience）。\n\n在开发 React 应用过程中，开发者通常需要去为某些功能去设计实现方案，或是使用其他的库、框架来解决这些问题。Modern.js 支持 React\n应用所需要的所有配置和工具，并内置额外的功能和优化。开发者可以使用 React 构建应用的 UI，然后逐步采用 Modern.js\n的功能来解决常见的应用需求，如路由、数据获取、状态管理等。\n\n它主要包含以下特性：\n\n * 🚀 Rust 构建：提供双构建工具支持，轻松切换到 Rspack 构建工具，编译飞快。\n * 🪜 渐进式：使用最精简的模板创建项目，通过生成器逐步开启插件功能，定制解决方案。\n * 🏠 一体化：开发与生产环境 Web Server 唯一，CSR 和 SSR 同构开发，函数即接口的 API 服务调用。\n * 📦 开箱即用：默认 TS 支持，内置构建、ESLint、调试工具，全功能可测试。\n * 🌏 周边生态：自研状态管理、微前端、模块打包、Monorepo 方案等周边需求。\n * 🕸 多种路由模式：包含自控路由、基于文件约定的路由（嵌套路由）等。\n\n\n下一步#\n\n如果你希望了解如何使用 Modern.js 框架，可以尝试 创建第一个应用，或是阅读 快速上手。","frontmatter":{"title":"介绍","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/get-started/introduction.mdx","_relativePath":"zh/guides/get-started/introduction.mdx"},{"id":526,"title":"快速上手","routePath":"/guides/get-started/quick-start","lang":"zh","toc":[{"text":"环境准备","id":"环境准备","depth":2,"charIndex":3},{"text":"Node.js","id":"nodejs","depth":3,"charIndex":11},{"text":"pnpm","id":"pnpm","depth":3,"charIndex":563},{"text":"安装","id":"安装","depth":2,"charIndex":654},{"text":"初始化项目","id":"初始化项目","depth":2,"charIndex":846},{"text":"启动项目","id":"启动项目","depth":2,"charIndex":1504},{"text":"使用配置","id":"使用配置","depth":2,"charIndex":1774},{"text":"构建项目","id":"构建项目","depth":2,"charIndex":2088},{"text":"本地验证","id":"本地验证","depth":2,"charIndex":3167},{"text":"部署","id":"部署","depth":2,"charIndex":3440}],"domain":"","content":"#\n\n\n环境准备#\n\n\nNode.js#\n\n在开始使用前，你需要安装 Node.js，并保证 Node.js 版本不低于 14.17.6，我们推荐使用 Node.js 16 的 LTS 版本。\n\n你可以通过以下命令检查当前使用的 Node.js 版本：\n\nnode -v\n# v16.19.1\n\n\n如果你当前的环境中尚未安装 Node.js，或是安装的版本低于 14.17.6，可以通过 nvm 或 fnm 安装需要的版本。\n\n下面是通过 nvm 安装 Node.js 16 LTS 版本的例子：\n\n# 安装 Node.js 16 的长期支持版本\nnvm install 16 --lts\n\n# 将刚安装的 Node.js 16 设置为默认版本\nnvm alias default 16\n\n# 切换到刚安装的 Node.js 16\nnvm use 16\n\n\nnvm 和 fnm\n\nnvm 和 fnm 都是 Node.js 版本管理工具。相对来说，nvm 较为成熟和稳定，而 fnm 是使用 Rust 实现的，比 nvm 提供了更好的性能。\n\n此外，在安装 nvm 或 fnm 后，然后只要仓库根目录下有内容为 lts/gallium 的 .nvmrc 文件，进入这个仓库时就会自动安装或切换到正确的\nNode.js 版本。\n\n\npnpm#\n\n推荐使用 pnpm 来管理依赖：\n\nnpm install -g pnpm@7\n\n\nNOTE\n\nModern.js 同样支持使用 yarn、npm 进行依赖管理。\n\n\n安装#\n\nModern.js 提供了 @modern-js/create 工具来创建项目，不要全局安装，使用 npx 按需运行。\n\n可以在已有的空目录来创建项目：\n\nmkdir myapp && cd myapp\nnpx @modern-js/create@latest\n\n\n也可以直接用新目录创建项目：\n\nnpx @modern-js/create@latest myapp\n\n\n\n初始化项目#\n\n@modern-js/create 会提供一个可交互的问答界面，根据结果初始化项目，按照默认的选择进行初始化：\n\n? 请选择你想创建的工程类型 Web 应用\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n? 请选择构建工具 webpack\n\n\n在生成项目后，Modern.js 会自动安装依赖、创建 git 仓库。\n\n[INFO] 依赖自动安装成功\n[INFO] git 仓库初始化成功\n[INFO] 创建成功！\n可在新项目的目录下运行以下命令：\npnpm run dev          # 启动开发服务器\npnpm run build        # 构建生产环境产物\npnpm run serve        # 启动生产环境服务\npnpm run lint         # 运行 ESLint 并自动修复问题\npnpm run new          # 启用可选功能或创建项目要素\n\n\n现在，项目结构如下：\n\n.\n├── node_modules\n├── src\n│   ├── modern-app-env.d.ts\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n├── modern.config.ts\n├── package.json\n├── pnpm-lock.yaml\n├── README.md\n└── tsconfig.json\n\n\n\n启动项目#\n\n在项目中执行 pnpm run dev 即可启动项目：\n\n$ pnpm run dev\n\n> modern dev\n\ninfo    Starting dev server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n Client ✔ done in 76.10ms\n\n\n在浏览器中打开 http://localhost:8000/，可以看到页面内容。\n\n\n使用配置#\n\n通过 @modern-js/create 创建的 Modern.js 项目中，会默认生成 modern.config.ts 文件。\n\n可以通过该配置文件修改配置，覆盖 Modern.js 的默认行为。例如添加如下配置，开启 SSR：\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n  server: {\n    ssr: true,\n  },\n  plugins: [appTools()],\n});\n\n\n重新执行 pnpm run dev，在浏览器 Network 菜单中，可以发现项目已经在服务端完成了页面渲染。\n\n\n构建项目#\n\n在项目中执行 pnpm run build 即可构建项目生产环境产物：\n\n$ pnpm run build\n\n> modern build\n\ninfo    Create a production build...\n\ninfo    File sizes after production build:\n\n  File                                      Size         Gzipped\n  dist/static/js/lib-corejs.ffeb7fb8.js     214.96 kB    67.23 kB\n  dist/static/js/lib-react.09721b5c.js      152.61 kB    49.02 kB\n  dist/static/js/218.102e2f39.js            85.45 kB     28.5 kB\n  dist/static/js/lib-babel.a7bba875.js      11.93 kB     3.95 kB\n  dist/html/main/index.html                 5.84 kB      2.57 kB\n  dist/static/js/main.3568a38e.js           3.57 kB      1.44 kB\n  dist/static/css/async/304.c3c481a5.css    2.62 kB      874 B\n  dist/asset-manifest.json                  1.48 kB      349 B\n  dist/static/js/async/304.c45706bc.js      1.4 kB       575 B\n  dist/static/js/async/509.fcb06e14.js      283 B        230 B\n\n Client ✔ done in 3.57s\n\n\n构建产物默认生成到 dist/，目录结构如下：\n\ndist\n├── html\n│   └── main\n├── modern.config.json\n├── route.json\n├── routes-manifest.json\n└── static\n    ├── css\n    └── js\n\n\n> 如果你需要自定义构建产物的目录，请参考 构建产物目录。\n\n\n本地验证#\n\n在项目中执行 pnpm run serve 即可在本地验证构建产物是否正常运行：\n\n$ pnpm run serve\n\n> modern serve\n\nStarting the modern server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n\n在浏览器中打开 http://localhost:8000/，内容应该和 pnpm run dev 时一致。\n\n\n部署#\n\n本地验证完成后，可以将 dist/ 下的产物整理成服务器需要的结构，进行部署。","frontmatter":{"title":"快速上手","sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/get-started/quick-start.mdx","_relativePath":"zh/guides/get-started/quick-start.mdx"},{"id":527,"title":"升级","routePath":"/guides/get-started/upgrade","lang":"zh","toc":[{"text":"通过命令行升级","id":"通过命令行升级","depth":2,"charIndex":3},{"text":"指定版本升级","id":"指定版本升级","depth":2,"charIndex":247},{"text":"锁定子依赖","id":"锁定子依赖","depth":2,"charIndex":380},{"text":"pnpm","id":"pnpm","depth":3,"charIndex":440},{"text":"Yarn","id":"yarn","depth":3,"charIndex":592},{"text":"Npm","id":"npm","depth":3,"charIndex":724}],"domain":"","content":"#\n\n\n通过命令行升级#\n\nModern.js 提供了 upgrade 命令支持项目升级到最新的 Modern.js 版本。\n\n在项目中执行 pnpm run upgrade：\n\n$ pnpm run upgrade\n\n> modern upgrade\n\n[INFO] [项目类型]: Web 应用\n[INFO] [Modern.js 最新版本]: 2.0.0\n[INFO] 已更新 Modern.js 依赖至最新版本!\n\n\n可以看到项目 package.json 中的依赖已经更改到最新。\n\n\n指定版本升级#\n\nModern.js 所有的官方包目前都使用统一版本号进行发布。\n\n根据官网 Release Note，开发者也可以手动将项目升级到想要的版本。\n\nTIP\n\n当升级时，需要对 Modern.js 官方提供的所有包做统一升级，而不是升级单个依赖。\n\n\n锁定子依赖#\n\n当项目某个子依赖出现问题，而 Modern.js 无法立即更新时，可以使用包管理器锁定子依赖版本。\n\n\npnpm#\n\n对于使用 pnpm 的项目，请在项目根目录的 package.json 中添加以下配置，然后重新执行 pnpm install：\n\n{\n  \"pnpm\": {\n    \"overrides\": {\n      \"package-name\": \"^1.0.0\"\n    }\n  }\n}\n\n\n\nYarn#\n\n对于使用 Yarn 的项目，请在项目根目录的 package.json 中添加以下配置，然后重新执行 yarn install：\n\n{\n  \"resolutions\": {\n    \"package-name\": \"^1.0.0\"\n  }\n}\n\n\n\nNpm#\n\n对于使用 Npm 的项目，请在项目根目录的 package.json 中添加以下配置，然后重新执行 npm install：\n\n{\n  \"overrides\": {\n    \"package-name\": \"^1.0.0\"\n  }\n}\n\n\nINFO\n\n对于 Monorepo 仓库，只能在项目根目录的 package.json 中锁定依赖版本，并且会影响 Monorepo 中的所有 package。","frontmatter":{"title":"升级","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/get-started/upgrade.mdx","_relativePath":"zh/guides/get-started/upgrade.mdx"},{"id":528,"title":"添加 Changesets","routePath":"/guides/topic-detail/changesets/add","lang":"zh","toc":[{"text":"信息","id":"信息","depth":2,"charIndex":47},{"text":"步骤","id":"步骤","depth":2,"charIndex":153},{"text":"模块工程方案","id":"模块工程方案","depth":3,"charIndex":214},{"text":"在根目录执行 change 命令","id":"在根目录执行-change-命令","depth":4,"charIndex":223},{"text":"选择本次变更需要升级的版本号类型","id":"选择本次变更需要升级的版本号类型","depth":4,"charIndex":260},{"text":"填入 changelog 信息，并点击两次回车：","id":"填入-changelog-信息，并点击两次回车：","depth":4,"charIndex":281},{"text":"Monorepo 工程方案","id":"monorepo-工程方案","depth":3,"charIndex":464},{"text":"在根目录执行 change 命令","id":"在根目录执行-change-命令-1","depth":4,"charIndex":536},{"text":"选择本次需要升级的包列表","id":"选择本次需要升级的包列表","depth":4,"charIndex":573},{"text":"分别选择不同版本类型对应的包","id":"分别选择不同版本类型对应的包","depth":4,"charIndex":745},{"text":"填入 changelog 信息","id":"填入-changelog-信息","depth":4,"charIndex":827},{"text":"参数","id":"参数","depth":2,"charIndex":1015},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":1209}],"domain":"","content":"#\n\n当我们开发完成时，需要添加一个 changeset 声明当前变更，用于后续版本发布。\n\n\n信息#\n\n一个 changeset 包含的内容包括：\n\n * 本次变更涉及哪些包的变更。\n\n * 本次变更需要升级的版本号类型，类型符合 semver 规范。\n\n * 本次变更的 changelog 信息。\n\n\n步骤#\n\nINFO\n\n以下示例命令都以 pnpm 作为包管理工具进行，如果需要使用其他包管理工具，请按需求进行替换。\n\n\n模块工程方案#\n\n在根目录执行 change 命令#\n\npnpm run change\n\n\n选择本次变更需要升级的版本号类型#\n\n\n\n填入 changelog 信息，并点击两次回车：#\n\n\n\n执行完成后，将在项目的 .changeset 目录创建对应的 changeset 文件，文件内容如下：\n\n---\n'module-changeset': patch\n---\n\nfeat: test module solution changeset\n\n\n该文件中包含了 changeset 的所有信息。\n\n\nMonorepo 工程方案#\n\n我们假设 monorepo 中存在三个模块包，分别为 module-1，module-2，module-3。\n\n在根目录执行 change 命令#\n\npnpm run change\n\n\n选择本次需要升级的包列表#\n\nChangesets 会根据当前代码变更(git diff Head...baseBranch)，将 Monorepo 中的 package\n分为两类，changed packages 和 unchanged packages，方便用户进行选择。\n\n使用空格键选择对应的包或者分类即可，选择完成后点击回车：\n\n\n\n分别选择不同版本类型对应的包#\n\nchangeset 会询问 major 和 minor 类型，如果存在包未选择这两种类型，将会默认使用 patch 类型。\n\n\n\n填入 changelog 信息#\n\n\n\n执行完成后，将在项目的 .changeset 目录创建对应的 changeset 文件，文件内容如下：\n\n---\n'module-2': minor\n'module-3': patch\n---\n\nfeat: test-changeset\n\n\n该文件中包含了 changeset 的所有信息，不同的包也会根据选择的版本类型进行标记。\n\n\n参数#\n\nchange 命令支持以下参数：\n\n * --empty： 添加一个空的 changeset。\n\npnpm run change --empty\n\n\n执行完成后，将在项目的 .changeset 目录创建空的 changeset 文件，文件内容如下：\n\n---\n---\n\n\n * --open： 使用该参数时，在填写 changelog 步骤会打开系统默认编辑器进行填写。\n\n\n注意事项#\n\n * 不是所有的变更都需要 changeset\n\n如果当前变更是修改仓库的一些基础设施，比如 CI、测试等，就不需要添加 changeset 或者可以添加一个空的 changeset。\n\n * 一个 pull reuqest 可以提交多个 changeset\n\n当一个 pull request 存在多个功能开发或者问题修复时，可以多次执行 pnpm run change 添加多个 changeset\n文件，每个文件选择对应功能的包和添加变更信息即可。\n\n * 创建 changeset 时，需要选择该功能相关的所有包\n\n在 Monorepo 中创建 changeset 时，需要选中和该功能相关的所有变更包，避免出现发版时部分包未发布的情况。","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/changesets/add.mdx","_relativePath":"zh/guides/topic-detail/changesets/add.mdx"},{"id":529,"title":"自定义 changelog 生成","routePath":"/guides/topic-detail/changesets/changelog","lang":"zh","toc":[{"text":"自定义 changelog 内容","id":"自定义-changelog-内容","depth":2,"charIndex":109},{"text":"getReleaseLine","id":"getreleaseline","depth":3,"charIndex":281},{"text":"Params","id":"params","depth":4,"charIndex":298},{"text":"返回值","id":"返回值","depth":4,"charIndex":689},{"text":"默认实现","id":"默认实现","depth":4,"charIndex":710},{"text":"getDependencyReleaseLine","id":"getdependencyreleaseline","depth":3,"charIndex":1192},{"text":"Params","id":"params-1","depth":4,"charIndex":1219},{"text":"返回值","id":"返回值-1","depth":4,"charIndex":1670},{"text":"默认实现","id":"默认实现-1","depth":4,"charIndex":1691},{"text":"配置","id":"配置","depth":2,"charIndex":2531},{"text":"配置相对路径","id":"配置相对路径","depth":3,"charIndex":2757},{"text":"使用模块工程方案","id":"使用模块工程方案","depth":3,"charIndex":3159},{"text":"使用 npx @modern-js/create@latest 创建模块工程方案","id":"使用-npx-@modern-js/create@latest-创建模块工程方案","depth":4,"charIndex":3209},{"text":"实现自定义内容","id":"实现自定义内容","depth":4,"charIndex":3332},{"text":"将模块发布到 NPM","id":"将模块发布到-npm","depth":4,"charIndex":3439},{"text":"在目标仓库根目录安装对应模块，例如 custom-changelog","id":"在目标仓库根目录安装对应模块，例如-custom-changelog","depth":4,"charIndex":3452},{"text":"配置 changeset 的 changelog 配置为包名称","id":"配置-changeset-的-changelog-配置为包名称","depth":4,"charIndex":3489},{"text":"使用 Monorepo 工程方案","id":"使用-monorepo-工程方案","depth":3,"charIndex":3572},{"text":"执行 pnpm run new 创建模块子项目","id":"执行-pnpm-run-new-创建模块子项目","depth":4,"charIndex":3632},{"text":"实现自定义内容","id":"实现自定义内容-1","depth":4,"charIndex":3753},{"text":"在 Monorepo 根目录添加子项目模块依赖，例如 custom-changelog","id":"在-monorepo-根目录添加子项目模块依赖，例如-custom-changelog","depth":4,"charIndex":3860},{"text":"配置 changeset 的 changelog 配置为包名称","id":"配置-changeset-的-changelog-配置为包名称-1","depth":4,"charIndex":3987}],"domain":"","content":"#\n\nChangesets 默认会使用 @changesets/cli/changelog 生成 Changelog 信息，如果默认的 changelog\n信息不能满足需求，可以自定义 changelog 的生成。\n\n\n自定义 changelog 内容#\n\nchangelog 信息主要包含以下两种信息：\n\n * changeset 中写入的 changelog 信息。\n\n * 本次版本升级关联包的版本变更信息。\n\n自定义逻辑主要实现两个函数，getReleaseLine 和 getDependencyReleaseLine，分别用来定义上述这两种信息。\n\n\ngetReleaseLine#\n\nParams#\n\n * changeset\n\nexport type VersionType = 'major' | 'minor' | 'patch' | 'none';\n\nexport type Release = { name: string; type: VersionType };\n\nexport type Changeset = {\n  id: string; // changeset 的文件名称\n  commit?: string; // changeset 提交时的 commit id 信息\n  summary: string; // changeset 内容信息\n  releases: Array; // 当前计算出的 changeset 升级包名称及类型信息\n};\n\n\n * type\n\n当前包对应的升级版本类型，类型为上述 VersionType。\n\n返回值#\n\nchangelog 内容。\n\n默认实现#\n\n@changesets/cli/changelog 默认处理逻辑为将 summary 信息按照换行符 \\n 分割，第一样前面增加 -\n作为列表开头，其他内容作为第一行内容的补充整理在列表下方。\n\nasync function getReleaseLine(changeset, type) {\n  const [firstLine, ...futureLines] = changeset.summary\n    .split('\\n')\n    .map(l => l.trimRight());\n\n  let returnVal = `- ${\n    changeset.commit ? `${changeset.commit}: ` : ''\n  }${firstLine}`;\n\n  if (futureLines.length > 0) {\n    returnVal += `\\n${futureLines.map(l => `  ${l}`).join('\\n')}`;\n  }\n\n  return returnVal;\n}\n\n\n\ngetDependencyReleaseLine#\n\nParams#\n\n * changesets\n\n当前关联的所有 changeset 信息，类型为 getReleaseLine changeset 类型数组。\n\n * dependenciesUpdated\n\ntype ModCompWithPackage = {\n  name: string; // 依赖模块名称\n  type: VersionType; // 依赖模块的升级类型\n  oldVersion: string; // 依赖模块当前版本号\n  newVersion: string; // 依赖模块新版本号\n  changesets: string[]; // 关联的 changeset id 列表\n  packageJson: PackageJSON; // 依赖模块完整的 package.json 内容\n  dir: string; // 依赖模块的路径(绝对路径)\n};\n\ntype DependenciesUpdated = ModCompWithPackage[];\n\n\n返回值#\n\nchangelog 内容。\n\n默认实现#\n\n@changesets/cli/changelog 默认会使用 changesets 信息展示对应的 Updated dependencies + commit\nid，以列表形式展示。然后根据 dependenciesUpdated 信息展示对应的依赖包包名和新版本号，作为列表的子列表项。\n\nasync function getDependencyReleaseLine(changesets, dependenciesUpdated) {\n  console.log('getDependencyReleaseLine', changesets, dependenciesUpdated);\n  if (dependenciesUpdated.length === 0) return '';\n\n  const changesetLinks = changesets.map(\n    changeset =>\n      `- Updated dependencies${\n        changeset.commit ? ` [${changeset.commit}]` : ''\n      }`,\n  );\n\n  const updatedDepenenciesList = dependenciesUpdated.map(\n    dependency => `  - ${dependency.name}@${dependency.newVersion}`,\n  );\n\n  return [...changesetLinks, ...updatedDepenenciesList].join('\\n');\n}\n\n\n展示效果为：\n\n- Updated dependencies [f0438ab]\n- Updated dependencies [f0438ab]\n  - module-3@2.0.0\n  - module-1@0.2.0\n\n\n\n配置#\n\nChangesets 配置文件中 changelog 字段用于标记 changelog 信息的获取途径。\n\n该配置可以为字符串，直接声明获取 changelog 信息模块的模块名称或者路径。\n\n该配置还支持配置数组，数组中第一个元素为获取 changelog 信息模块的模块名称或者路径，第二个元素为传入对应函数的参数值，会作为\ngetReleaseLine 和 getDependencyReleaseLine 函数的第三个参数传入。\n\n\n配置相对路径#\n\nchangelog 配置如果为相对路径为 .changesets 目录下的相对路径。\n\n例如创建 .changeset/my-changelog-config.js 文件，定义如下内容：\n\nasync function getReleaseLine(changeset, type) {}\n\nasync function getDependencyReleaseLine(changesets, dependenciesUpdated) {}\n\nmodule.exports = {\n  getReleaseLine,\n  getDependencyReleaseLine,\n};\n\n\nchanglog 配置为 ./my-changelog-config.js 即可:\n\n{\n  \"changelog\": \"./my-changelog-config.js\",\n   ...\n}\n\n\n\n使用模块工程方案#\n\n自定义 changelog 还可以使用模块工程方案进行管理，提供通用方案。\n\n使用 npx @modern-js/create@latest 创建模块工程方案#\n\n? 请选择你想创建的工程类型：Npm 模块\n? 请填写项目名称：custom-changelog\n? 请选择开发语言：TS\n? 请选择包管理工具：pnpm\n\n\n实现自定义内容#\n\nexport async function getReleaseLine() {}\n\nexport async function getDependencyReleaseLine() {}\n\n\n将模块发布到 NPM#\n\n在目标仓库根目录安装对应模块，例如 custom-changelog#\n\n配置 changeset 的 changelog 配置为包名称#\n\n{\n  \"changelog\": \"custom-changelog\",\n   ...\n}\n\n\n\n使用 Monorepo 工程方案#\n\n如果你当前仓库为 Monorepo 工程方案，可以直接使用模块子项目进行管理。\n\n执行 pnpm run new 创建模块子项目#\n\n? 请选择你想创建的工程类型：Npm 模块\n? 请填写子项目名称：custom-changelog\n? 请填写子项目目录名称：custom-changelog\n? 请选择开发语言：TS\n\n\n实现自定义内容#\n\nexport async function getReleaseLine() {}\n\nexport async function getDependencyReleaseLine() {}\n\n\n在 Monorepo 根目录添加子项目模块依赖，例如 custom-changelog#\n\n{\n  \"devDependencies\": {\n    \"custom-changelog\": \"workspace: *\",\n    ...\n  }\n}\n\n\n配置 changeset 的 changelog 配置为包名称#\n\n{\n  \"changelog\": \"custom-changelog\",\n   ...\n}\n\n\n该模块发布到 NPM 后，依然可以和模块类型一样供其他仓库使用。","frontmatter":{"sidebar_position":6},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/changesets/changelog.mdx","_relativePath":"zh/guides/topic-detail/changesets/changelog.mdx"},{"id":530,"title":"自定义提交 commit 信息","routePath":"/guides/topic-detail/changesets/commit","lang":"zh","toc":[{"text":"自定义 commit 信息内容","id":"自定义-commit-信息内容","depth":2,"charIndex":160},{"text":"getAddMessage","id":"getaddmessage","depth":3,"charIndex":324},{"text":"Params","id":"params","depth":4,"charIndex":340},{"text":"返回值","id":"返回值","depth":4,"charIndex":581},{"text":"默认实现","id":"默认实现","depth":4,"charIndex":601},{"text":"getVersionMessage","id":"getversionmessage","depth":3,"charIndex":1095},{"text":"Params","id":"params-1","depth":4,"charIndex":1115},{"text":"返回值","id":"返回值-1","depth":4,"charIndex":1969},{"text":"默认实现","id":"默认实现-1","depth":4,"charIndex":1989},{"text":"配置","id":"配置","depth":2,"charIndex":2737},{"text":"配置相对路径","id":"配置相对路径","depth":3,"charIndex":3050},{"text":"使用模块工程方案","id":"使用模块工程方案","depth":3,"charIndex":3414},{"text":"使用 npx @modern-js/create@latest 创建模块工程方案","id":"使用-npx-@modern-js/create@latest-创建模块工程方案","depth":4,"charIndex":3461},{"text":"实现自定义内容","id":"实现自定义内容","depth":4,"charIndex":3581},{"text":"将模块发布到 NPM","id":"将模块发布到-npm","depth":4,"charIndex":3680},{"text":"在目标仓库根目录安装对应模块，例如 custom-commit","id":"在目标仓库根目录安装对应模块，例如-custom-commit","depth":4,"charIndex":3693},{"text":"配置 changeset 的 commit 配置为包名称","id":"配置-changeset-的-commit-配置为包名称","depth":4,"charIndex":3727},{"text":"使用 Monorepo 工程方案","id":"使用-monorepo-工程方案","depth":3,"charIndex":3801},{"text":"执行 pnpm run new 创建模块子项目","id":"执行-pnpm-run-new-创建模块子项目","depth":4,"charIndex":3861},{"text":"实现自定义内容","id":"实现自定义内容-1","depth":4,"charIndex":3976},{"text":"在 Monorepo 根目录添加子项目模块依赖，例如 custom-commit","id":"在-monorepo-根目录添加子项目模块依赖，例如-custom-commit","depth":4,"charIndex":4075},{"text":"配置 changeset 的 commit 配置为包名称","id":"配置-changeset-的-commit-配置为包名称-1","depth":4,"charIndex":4196}],"domain":"","content":"#\n\nChangesets 支持配置 commit 为 true 时，在执行 change 和 bump 命令时自动提交当前变更。\n\n默认的 commit 信息由 @changesets/cli/commit 提供，默认信息格式为：\n\n\n\n当默认的 commit 信息不能满足需求时，支持自定义 commit 信息。\n\n\n自定义 commit 信息内容#\n\ncommit 信息分为两种：\n\n * 执行 change 命令时自动生成的 commit 信息。\n * 执行 bump 命令时自动生成的 commit 信息。\n\n自定义逻辑主要实现两个函数，getAddMessage 和 getVersionMessage，分别用来定义上述这两种信息。\n\n\ngetAddMessage#\n\nParams#\n\n * changeset\n\n当前创建的 chagneset 信息\n\ntype Release = {\n  name: string;\n  type: VersionType;\n};\n\ntype Changeset = {\n  summary: string;\n  releases: Array;\n};\n\n\n * options\n\n配置 commit 时的配置信息。\n\n> commit 配置为数组时，第二个参数支持传入默认的配置信息，会对应的使用该参数传递。\n\n返回值#\n\ncommit 信息内容。\n\n默认实现#\n\n@changesets/cli/commit 默认处理逻辑为以 docs(changeset): 开头，commit 信息为 changeset 的\nsummary，并根据传入的 skipCI 参数配置添加 [skip ci] 信息。\n\ntype SkipCI = boolean | 'add' | 'version';\n\nconst getAddMessage = async (\n  changeset: Changeset,\n  options: { skipCI?: SkipCI } | null,\n) => {\n  const skipCI = options?.skipCI === 'add' || options?.skipCI === true;\n  return outdent`docs(changeset): ${changeset.summary}${\n    skipCI ? `\\n\\n[skip ci]\\n` : ''\n  }`;\n};\n\n\n> outdent 目的是删除模板字符串开头的空格内容，使 commit 信息更符合规范。\n\n\ngetVersionMessage#\n\nParams#\n\n * releasePlan\n\ntype VersionType = 'major' | 'minor' | 'patch' | 'none';\n\ntype Release = {\n  name: string;\n  type: VersionType;\n};\n\ntype Changeset = {\n  id: string;\n  summary: string;\n  releases: Array;\n};\n\ntype ComprehensiveRelease = {\n  name: string;\n  type: VersionType;\n  oldVersion: string;\n  newVersion: string;\n  changesets: string[];\n};\n\ntype PreState = {\n  mode: 'pre' | 'exit'; // pre 模式当前状态\n  tag: string; // pre 的类型\n  initialVersions: {\n    [pkgName: string]: string; // 版本升级前包名及版本号信息，Map 格式\n  };\n  changesets: string[]; // 本次升级的 changeset id 列表\n};\n\ntype ReleasePlan = {\n  changesets: Changeset[]; // 本次升级的 changeset 列表\n  releases: ComprehensiveRelease[]; // 当前升级的包信息，包含包名称、当前版本、升级后版本、升级类型等\n  preState: PreState | undefined; // 当前如果为 pre 发布，提供相关状态信息\n};\n\n\n * options\n\n配置 commit 时的其他参数。\n\n> commit 配置为数组时，第二个参数支持传入默认的配置信息，会对应的使用该参数传递。\n\n返回值#\n\ncommit 信息内容。\n\n默认实现#\n\n@changesets/cli/commit 默认处理逻辑为：先展示当前需要 release 的包数量，再展示 release 包的名称及新版本号，并根据传入的\nskipCI 参数配置添加 [skip ci] 信息。\n\nconst getVersionMessage = async (\n  releasePlan: ReleasePlan,\n  options: { skipCI?: SkipCI } | null,\n) => {\n  const skipCI = options?.skipCI === 'version' || options?.skipCI === true;\n  const publishableReleases = releasePlan.releases.filter(\n    release => release.type !== 'none',\n  );\n  const numPackagesReleased = publishableReleases.length;\n\n  const releasesLines = publishableReleases\n    .map(release => `  ${release.name}@${release.newVersion}`)\n    .join('\\n');\n\n  return outdent`\n    RELEASING: Releasing ${numPackagesReleased} package(s)\n\n    Releases:\n    ${releasesLines}\n    ${skipCI ? `\\n[skip ci]\\n` : ''}\n`;\n};\n\n\n\n配置#\n\nChangesets 配置文件中 commit 字段，该字段用于标记是否需要在 change 和 bump 命令是提交 commit 信息及 commit\n信息的获取途径。\n\n该配置可以为 boolean，为 true 时使用默认 @changesets/cli/commit 格式化 commit 信息。\n\n该配置可以为字符串，直接声明获取 commit 信息模块的模块名称或者路径。\n\n该配置还支持配置数组，数组中第一个元素为获取 commit 信息模块的模块名称或者路径，第二个元素为传入对应函数的参数值，会作为 getAddMessage 和\ngetVersionMessage 函数的第二个参数传入。\n\n\n配置相对路径#\n\ncommit 配置如果为相对路径为 .changesets 目录下的相对路径。\n\n例如创建 .changeset/my-commit-config.js 文件，定义如下内容：\n\nasync function getAddMessage(changeset, options) {}\n\nasync function getVersionMessage(releasePlan, options) {}\n\nmodule.exports = {\n  getAddMessage,\n  getVersionMessage,\n};\n\n\ncommit 配置为 ./my-commit-config.js 即可:\n\n{\n  \"changelog\": \"./my-commit-config.js\",\n   ...\n}\n\n\n\n使用模块工程方案#\n\n自定义 commit 还可以使用模块工程方案进行管理，提供通用方案。\n\n使用 npx @modern-js/create@latest 创建模块工程方案#\n\n? 请选择你想创建的工程类型：Npm 模块\n? 请填写项目名称：custom-commit\n? 请选择开发语言：TS\n? 请选择包管理工具：pnpm\n\n\n实现自定义内容#\n\nexport async function getAddMessage() {}\n\nexport async function getVersionMessage() {}\n\n\n将模块发布到 NPM#\n\n在目标仓库根目录安装对应模块，例如 custom-commit#\n\n配置 changeset 的 commit 配置为包名称#\n\n{\n  \"commit\": \"custom-commit\",\n   ...\n}\n\n\n\n使用 Monorepo 工程方案#\n\n如果你当前仓库为 Monorepo 工程方案，可以直接使用模块子项目进行管理。\n\n执行 pnpm run new 创建模块子项目#\n\n? 请选择你想创建的工程类型：Npm 模块\n? 请填写子项目名称：custom-commit\n? 请填写子项目目录名称：custom-commit\n? 请选择开发语言：TS\n\n\n实现自定义内容#\n\nexport async function getAddMessage() {}\n\nexport async function getVersionMessage() {}\n\n\n在 Monorepo 根目录添加子项目模块依赖，例如 custom-commit#\n\n{\n  \"devDependencies\": {\n    \"custom-commit\": \"workspace: *\",\n    ...\n  }\n}\n\n\n配置 changeset 的 commit 配置为包名称#\n\n{\n  \"commit\": \"custom-commit\",\n   ...\n}\n\n\n该模块发布到 NPM 后，依然可以和模块类型一样供其他仓库使用。","frontmatter":{"sidebar_position":7},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/changesets/commit.mdx","_relativePath":"zh/guides/topic-detail/changesets/commit.mdx"},{"id":531,"title":"Changesets 配置文件","routePath":"/guides/topic-detail/changesets/config","lang":"zh","toc":[{"text":"配置介绍","id":"配置介绍","depth":2,"charIndex":105},{"text":"commit","id":"commit","depth":3,"charIndex":113},{"text":"access","id":"access","depth":3,"charIndex":268},{"text":"baseBranch","id":"basebranch","depth":3,"charIndex":598},{"text":"ignore","id":"ignore","depth":3,"charIndex":664},{"text":"fixed","id":"fixed","depth":3,"charIndex":755},{"text":"linked","id":"linked","depth":3,"charIndex":879},{"text":"updateInternalDependencies","id":"updateinternaldependencies","depth":3,"charIndex":1025},{"text":"changelog","id":"changelog","depth":3,"charIndex":1482},{"text":"___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH","id":"___experimentalunsafeoptions_will_change_in_patch","depth":3,"charIndex":1818},{"text":"onlyUpdatePeerDependentsWhenOutOfRange","id":"onlyupdatepeerdependentswhenoutofrange","depth":4,"charIndex":1880},{"text":"updateInternalDependents","id":"updateinternaldependents","depth":4,"charIndex":2079},{"text":"useCalculatedVersionForSnapshots","id":"usecalculatedversionforsnapshots","depth":4,"charIndex":2237}],"domain":"","content":"#\n\n我们前面了解到，初始化 Modern.js 仓库时，会默认初始化 changesets 的配置文件，即 .changeset/config.json\n文件，下面我们将详细了解一下该文件中支持哪些配置。\n\n\n配置介绍#\n\n\ncommit#\n\n类型： boolean\n\n默认值： false\n\n当配置该字段为 true 时，在执行 change 和 bump 命令时，将自动执行提交代码操作。\n\n默认的 commit 信息格式如下：\n\n\n\n该 commit 信息支持自定义，我们将在自定义提交 commit 信息章节进行详细介绍。\n\n\naccess#\n\n类型：restricted | public\n\n默认值：restricted\n\n用于配置当前包的发布形式，如果配置为 restricted，将作为私有包发布，如果为 public，则发布公共范围包。\n\n对于仓库中存在部分包需要配置 access，可以在 package.json 中配置 publishConfig，例如：\n\n{\n  \"publishConfig\": {\n    \"registry\": \"https://registry.npmjs.org/\",\n    \"access\": \"public\"\n  }\n}\n\n\n对于不需要发布的包，可以在 package.json 中设置 private 为 true，阻止其进行发布。\n\n\nbaseBranch#\n\n类型： string\n\n默认值： main\n\n仓库主分支。该配置用于计算当前分支的变更包并进行分类。\n\n\nignore#\n\n类型：string[]\n\n默认值：[]\n\n用于声明执行 bump 命令时忽略的包，和 bump 命令的 --ignore 参数用法一致，注意两者不能同时使用。\n\n\nfixed#\n\n类型： string[][]\n\n默认值：[]\n\n用于 monorepo 中对包进行分组，相同分组中的包版本号将进行绑定，每次执行 bump 命令时，同一分组中的包只要有一个升级版本号，其他会一起升级。\n支持使用正则匹配包名称。\n\n\nlinked#\n\n类型： string[][]\n\n默认值：[]\n\n和 fixed 类似，也是对 monorepo 中对包进行分组，但是每次执行 bump 命令时，只有和 changeset\n声明的变更相关的包才会升级版本号，同一分组的变更包的版本号将保持一致。 支持使用正则匹配包名称。\n\n\nupdateInternalDependencies#\n\n类型：patch | minor\n\n默认值：patch\n\n用于声明更新内部依赖的版本号规则。\n\n当执行 bump 命令升级版本号时，默认会自动更新仓库中使用该包的依赖声明。配置该字段为 minor 后，如果升级版本号为 patch\n类型，将不会自动更新引用依赖声明。\n\n例如：\n\npkg-a @ version 1.0.0\npkg-b @ version 1.0.0\n  depends on pkg-a at range `^1.0.0\n\n\n默认情况下，升级 pkg-a 至 1.0.1 时，会更新 pkg-b 中的 pkg-a 的依赖版本为 ^1.0.1。\n\n当配置 updateInternalDependencies 为 minor 时，升级 pkg-a 至 1.0.1 时，pkg-b 中的 pkg-a\n的依赖版本将不会更新，只有 pkg-a 升级版本号为 1.1.0 或者 2.0.0 时，才会更新 pkg-b 中的 pkg-a 的依赖。\n\n\nchangelog#\n\n类型：boolean | string | [string, unknow]\n\n默认值：@changesets/cli/changelog\n\n生成 changelog 规则。\n\n配置为 false 时，执行 bump 命令时，在 CHANGELOG.md 文件中只声明版本号，不声明其他 changelog 信息。\n\n\n\n配置为 @changesets/cli/changelog 将使用官方提供的 changlog 生成规则，将 changeset 信息转换为 changlog\n内容。\n\n配置为数组时，第一个参数为自定义 NPM 包或者路径，第二个参数为需要传入的默认参数配置，自定义格式我们将在后续自定义 changelog 章节讲解。\n\n\n___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH#\n\n一些实验性配置。\n\nonlyUpdatePeerDependentsWhenOutOfRange#\n\n类型：boolean\n\n默认值：false\n\n针对于 peerDependence 依赖的升级策略配置，默认针对 peerDependence 在 minor 和 major\n版本升级时，当前包会升级大版本。\n\n该配置设置为 true 时，仅当 peerDependence 声明包依赖超出声明范围时才更新版本。\n\nupdateInternalDependents#\n\n类型： always | out-of-range\n\n默认值：always\n\n当执行 bump 命令升级版本号时，默认会自动更新仓库中使用该包的依赖声明。当设置该参数为 out-of-range\n时，只有当依赖声明超出范围时才会更新仓库中使用该包的依赖声明。\n\nuseCalculatedVersionForSnapshots#\n\n类型：boolean\n\n默认值：false\n\n使用快照发布时，默认会使用 0.0.0-timestamp\n的版本格式，保证用户可以正常使用预发布版本。当你需要忽略上述问题，使用正常的版本号格式时，即当前版本为 1.0.1\n快照版本期望使用1.0.1-timestamp，可配置该参数为 true。","frontmatter":{"sidebar_position":5},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/changesets/config.mdx","_relativePath":"zh/guides/topic-detail/changesets/config.mdx"},{"id":532,"title":"使用 Github 相关工具","routePath":"/guides/topic-detail/changesets/github","lang":"zh","toc":[{"text":"BOT","id":"bot","depth":2,"charIndex":3},{"text":"安装","id":"安装","depth":3,"charIndex":101},{"text":"配置","id":"配置","depth":3,"charIndex":135},{"text":"使用","id":"使用","depth":3,"charIndex":173},{"text":"未添加 changeset","id":"未添加-changeset","depth":4,"charIndex":248},{"text":"已添加 changeset","id":"已添加-changeset","depth":4,"charIndex":330},{"text":"不需要 changeset","id":"不需要-changeset","depth":4,"charIndex":375},{"text":"Action","id":"action","depth":2,"charIndex":436},{"text":"自动创建 Release Pull Request","id":"自动创建-release-pull-request","depth":3,"charIndex":446},{"text":"使用","id":"使用-1","depth":4,"charIndex":577},{"text":"自动 Release","id":"自动-release","depth":3,"charIndex":1975},{"text":"使用","id":"使用-2","depth":4,"charIndex":2063}],"domain":"","content":"#\n\n\nBOT#\n\n在 Github 上，changesets 提供了机器人用于检测当前 Pull Request 是否存在 changeset，并提供了 UI 界面添加和修改\nchangeset。\n\n\n安装#\n\n点击进入链接，右上角选择安装，确认即可安装成功。\n\n\n\n\n配置#\n\n安装成功后，即可进入配置页面，根据需求选择应用仓库即可。\n\n\n\n\n使用#\n\n配置完成后，该机器人将会自动 check 每个 Pull Request 是否添加了 changeset，并通过回复的方式给到提示信息。\n\n未添加 changeset#\n\n\n\n可在仓库执行 pnpm run change 添加 changeset，也可直接点击下方第二个链接填写 changeset。\n\n已添加 changeset#\n\n\n\n可点击下方链接修改和添加新的 changeset。\n\n不需要 changeset#\n\n可直接忽略未添加时的提示信息，它不会造成 Pull Request 不能合并的问题。\n\n\nAction#\n\n\n自动创建 Release Pull Request#\n\nModern.js 提供了自动创建发版 Pull Request 的 Github Action，提供基于选择的分支自动执行 bump 操作，更新 lock\n文件及创建 Pull Request 操作。\n\n使用#\n\n * 在仓库中创建 .github/workflows/release-pull-request.yml 文件，填入以下内容：\n\nname: Release Pull Request\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        type: choice\n        description: 'Release Type(canary, beta, alpha, latest)'\n        required: true\n        default: 'latest'\n        options:\n        - canary\n        - beta\n        - alpha\n        - latest\n\njobs:\n  release:\n    name: Create Release Pull Request\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@master\n        with:\n          # This makes Actions fetch only one branch to release\n          fetch-depth: 100\n\n      - ... # install dependencies and build repo package\n      - name: Create Release Pull Request\n        uses: web-infra-dev/actions@v2\n        with:\n          version: ${{ github.event.inputs.version }}\n          versionNumber: 'auto'\n          type: 'pull request'\n          tools: 'modern'\n        env:\n          GITHUB_TOKEN: ${{ secrets.REPO_SCOPED_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n          REPOSITORY: ${{ github.repository }}\n          REF: ${{ github.ref }}\n\n\n * 将 Workflow 合并到主分支后，进入 Github 仓库对应的 Action 页面，选择 Release Pull Request：\n\n\n\n * 选择本次发布类型，点击 Run workflow 按钮：\n\n\n\n * Workflow 运行完成后将自动创建 Release-${version} 的 Pull Request，自动完成 bump changeset\n   相关版本号并更新 lock 文件，Pull Request 的内容为执行 gen-release-note 命令自动生成的 Release Note。\n\n\n\n\n自动 Release#\n\nModern.js 提供了自动发布版本 的 Github Action，提供基于选择的分支自动执行 release 操作，将包发布到 NPM 上。\n\n使用#\n\n * 在仓库中创建 .github/workflows/release.yml 文件，填入以下内容：\n\nname: Release\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        type: choice\n        description: 'Release Version(canary, beta, alpha, latest)'\n        required: true\n        default: 'next'\n        options:\n        - canary\n        - beta\n        - alpha\n        - latest\n      branch:\n        description: 'Release Branch(confirm release branch)'\n        required: true\n        default: 'main'\n\njobs:\n  release:\n    name: Release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@master\n        with:\n          # This makes Actions fetch only one branch to release\n          fetch-depth: 1\n\n      - ... # install dependencies and build repo package\n      - name: Release\n        uses: web-infra-dev/actions@v2\n        with:\n          version: ${{ github.event.inputs.version }}\n          branch: ${{ github.event.inputs.branch }}\n          type: 'release'\n          tools: 'modern'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n          REPOSITORY: ${{ github.repository }}\n          REF: ${{ github.ref }}\n\n\n * 配置仓库的 NPM_TOKEN:\n\n\n\n * 将 Workflow 合并到主分支后，进入 Github 仓库对应的 Action 页面，选择 Release：\n\n\n\n * 选择分支名称和发布版本类型，点击 Run workflow 按钮：\n\n\n\n * Workflow 将自动完成仓库 build 和发布到 NPM 流程。","frontmatter":{"sidebar_position":9},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/changesets/github.mdx","_relativePath":"zh/guides/topic-detail/changesets/github.mdx"},{"id":533,"title":"认识 Changesets","routePath":"/guides/topic-detail/changesets/introduce","lang":"zh","toc":[{"text":"特点","id":"特点","depth":2,"charIndex":58},{"text":"初始化","id":"初始化","depth":2,"charIndex":283},{"text":"命令","id":"命令","depth":2,"charIndex":865}],"domain":"","content":"#\n\nModern.js 默认集成了 changesets 用于模块和 Monorepo 工程方案的包版本管理。\n\n\n特点#\n\nChangesets 具有以下几个特点：\n\n * 在开发时，需要开发者提供本次变更涉及的包名称、升级版本类型(pathch、minor、major)及变更信息，即 changeset。\n\n * 在发布版本时，会根据 changeset 内容自动升级对应包的版本号，并在对应的包中生成 changelog 信息。\n\n * 在 Monorepo 项目中，changeset 会自动生成仓库依赖图，升级时只会升级变更包及相关依赖包的版本号。\n\n\n初始化#\n\nModern.js 默认创建的模块和 Monorepo 工程方案项目已经初始化完成 changesets，在项目根目录会自动创建 .changeset 目录，及\n.changeset/config.json 的配置文件。\n\n并且，Modern.js 在其对应的工程方案工具 @modern-js/module-tools 和 @modern-js/monorepo-tools 提供了\nchangesets 相应的命令，无需再手动安装 changesets 相关依赖。\n\nChangesets 默认配置如下：\n\n{\n  \"$schema\": \"https://unpkg.com/@changesets/config@2.0.0/schema.json\",\n  \"changelog\": \"@changesets/cli/changelog\",\n  \"commit\": false,\n  \"linked\": [],\n  \"access\": \"restricted\",\n  \"baseBranch\": \"main\",\n  \"updateInternalDependencies\": \"patch\",\n  \"ignore\": []\n}\n\n\n配置文件提供了生成 changesets 的一些基本配置，字段详细介绍请参考 Changesets 配置文件。\n\n\n命令#\n\n * change： 创建一个 changeset，执行完成该命令后会自动在 .changeset 目录生成一个 changeset 文件。\n\n * bump： 根据当前 changeset 升级对应包版本号。\n\n * pre： 标记进入和退出 pre-release 模式，在 pre release 模式下执行 bump 命令，将会生成\n   x.x.x-${pre-tag}.x 的版本号格式。\n\n * release： 发布包到 NPM。\n\n * status： 查看当前 changeset 状态。\n\n * gen-release-note： 根据当前的 chagneset 状态生成 Release Note 信息。\n\n具体命令支持的参数可以查看后续对应章节介绍。","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/changesets/introduce.mdx","_relativePath":"zh/guides/topic-detail/changesets/introduce.mdx"},{"id":534,"title":"自定义 Release Note 格式","routePath":"/guides/topic-detail/changesets/release-note","lang":"zh","toc":[{"text":"信息","id":"信息","depth":2,"charIndex":481},{"text":"getReleaseInfo","id":"getreleaseinfo","depth":3,"charIndex":487},{"text":"Params","id":"params","depth":4,"charIndex":610},{"text":"返回值","id":"返回值","depth":4,"charIndex":1278},{"text":"默认实现","id":"默认实现","depth":4,"charIndex":1314},{"text":"getReleaseNoteLine","id":"getreleasenoteline","depth":4,"charIndex":2481},{"text":"Params","id":"params-1","depth":4,"charIndex":2591},{"text":"返回值","id":"返回值-1","depth":4,"charIndex":2700},{"text":"默认实现","id":"默认实现-1","depth":4,"charIndex":2725},{"text":"使用自定义模块","id":"使用自定义模块","depth":2,"charIndex":3312},{"text":"配置相对路径","id":"配置相对路径","depth":3,"charIndex":3394},{"text":"使用模块工程方案","id":"使用模块工程方案","depth":3,"charIndex":3953},{"text":"使用 npx @modern-js/create@latest 创建模块工程方案","id":"使用-npx-@modern-js/create@latest-创建模块工程方案","depth":4,"charIndex":3999},{"text":"实现自定义内容","id":"实现自定义内容","depth":4,"charIndex":4125},{"text":"将模块发布到 NPM","id":"将模块发布到-npm","depth":4,"charIndex":4214},{"text":"在目标仓库根目录安装对应模块，例如 custom-release-note","id":"在目标仓库根目录安装对应模块，例如-custom-release-note","depth":4,"charIndex":4227},{"text":"执行 gen-release-note 命令添加 custom 参数","id":"执行-gen-release-note-命令添加-custom-参数","depth":4,"charIndex":4267},{"text":"使用 Monorepo 工程方案","id":"使用-monorepo-工程方案","depth":3,"charIndex":4362},{"text":"执行 pnpm run new 创建模块子项目","id":"执行-pnpm-run-new-创建模块子项目","depth":4,"charIndex":4422},{"text":"实现自定义内容","id":"实现自定义内容-1","depth":4,"charIndex":4549},{"text":"在 Monorepo 根目录添加子项目模块依赖，例如 custom-release-note。","id":"在-monorepo-根目录添加子项目模块依赖，例如-custom-release-note。","depth":4,"charIndex":4638},{"text":"执行 gen-release-note 命令添加 --custom 参数","id":"执行-gen-release-note-命令添加---custom-参数","depth":4,"charIndex":4768}],"domain":"","content":"#\n\nModern.js 提供了 modern gen-release-note 命令，支持通过当前存在的 changeset 和 git commit 信息自动生成\nRelease Note 信息，在发布命令执行之前，可以通过执行该命令生成本次发布的 Release Note。\n\n默认生成的 Release Note 格式为：\n\n- fix: add missing type definitions by @zllkjc in https://github.com/web-infra-dev/modern.js/pull/3835\n\n\n根据 commit 信息获取 changeset 的 Pull Request ID，并生成 Github 的链接，内容为 changeset 的\nchangelog 信息和作者信息。\n\nINFO\n\n获取作者信息，需要提供 Github Token 环境变量，通过 GITHUB_AUTH_TOKEN 传入。\n\n当默认生成 Release Note 逻辑不能满足需求时，支持自定义 Release Note 格式。\n\n\n信息#\n\n\ngetReleaseInfo#\n\n生成 Release Note 信息需要先收集一些信息，比如 commit ID、Pull Request ID、commit message 等等。\n\n该逻辑可通过 getReleaseInfo 函数实现。\n\nParams#\n\n * commit\n\n类型： string;\n\n当前 changeset 对应的 commit message 信息。\n\n执行 git log --pretty=format:%h--%s--%ae .changeset/${changeset.id}.md 的结果。\n\n * commitObj\n\n初步解析 commit 获取基本信息。\n\nexport enum CommitType {\n  Performance = 'performance',\n  Features = 'features',\n  BugFix = 'bugFix',\n  Doc = 'doc',\n  Other = 'other',\n}\n\ninterface Commit {\n  id: string; // commit id\n  type: CommitType;\n  repository?: string; // 参数传入的 repo 信息或者 package.json 中定义的 repository 信息\n  pullRequestId?: string;\n  author?: string;\n  message: string; // commit message\n  summary: string; // changeset summary\n  summary_zh: string; // changeset zh summary\n  [key: string]: string | undefined;\n}\n\n\n返回值#\n\ncommitObj， 补充后完整的 commit 对象。\n\n默认实现#\n\nModern.js 的默认实现为：根据 commit 信息拆分出 Pull Request ID，并根据 commit id 获取到用户信息，加入到\ncommitObj 中。\n\nfunction getReleaseInfo(commit: string, commitObj: Commit) {\n  const commitRegex = /(.*)\\(#(\\d*)\\)/;\n\n  const [commitId, message, email] = commit.split('--');\n\n  const author = AuthorMap.get(email);\n  const token = authToken || process.env.GITHUB_AUTH_TOKEN;\n  if (author) {\n    commitObj.author = author;\n  } else if (repo && token) {\n    try {\n      const res = await axios.get(\n        `https://api.github.com/repos/${repo}/commits/${commitId}`,\n        {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: token,\n          },\n        },\n      );\n      const author = res.data.author.login;\n      commitObj.author = author;\n      AuthorMap.set(email, author);\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n\n  if ((message || commitObj.summary).match(commitRegex)) {\n    const [, messageShort, pullRequestId] = (\n      message || commitObj.summary\n    ).match(commitRegex)!;\n    commitObj.pullRequestId = pullRequestId;\n    commitObj.message = messageShort.trim();\n  }\n\n  return commitObj;\n}\n\n\ngetReleaseNoteLine#\n\n根据 getReleaseInfo 中获取的 commit 对象信息，生成对应的 Release Note。\n\n该逻辑可通过 getReleaseNoteLine 函数实现。\n\nParams#\n\n * commit\n\n类型和上述 commitObj 类型一致。\n\n * lang\n\n类型： string;\n\n获取对应语言的 Release Note 信息，支持 en 和 zh，默认为 en。\n\n返回值#\n\n生成的 Release Note。\n\n默认实现#\n\nModern.js 的默认实现为：\n\nexport function getReleaseNoteLine(\n  commit: Commit,\n  lang: 'en' | 'zh' = 'en',\n) {\n  const { repository, pullRequestId, summary, summary_zh, author } = commit;\n  const pullRequest =\n    pullRequestId && repository\n      ? `https://github.com/${repository}/pull/${pullRequestId}`\n      : '';\n  if (lang === 'en') {\n    return `- ${summary}${author ? ` by @${author}` : ''}${\n      pullRequest ? ` in ${pullRequest}` : ''\n    }\\n`;\n  }\n  return `- ${summary_zh}${author ? ` 由 @${author} 实现` : ''}${\n    pullRequest ? `， 详情可查看 ${pullRequest}` : ''\n  }\\n`;\n}\n\n\n\n使用自定义模块#\n\ngen-release-note 命令支持 --custom 参数，该参数可传入自定义 Release Note 模块的模块名称或者路径。\n\n\n配置相对路径#\n\ncustom 参数值如果为相对路径为项目跟目录。\n\n例如创建 scripts/my-release-note-config.js 文件，定义如下内容：\n\nfunction getReleaseInfo(commit, commitObj) {\n  return commitObj;\n}\n\nfunction getReleaseNoteLine(commit) {}\n\nmodule.exports = {\n  getReleaseInfo,\n  getReleaseNoteLine,\n};\n\n\n执行下面命令：\n\npnpm run gen-release-note --custom ./scripts/my-release-note-config.js\n\n\n也可以把命令参数直接定义到 package.json 中：\n\n{\n    \"scripts\": {\n        ...\n        \"gen-release-note\": \"modern gen-release-note --custom ./scripts/my-release-note-config.js\"\n    },\n    ...\n}\n\n\n直接执行命令 pnpm run gen-release-note 即可。\n\n\n使用模块工程方案#\n\ncustom 参数值还可以使用模块工程方案进行管理，提供通用方案。\n\n使用 npx @modern-js/create@latest 创建模块工程方案#\n\n? 请选择你想创建的工程类型：Npm 模块\n? 请填写项目名称：custom-release-note\n? 请选择开发语言：TS\n? 请选择包管理工具：pnpm\n\n\n实现自定义内容#\n\nexport function getReleaseInfo() {}\n\nexport function getReleaseNoteLine() {}\n\n\n将模块发布到 NPM#\n\n在目标仓库根目录安装对应模块，例如 custom-release-note#\n\n执行 gen-release-note 命令添加 custom 参数#\n\npnpm run gen-release-note --custom custom-release-note\n\n\n\n使用 Monorepo 工程方案#\n\n如果你当前仓库为 Monorepo 工程方案，可以直接使用模块子项目进行管理。\n\n执行 pnpm run new 创建模块子项目#\n\n? 请选择你想创建的工程类型：Npm 模块\n? 请填写子项目名称：custom-release-note\n? 请填写子项目目录名称：custom-release-note\n? 请选择开发语言：TS\n\n\n实现自定义内容#\n\nexport function getReleaseInfo() {}\n\nexport function getReleaseNoteLine() {}\n\n\n在 Monorepo 根目录添加子项目模块依赖，例如 custom-release-note。#\n\n{\n  \"devDependencies\": {\n    \"custom-release-note\": \"workspace: *\",\n    ...\n}\n\n\n执行 gen-release-note 命令添加 --custom 参数#\n\npnpm run gen-release-note --custom custom-release-note\n\n\n该模块发布到 NPM 后，依然可以和模块类型一样供其他仓库使用。","frontmatter":{"sidebar_position":8},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/changesets/release-note.mdx","_relativePath":"zh/guides/topic-detail/changesets/release-note.mdx"},{"id":535,"title":"发布预发布版本","routePath":"/guides/topic-detail/changesets/release-pre","lang":"zh","toc":[{"text":"步骤","id":"步骤","depth":2,"charIndex":60},{"text":"执行 bump 命令升级预发布版本版本号","id":"执行-bump-命令升级预发布版本版本号","depth":4,"charIndex":120},{"text":"检查相关变更并提交","id":"检查相关变更并提交","depth":4,"charIndex":349},{"text":"执行 release 命令发布预发布版本","id":"执行-release-命令发布预发布版本","depth":4,"charIndex":432},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":530},{"text":"退出预发布模式","id":"退出预发布模式","depth":3,"charIndex":538}],"domain":"","content":"#\n\n在发布正式版本之前，我们也需要发布预发布版本供内部测试和用户使用，changesets 也支持发布预发布版本。\n\n\n步骤#\n\nINFO\n\n以下示例命令都以 pnpm 作为包管理工具进行，如果需要使用其他包管理工具，请按需求进行替换。\n\n执行 bump 命令升级预发布版本版本号#\n\npnpm run bump --canary --preid \n\n\npreid 为预发布版本标记，例如 alpha、beta 等，默认值为 next。\n\n使用 --canary 参数后，bump 命令由以下三个步骤完成：\n\n * changeset pre enter 进入预发布模式。\n\n * changeset version 升级版本号。\n\n * changeset pre exit 退出预发布模式。\n\n检查相关变更并提交#\n\n检查相关版本号变更是否正确，并提交变更。\n\n建议预发布操作不在主分支上进行，不合入主分支，当预发布验证完成后，直接基于主分支发布正式版本。\n\n执行 release 命令发布预发布版本#\n\npnpm run release --tag \n\n\n发布预发布版本一定要使用 --tag 参数，参数值最好和 preid 值相同，方便用户使用。\n\n\n注意事项#\n\n\n退出预发布模式#\n\n在进入预发布模式后，changesets 会自动在 .changeset 目录创建 pre.json\n文件用于记录当时进入预发布模式的一些状态信息，当出现状态信息和当前仓库状态不一致时，可直接删除该文件退出预发布模式。","frontmatter":{"sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/changesets/release-pre.mdx","_relativePath":"zh/guides/topic-detail/changesets/release-pre.mdx"},{"id":536,"title":"发布正式版本","routePath":"/guides/topic-detail/changesets/release","lang":"zh","toc":[{"text":"步骤","id":"步骤","depth":2,"charIndex":74},{"text":"模块工程方案","id":"模块工程方案","depth":3,"charIndex":135},{"text":"在根目录执行 bump 命令","id":"在根目录执行-bump-命令","depth":4,"charIndex":144},{"text":"确认并提交当前变更","id":"确认并提交当前变更","depth":4,"charIndex":331},{"text":"在根目录执行以下命令发布包至 NPM","id":"在根目录执行以下命令发布包至-npm","depth":4,"charIndex":393},{"text":"push 对应的 tag 信息至远程仓库","id":"push-对应的-tag-信息至远程仓库","depth":4,"charIndex":435},{"text":"Monorepo 工程方案","id":"monorepo-工程方案","depth":3,"charIndex":484},{"text":"在根目录执行 bump 命令","id":"在根目录执行-bump-命令-1","depth":4,"charIndex":500},{"text":"确认并提交当前变更","id":"确认并提交当前变更-1","depth":4,"charIndex":770},{"text":"在根目录执行以下命令发布包至 NPM","id":"在根目录执行以下命令发布包至-npm-1","depth":4,"charIndex":881},{"text":"push 对应的 tag 信息至远程仓库","id":"push-对应的-tag-信息至远程仓库-1","depth":4,"charIndex":1147},{"text":"参数","id":"参数","depth":2,"charIndex":1196},{"text":"bump 命令参数","id":"bump-命令参数","depth":3,"charIndex":1202},{"text":"release 命令参数","id":"release-命令参数","depth":3,"charIndex":1662},{"text":"升级版本策略","id":"升级版本策略","depth":2,"charIndex":2094},{"text":"dependencies 或者 devDependencies 依赖","id":"dependencies-或者-devdependencies-依赖","depth":3,"charIndex":2104},{"text":"peerDependencies 依赖","id":"peerdependencies-依赖","depth":3,"charIndex":2578}],"domain":"","content":"#\n\n发版正式版本时，我们需要根据开发过程中生成的 changesets 进行相关包版本号升级，并执行 publish 命令发布到 NPM 上。\n\n\n步骤#\n\nINFO\n\n以下示例命令都以 pnpm 作为包管理工具进行，如果需要使用其他包管理工具，请按需求进行替换。\n\n\n模块工程方案#\n\n在根目录执行 bump 命令#\n\npnpm run bump\n\n\n\n\n执行该命令时，changeset 会自动进行以下操作：\n\n * 删除 .changesets 目录下的所有 changeset 文件。\n\n * 根据 changeset 信息升级该包版本号。\n\n * 在根目录的 CHANGELOG.md 文件中写入 changelog 信息，文件不存在时会自动创建。\n\n确认并提交当前变更#\n\ngit add .\ngit commit -m \"release: bump package\"\n\n\n在根目录执行以下命令发布包至 NPM#\n\npnpm run release\n\n\n\n\npush 对应的 tag 信息至远程仓库#\n\ngit push --follow-tags\n\n\n\nMonorepo 工程方案#\n\n在根目录执行 bump 命令#\n\npnpm run bump\n\n\n\n\n执行该命令时，changesets 会自动进行以下操作：\n\n * 删除 .changesets 目录下的所有 changeset 文件。\n\n * 根据 changeset 信息升级相关包的版本号，除了显示写入 changeset 的包，执行命令时还会将 Monorepo\n   中所有的包进行依赖关系分析，如果需要升级，也会对应的自动升级版本号。\n\n * 在需要升级的包目录的 CHANGELOG.md 文件中写入 Changelog 信息，文件不存在时会自动创建。\n\n确认并提交当前变更#\n\nINFO\n\n需确认自动升级的版本号是否符合预期，如果需要了解版本升级策略，请查看升级版本策略。\n\ngit add .\ngit commit -m \"release: bump package\"\n\n\n在根目录执行以下命令发布包至 NPM#\n\npnpm run release\n\n\n执行该命令时，将会依次判断 Monorepo 中所有的 packages 的版本是否在 NPM 中存在，如果不存在将会执行 publish 命令发布。\n\nWARNING\n\n当 Monorepo 中包之间依赖关系使用 workspace 声明时，注意不要直接在 package 对应的子目录直接执行 npm publish 发布\npackage，使用 release 命令在发布时将会自动去除 workspace 声明，确保 NPM 包发布之后可用。\n\npush 对应的 tag 信息至远程仓库#\n\ngit push --follow-tags\n\n\n\n参数#\n\n\nbump 命令参数#\n\n * --snapshot：生成基于时间戳的版本号。\n\npnpm run bump --snapshot canary\n\n\n执行完成后，对应的升级版本号将会变成 0.0.0-canary-20220622092823 的形式，其中 canary 为 snapshot\n配置的标记，如果不配置，将直接生成 0.0.0-20220622092823 的形式。\n\n该参数主要用于发布临时测试版本进行测试，不需要进行代码提交。\n\n * --ignore：发布时手动忽略部分包。\n\n例如本次发布你需要忽略 module-2 包：\n\npnpm run bump --ignore module-2\n\n\n命令执行完成后，将会忽略 module-2 包的更新。注意如果存在包依赖 module-2，需要将对应包也加入到 ignore 参数中，否则 bump\n命令将执行失败。\n\n加入多个包的使用姿势为：\n\npnpm run bump --ignore module-2 --ignore module-3\n\n\n\nrelease 命令参数#\n\n * --otp：使用 npm token 发布包。\n\npnpm run relese --otp \n\n\n * --tag：发布使用特定的 tag，默认使用 latest\n\npnpm run release --tag \n\n\n * --ignore-scripts：发布时忽略 npm scripts。\n\n执行 publish 命令时，npm 会自动触发很多命令，比如 prepare、prepublish，使用该参数可以忽略这些命令执行。该参数仅支持在使用\npnpm 的 Monorepo 中使用。\n\npnpm run release --ignore-scripts\n\n\n * --no-git-checks：发布时忽略检查当前分支。\n\n执行发布命令时，默认会自动检查当前分支是否为发布分支，是否存在未提交变更等等，使用该参数可以忽略 git 相关检查。\n\npnpm run release --no-git-checks\n\n\n\n升级版本策略#\n\n\ndependencies 或者 devDependencies 依赖#\n\n * patch 版本依赖只升级自身\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 dependencies 中存在 module-1。\n\n当前存在的 changeset 为 module-1 的 patch 版本升级。\n\n执行 bump 命令后将只会升级 module-1 的 patch 版本号。\n\n * major / minor 版本自身升级 major 或者 minor 版本号，依赖包升级 patch 版本号\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 dependencies 中存在module-1。\n\n当前存在的 changeset 为 module-1 的 minor 版本升级。\n\n执行 bump 命令后 module-1 会升级 minor 版本号，module -2 会升级 patch 版本号。\n\n\npeerDependencies 依赖#\n\n * patch 版本依赖自身和依赖包都升级 patch 版本号\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 peerDependencies 中存在 module-1。\n\n当前存在的 changeset 为 module-1 的 patch 版本升级。\n\n执行 bump 命令后将 module-1 和 module-2 都升级 patch 版本号。\n\n * major / minor 版本自身升级 major 或者 minor 版本号，依赖包升级 major 版本号\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 peerDependencies 中存在 module-1。\n\n当前存在的 changeset 为 module-1 的 minor 版本升级。\n\n执行 bump 命令后将 module-1 将升级 minor 版本号， module-2 升级 major 版本号。\n\n * 修改 peerDependencies 的升级策略\n\npeerDependencies 的升级策略支持通过配置 onlyUpdatePeerDependentsWhenOutOfRange\n来修改依赖升级策略，当只有超出声明的版本类型范围时，才对应升级 peerDependencies。\n\n{\n  \"___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH\": {\n    \"onlyUpdatePeerDependentsWhenOutOfRange\": true\n  },\n  ...\n}\n\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 peerDependencies 中存在 module-1，声明\nmodule-1 的版本号使用 ^。\n\n当前存在的 changeset 为 module-1 的 patch 或者 minor 版本升级。\n\n执行 bump 命令后只升级 module-1 版本号。\n\n需注意，如果包版本号在 0.x.x 的范围时，minor 版本号升级也是超出声明的版本类型范围的。","frontmatter":{"sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/changesets/release.mdx","_relativePath":"zh/guides/topic-detail/changesets/release.mdx"},{"id":537,"title":"扩展插件 Hook","routePath":"/guides/topic-detail/framework-plugin/extend","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":41},{"text":"创建 Hook","id":"创建-hook","depth":3,"charIndex":165},{"text":"使用 Hook","id":"使用-hook","depth":3,"charIndex":454}],"domain":"","content":"#\n\n本小节介绍如何通过动态注册 Hook 模型 的方式来扩展插件 Hook。\n\n\n示例#\n\n这里我们用一个简单的例子演示一下。假设我们要添加一些管理控制台输出信息的 Hook。\n\n首先我们初始化一个空的项目文件，并添加基础依赖：\n\n$ npx @modern-js/create@latest modern-js-demo\n\n\n\n创建 Hook#\n\n我们先创建一个 Hook 模型：\n\n\n\nconst message = createWaterfall();\n\n\n然后注册它：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  registerHook: {\n    message,\n  },\n});\n\n\n添加 Hook 类型：\n\ndeclare module '@modern-js/core' {\n  export interface Hooks {\n    message: typeof message;\n  }\n}\n\n\n\n使用 Hook#\n\n创建插件，通过 commands Hook 函数，添加命令处理逻辑：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup(api) {\n    return {\n      commands({ program }) {\n        program.command('message').action(async () => {\n          const hookRunners = api.useHookRunners();\n          const messages = hookRunners.message([]);\n          console.log(messages.join('\\n'));\n        });\n      },\n    };\n  },\n});\n\n\n最后 config/plugin/myPlugin.ts 的状态是：\n\n\n\n\nconst message = createWaterfall();\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  registerHook: {\n    message,\n  },\n\n  setup(api) {\n    return {\n      commands({ program }) {\n        program.command('message').action(async () => {\n          const hookRunners = api.useHookRunners();\n          const messages = hookRunners.message([]);\n          console.log(messages.join('\\n'));\n        });\n      },\n    };\n  },\n});\n\ndeclare module '@modern-js/core' {\n  export interface Hooks {\n    message: typeof message;\n  }\n}\n\n\n然后在 modern.config.ts 中添加这个插件：\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n这时运行 npx modern message 就会执行相关逻辑，但由于没有收集到任何信息，所以控制台输出为空。\n\n那这里我们添加一个：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'other-plugin',\n\n  setup(api) {\n    return {\n      message(list) {\n        return [...list, '[foo] line 0', '[foo] line 1'];\n      },\n    };\n  },\n});\n\n\n将它添加到配置中：\n\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin(), otherPlugin()],\n});\n\n\n这时运行 npx modern message 就可以在控制台看到信息了：\n\n$ modern message\n[foo] line 0\n[foo] line 1\n\n\n以上面这种方式就可以扩展出拥有各种能力的插件 Hook。","frontmatter":{"title":"扩展插件 Hook","sidebar_position":5},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/framework-plugin/extend.mdx","_relativePath":"zh/guides/topic-detail/framework-plugin/extend.mdx"},{"id":538,"title":"Hook 列表","routePath":"/guides/topic-detail/framework-plugin/hook-list","lang":"zh","toc":[{"text":"CLI","id":"cli","depth":2,"charIndex":60},{"text":"beforeConfig","id":"beforeconfig","depth":3,"charIndex":67},{"text":"config","id":"config","depth":3,"charIndex":313},{"text":"validateSchema","id":"validateschema","depth":3,"charIndex":626},{"text":"prepare","id":"prepare","depth":3,"charIndex":1415},{"text":"afterPrepare","id":"afterprepare","depth":3,"charIndex":1655},{"text":"commands","id":"commands","depth":3,"charIndex":1908},{"text":"beforeExit","id":"beforeexit","depth":3,"charIndex":2442},{"text":"beforeDev","id":"beforedev","depth":3,"charIndex":2756},{"text":"afterDev","id":"afterdev","depth":3,"charIndex":3016},{"text":"beforeCreateCompiler","id":"beforecreatecompiler","depth":3,"charIndex":3572},{"text":"afterCreateCompiler","id":"aftercreatecompiler","depth":3,"charIndex":3950},{"text":"beforePrintInstructions","id":"beforeprintinstructions","depth":3,"charIndex":4327},{"text":"beforeBuild","id":"beforebuild","depth":3,"charIndex":4753},{"text":"afterBuild","id":"afterbuild","depth":3,"charIndex":5078},{"text":"modifyEntryImports","id":"modifyentryimports","depth":3,"charIndex":5345},{"text":"modifyEntryExport","id":"modifyentryexport","depth":3,"charIndex":5922},{"text":"modifyEntryRuntimePlugins","id":"modifyentryruntimeplugins","depth":3,"charIndex":6425},{"text":"modifyEntryRenderFunction","id":"modifyentryrenderfunction","depth":3,"charIndex":7063},{"text":"modifyFileSystemRoutes","id":"modifyfilesystemroutes","depth":3,"charIndex":7538},{"text":"modifyServerRoutes","id":"modifyserverroutes","depth":3,"charIndex":8156},{"text":"modifyAsyncEntry","id":"modifyasyncentry","depth":3,"charIndex":8714},{"text":"htmlPartials","id":"htmlpartials","depth":3,"charIndex":9194},{"text":"Runtime","id":"runtime","depth":2,"charIndex":9643},{"text":"init","id":"init","depth":3,"charIndex":9727},{"text":"hoc","id":"hoc","depth":3,"charIndex":10046}],"domain":"","content":"#\n\n在 Modern.js 中暴露了三类插件：CLI、Runtime、Server。下面列举下各类中的 Hook：\n\n\nCLI#\n\n\nbeforeConfig#\n\n * 功能：运行收集配置前的任务\n * 执行阶段：收集配置前\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeConfig: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nconfig#\n\n * 功能：收集配置\n * 执行阶段：解析完 modern.config.ts 中的配置之后\n * Hook 模型：ParallelWorkflow\n * 类型：ParallelWorkflow\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      config: () => {\n        return {\n          /** some config */\n        };\n      },\n    };\n  },\n});\n\n\n这里返回的配置信息，会被收集和统一处理合并。\n\n\nvalidateSchema#\n\n * 功能：收集各个插件中配置的用来校验用户配置的 JSON Schema\n * 执行阶段：config Hook 运行完之后。\n * Hook 模型：ParallelWorkflow\n * 类型：ParallelWorkflow\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      validateSchema: () => {\n        return {\n          // target is field\n          target: 'foo',\n          schema: {\n            type: 'string',\n          },\n        };\n      },\n    };\n  },\n});\n\n\n这里返回的 JSON Schema 会用来校验 modern.config.js 中的配置信息。\n\n比如这里返回：\n\n{\n  \"target\": \"foo\",\n  \"schema\": {\n    \"type\": \"string\"\n  }\n}\n\n\n就可以在 modern.config.ts 中这样配置：\n\nexport default defineConfig({\n  foo: 'test',\n});\n\n\n如果是别的类型，校验就不通过会报错，比如这样：\n\nexport default defineConfig({\n  foo: {},\n});\n\n\n就会报错：\n\n$ modern dev\n  1 | {\n> 2 |   \"foo\": {},\n    |   ^^^^^  Property foo is not expected to be here\n\n\n\nprepare#\n\n * 功能：运行主流程的前置准备流程\n * 执行阶段：校验完配置之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      prepare: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterPrepare#\n\n * 功能：运行前置准备流程的之后的任务\n * 执行阶段：前置准备流程之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterPrepare: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\ncommands#\n\n * 功能：为 command 添加新的命令\n * 执行阶段：prepare Hook 运行完之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ program: Command; }, void>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      commands: ({ program }) => {\n        program.command('foo').action(async () => {\n          // do something\n          console.log('foo');\n        });\n      },\n    };\n  },\n});\n\n\n将上面这个插件添加到 modern.config.ts 中：\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n运行 modern foo 就可以看到控制台输出：\n\n$ modern foo\nfoo\n\n\n\nbeforeExit#\n\n * 功能：在退出进程前，重置一些文件状态\n * 执行阶段：进程退出之前\n * Hook 模型：Workflow\n * 类型：Workflow\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeExit: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\nTIP\n\n由于 Node.js 中退出进程时的回调函数是同步的，所以 beforeExit Hook 的类型是 Workflow，不能执行异步操作。\n\n\nbeforeDev#\n\n * 功能：运行 dev 主流程的之前的任务\n * 执行阶段：dev 命令运行时，项目开始启动前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeDev: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterDev#\n\n * 功能：运行 dev 主流程的之后的任务\n * 执行阶段：运行 dev 命令时，每一次编译完成后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ isFirstCompile: boolean }, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterDev: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\nafterDev 会在每一次编译完成后执行，你可以通过 isFirstCompile 参数来判断是否为首次编译：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterDev: ({ isFirstCompile }) => {\n        if (isFirstCompile) {\n          // do something\n        }\n      },\n    };\n  },\n});\n\n\n\nbeforeCreateCompiler#\n\n * 功能：在中间件函数中可以拿到创建 Webpack Compiler 的 Webpack 配置\n * 执行阶段：创建 Webpack Compiler 之前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ webpackConfigs: Configuration[];}, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeCreateCompiler: ({ webpackConfigs }) => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterCreateCompiler#\n\n * 功能：在中间件函数中可以拿到创建的 Webpack Compiler\n * 执行阶段：创建 Webpack Compiler 之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ compiler: Compiler | MultiCompiler | undefined; },\n   unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterCreateCompiler: ({ compiler }) => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nbeforePrintInstructions#\n\n * 功能：在中间件函数中可以拿到即将打印的日志信息，并对其进行修改\n * 执行阶段：打印日志信息之前执行\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ instructions: string }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforePrintInstructions: ({ instructions }) => {\n        // do something\n        return {\n          instructions: [...instructions, 'some new message'],\n        };\n      },\n    };\n  },\n});\n\n\n\nbeforeBuild#\n\n * 功能：运行 build 主流程的之前的任务，可以拿到构建的 Webpack 配置\n * 执行阶段：build 命令运行时，项目构建启动前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ webpackConfigs: Configuration[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeBuild: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterBuild#\n\n * 功能：运行 build 主流程的之后的任务\n * 执行阶段：build 命令运行时，项目构建完成之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterBuild: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryImports#\n\n * 功能：用于修改、添加生成入口文件中的 import 语句\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ imports: ImportStatement[]; entrypoint: Entrypoint; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryImports({ entrypoint, imports }) {\n        // 添加 ``\n        imports.push({\n          value: 'react',\n          specifiers: [\n            {\n              imported: 'unmountComponentAtNode',\n            },\n          ],\n        });\n\n        return { entrypoint, imports };\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryExport#\n\n * 功能：用于修改生成入口文件中的 export 语句\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; exportStatement: string; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryExport({ entrypoint, exportStatement }) {\n        return {\n          entrypoint,\n          exportStatement: [`export const foo = 'test'`, exportStatement].join(\n            '\\n',\n          ),\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryRuntimePlugins#\n\n * 功能：用于添加、修改生成入口文件中的 Runtime 插件\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; plugins: RuntimePlugin[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryRuntimePlugins({ entrypoint, plugins }) {\n        const name = 'customPlugin';\n        const options = {\n          /** 可序列化的内容 */\n        };\n\n        return {\n          plugins: [\n            ...plugins,\n            {\n              name,\n              options: JSON.stringify(options),\n            },\n          ],\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryRenderFunction#\n\n * 功能：用于修改生成入口文件中 render 函数\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; code: string; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryRenderFunction({ entrypoint, code }) {\n        const customRender = `/** render function body */`;\n        return {\n          entrypoint,\n          code: customRender,\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyFileSystemRoutes#\n\n * 功能：用于修改生成前端页面路由文件中的内容，内容都是需要可序列化的\n * 执行阶段：生成前端路由文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; routes: Route[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyFileSystemRoutes({ entrypoint, routes }) {\n        return {\n          entrypoint,\n          routes: [\n            ...routes,\n            {\n              path: '/custom_page',\n              component: require.resolve('./Component'),\n              exact: true,\n            },\n          ],\n        };\n      },\n    };\n  },\n});\n\n\n这样就为前端新增了一个页面路由。\n\n\nmodifyServerRoutes#\n\n * 功能：用于修改生成服务器路由中的内容\n * 执行阶段：生成 Server 路由文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ routes: ServerRoute[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyServerRoutes({ routes }) {\n        return {\n          routes: [\n            ...routes,\n            {\n              urlPath: '/api/foo',\n              isApi: true,\n              entryPath: '',\n              isSPA: false,\n              isSSR: false,\n            },\n          ],\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyAsyncEntry#\n\n * 功能：用于修改包裹入口文件的异步模块，参见 source.enableAsyncEntry\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; code: string; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyAsyncEntry({ entrypoint, code }) {\n        const customCode = `console.log('hello');`;\n        return {\n          entrypoint,\n          code: `${customCode}${code}`,\n        };\n      },\n    };\n  },\n});\n\n\n\nhtmlPartials#\n\n * 功能：用于定制生成的 HTML 页面模版\n * 执行阶段：prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; partials: HtmlPartials; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      async htmlPartials({ entrypoint, partials }) {\n        partials.head.push('');\n        return {\n          entrypoint,\n          partials,\n        };\n      },\n    };\n  },\n});\n\n\n这样就为 HTML 模版中新增了一个 Script 标签。\n\n\nRuntime#\n\nNOTE\n\n目前 Runtime 插件还未完全开放，API 不保证稳定，使用需谨慎。\n\nRuntime 插件主要用于开发者修改需要渲染的组件。\n\n\ninit#\n\n * 功能：执行 App.init\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<{ context: RuntimeContext; }, unknown>\n * 使用示例：\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    return {\n      init({ context }, next) {\n        // do something\n        return next({ context });\n      },\n    };\n  },\n});\n\n\n\nhoc#\n\n * 功能：修改需要渲染的组件\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：Pipeline\n * 类型：Pipeline<{ App: React.ComponentType; }, React.ComponentType>\n * 使用示例：\n\nNOTE\n\n使用 hoc 钩子时，需要把原来的 App 组件的静态属性拷贝到新的组件上，并透传 props.\n\n\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    const FooContext = createContext('');\n    return {\n      hoc({ App }, next) {\n        const AppWrapper = (props: any) => {\n          return (\n            \n              \n            \n          );\n        };\n        return next({\n          App: hoistNonReactStatics(AppWrapper, App),\n        });\n      },\n    };\n  },\n});\n","frontmatter":{"title":"Hook 列表","sidebar_position":8},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/framework-plugin/hook-list.mdx","_relativePath":"zh/guides/topic-detail/framework-plugin/hook-list.mdx"},{"id":539,"title":"Hook 模型","routePath":"/guides/topic-detail/framework-plugin/hook","lang":"zh","toc":[{"text":"基础工作方式","id":"基础工作方式","depth":2,"charIndex":112},{"text":"不同 Hook 模型的区别","id":"不同-hook-模型的区别","depth":2,"charIndex":1339},{"text":"Pipeline","id":"pipeline","depth":3,"charIndex":1432},{"text":"Waterfall","id":"waterfall","depth":3,"charIndex":1690},{"text":"Workflow","id":"workflow","depth":3,"charIndex":2319},{"text":"Hook 模型对比","id":"hook-模型对比","depth":2,"charIndex":2913}],"domain":"","content":"#\n\n首先介绍一下 Modern.js 的基础的插件系统中的一些内容，包括 Hook 模型的工作方式、各个 Hook 模型的运行模式、Manager 的工作模式。\n\n每种 Hook 模型都是独立的，可以独立管理运行函数。\n\n\n基础工作方式#\n\n先以 Pipeline 为例，简单介绍一下 Hook 模型的工作方式。先看一个简单的例子：\n\n\n\n// 1. 创建\nconst pipeline = createPipeline();\n\n// 2. 添加函数\npipeline.use((count, next) => {\n  return next(count + 1);\n});\npipeline.use((count, next) => {\n  return count * 2;\n});\n\n// 3. 执行\npipeline.run(1); // 4\npipeline.run(5); // 12\n\n\n在这个例子中，创建了一个 Pipeline 类型的 Pipeline（L3），这意味着运行它的时候，你需要传入一个 number，然后你会得到一个\nnumber，而这个模型管理的函数的类型是：\n\n(count: number, next: (nextCount: number) => number) => number;\n\n\n这里全是 number，是因为我们创建的是 Pipeline ，如果创建的是 Pipeline 则运行它入参是 number，返回值是\nstring，对应管理的函数的类型会是：\n\n(count: number, next: (nextCount: number) => string) => string;\n\n\n创建好 Pipeline 之后，可以通过 use 添加函数（L5、L8），需要注意的是，添加的顺序就是他们默认的运行顺序，在这些函数中，你可以对 count\n进行处理、返回一个值，如果你调用了 next 函数，则会运行后面的函数，即如果你添加了三个函数： A、B、C，如果你在 A 中调用 next 那么就会运行\nB，同样的，如果你在 B 中调用 next 那么就会运行 C，而在上面的例子中，添加的第一个函数（L5）就运行了\nnext，所以这里就会运行第二个函数（L8），并且运行的返回值就是 第二个函数的返回值，如果在第一个函数中没有调用 next，直接返回，例如：\n\n\n\n// 1. 创建\nconst pipeline = createPipeline();\n\n// 2. 添加函数\npipeline.use((count, next) => {\n  return count + 1;\n});\npipeline.use((count, next) => {\n  return count * 2;\n});\n\n// 3. 执行\npipeline.run(1); // 2\npipeline.run(5); // 6\n\n\n则在运行 Pipeline 的时候就不会运行第二个函数，那么 Pipeline 的运行结果则就是第一个函数的返回值。\n\n最后，运行 Pipeline 的方式也显而易见就是调用 pipeline.run 。\n\n\n不同 Hook 模型的区别#\n\n上面这部分就是 Pipeline 整体的一个工作模式的描述，其他的 Hook 模型的工作模式基本也是这样，主要的区别点，是函数类型、执行顺序，参数。\n\n\nPipeline#\n\n上面的例子就是以 Pipeline 为例描述的，这里就不赘述了，在 Pipeline 这个大类中，提供了两个小类：Sync 和\nAsync，顾名思义，它们的区别就是管理的函数的类型是 Sync 的还是 Async 的。\n\nINFO\n\n当 Pipeline 中没有函数或者所有函数都调用了 next 函数，则就需要在运行的时候提供：\n\npipeline(\n  {},\n  {\n    onLast: () => {\n      // do something\n    },\n  },\n);\n\n\n\nWaterfall#\n\n这种模型顾名思义，他的特点就是参数的顺序递交，即前面一个函数的返回值，将会成为下一个函数的入参，我们也用一个例子来看一下：\n\n\n\n// 1. 创建\nconst waterfall = createWaterfall();\n\n// 2. 添加函数\nwaterfall.use(count => {\n  return count + 1;\n});\nwaterfall.use(count => {\n  return count * 2;\n});\n\n// 3. 执行\nwaterfall.run(1); // 4\nwaterfall.run(5); // 12\n\n\n这个例子中，创建了一个类型为 Waterfall ，即这个模型执行的入参和返回值是一样的，这个例子中都是 number，而它管理的函数的类型是：\n\n(count: number) => number;\n\n\n可能简单看这个例子感觉和上面的 Pipeline 功能一样，那需要注意的是，首先这里 Waterfall 管理的函数没有 next\n函数作为第二个参数，所以它无法在函数内部通过调用 next 来先运行之后添加的函数，从而修改运行的顺序，其次这里的运行的入参的类型和返回值的类型必须是一样的（而\nPipeline 可以不一样）。\n\n同样的，在 Waterfall 这个大类中，也提供了 Sync 和 Async 的小类，分别对应 Sync 和 Async 的函数。\n\n\nWorkflow#\n\n这种 Hook 模型与上面两种 Hook\n模型的区别是，没有那么强的前后参数返回值递交的概念，在这个模型中，每个函数都是基于同样的入参，相对独立运行的，通过一个例子简单看一下：\n\n\n\n// 1. 创建\nconst workflow = createWorkflow();\n\n// 2. 添加函数\nworkflow.use(count => {\n  return count + 1;\n});\nworkflow.use(count => {\n  return count * 2;\n});\n\n// 3. 执行\nworkflow.run(1); // [2, 2]\nworkflow.run(5); // [6, 10]\n\n\n在这个例子中，添加了两个函数，所以运行的结果就是这两个函数运行的结果形成的一个数组。\n\n虽然这种模型中没有那么强的前后参数返回值递交的概念，但依旧有执行顺序的区别，在 Workflow\n这个大类中，提供了三个小类：Sync、Async、Parallel。他们之间的区别就是函数的执行顺序，当然默认的都是按照添加顺序执行，而在 Sync、Async\n则是强制按照添加顺序执行，而 Parallel 则是 Async 模式的一个变体，即它使用的是 Promise.all 来执行所有函数，而 Async 则会\nawait 前面的函数运行结束。\n\n\nHook 模型对比#\n\nWorkflow、Waterfall 其实都是 Pipeline 的变体，Pipeline 可以通过特定的写法来实现\nWorkflow、Waterfall，但都较为麻烦，有许多隐形的约定。为了方便使用，提供了这两种变体来满足这种特殊场景。","frontmatter":{"title":"Hook 模型","sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/framework-plugin/hook.mdx","_relativePath":"zh/guides/topic-detail/framework-plugin/hook.mdx"},{"id":540,"title":"如何编写插件","routePath":"/guides/topic-detail/framework-plugin/implement","lang":"zh","toc":[{"text":"实现插件","id":"实现插件","depth":2,"charIndex":48},{"text":"插件类型","id":"插件类型","depth":3,"charIndex":422},{"text":"插件配置项","id":"插件配置项","depth":3,"charIndex":1476},{"text":"插件 API","id":"插件-api","depth":3,"charIndex":1699},{"text":"异步 setup","id":"异步-setup","depth":3,"charIndex":2083},{"text":"添加插件","id":"添加插件","depth":2,"charIndex":2251},{"text":"开发本地插件","id":"开发本地插件","depth":3,"charIndex":2318},{"text":"在 npm 上发布插件","id":"在-npm-上发布插件","depth":3,"charIndex":2570}],"domain":"","content":"#\n\n上一小节介绍了 Modern.js 插件的 Hook 模型，这一小节介绍如何编写插件。\n\n\n实现插件#\n\nModern.js 插件是一个对象，对象包含以下属性：\n\n * name: 插件的名称，唯一标识符。\n * setup: 插件初始化函数，只会执行一次。setup 函数可以返回一个 Hooks 对象，Modern.js 会在特定的时机执行这些 Hooks。\n\nconst myPlugin = {\n  name: 'my-plugin',\n\n  setup() {\n    // 执行一些初始化逻辑\n    const foo = '1';\n\n    // 返回一个 Hooks 对象\n    return {\n      afterBuild: () => {\n        // 在构建完成后执行逻辑\n      },\n    };\n  },\n};\n\n\n另外，在插件中，允许配置与其他插件的执行顺序。详情可以参考插件关系。\n\n\n插件类型#\n\nModern-js 支持多种工程开发，如应用工程(app-tools), 模块工程(module-tools)等。\n\n为了兼顾不同工程开发的差异和通性，Modern-js 将插件如下图进行组织:\n\n\n\n从图可以看出，Modern-js 将插件大致分为两类:\n\n 1. 通用插件: 插件只会包含一些基础的 Hooks\n\n 2. 工程插件: 不同的工程开发会在通用插件的基础上扩展出自己的 Hooks, Config 等类型。\n\n使用 TypeScript 时，可以引入内置的 CliPlugin 等类型，为插件提供正确的类型推导。\n\n\n\nconst myPlugin: CliPlugin = {\n  name: 'my-plugin',\n\n  setup() {\n    const foo = '1';\n\n    return {\n      afterBuild: () => {\n        // 在构建完成后执行逻辑\n      },\n    };\n  },\n};\n\n\n上述代码为通用插件，只包含一些基础的 Hooks。 Modern.js 支持通过泛型对插件的定义进行扩展：\n\n\n\nconst myPlugin: CliPlugin = {\n  name: 'my-plugin',\n\n  setup() {\n    const foo = '1';\n\n    return {\n      afterBuild: () => {\n        // 在构建完成后执行逻辑\n      },\n    };\n  },\n};\n\n\n如果仔细观察 AppTools 这个类型，可以发现 AppTools 由 3 种类型构成.\n\ntype AppTools = {\n  hooks: AppToolsHooks;\n  userConfig: AppToolsUserConfig;\n  normalizedConfig: AppToolsNormalizedConfig;\n};\n\n\n当编写插件时，插件通过泛型扩展在不同的基础上扩展自己的 Hooks 等类型:\n\n// 通用插件上扩展\n\n\n\nconst myPlugin: CliPlugin<{ hooks: MyPluginHook }> = {};\n\n\n// 在 @modern-js/app-tools 基础上扩展\n\n\n\nconst myPlugin: CliPlugin = {};\n\n\n详细说明，请参考 扩展 Hook。\n\n\n插件配置项#\n\n建议将插件写成函数的形式，使插件能通过函数入参来接收配置项：\n\n\n\ntype MyPluginOptions = {\n  foo: string;\n};\n\nconst myPlugin = (options: MyPluginOptions): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup() {\n    console.log(options.foo);\n  },\n});\n\n\n\n插件 API#\n\n插件的 setup 函数会接收一个 api 入参，你可以调用 api 上提供的一些方法来获取到配置、应用上下文等信息。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup(api) {\n    // 获取应用原始配置\n    const config = api.useConfigContext();\n    // 获取应用运行上下文\n    const appContext = api.useAppContext();\n    // 获取解析之后的最终配置\n    const resolvedConfig = api.useResolvedConfigContext();\n  },\n});\n\n\n插件 API 的详细说明，请参考 Plugin API。\n\n\n异步 setup#\n\nCLI 插件的 setup 可以是一个异步函数，在初始化过程中执行异步逻辑。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  async setup(api) {\n    await doSomething();\n  },\n});\n\n\n\n添加插件#\n\n自定义插件的使用方式可以查看：plugins (框架插件)。下面会介绍 Modern.js 中推荐的插件实现方法。\n\n\n开发本地插件#\n\n本地插件推荐写在 config/plugin 目录下，并通过 export default 导出：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup() {\n    // 插件初始化\n  },\n});\n\n\n然后在 modern.config.ts 中注册对应的插件：\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n\n在 npm 上发布插件#\n\n如果需要将 Modern.js 插件发布到 npm，推荐使用 Modern.js 中的模块工程方案来管理和构建。\n\n首先创建一个空的模块工程方案项目，调整 npm 包名称：\n\n{\n  \"name\": \"my-plugin\"\n  ...\n}\n\n\n然后新建对应的插件文件：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup() {\n    // 插件初始化\n  },\n});\n\n\n发布之后，安装到需要使用的项目 pnpm add my-plugin，这里以一个应用项目为例，然后在 modern.config.ts 中添加：\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n如果你发现目前 Modern.js 存在无法满足的场景，欢迎通过编写自定义插件的方式来一起建设 Modern.js 生态。","frontmatter":{"title":"如何编写插件","sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/framework-plugin/implement.mdx","_relativePath":"zh/guides/topic-detail/framework-plugin/implement.mdx"},{"id":541,"title":"介绍","routePath":"/guides/topic-detail/framework-plugin/introduction","lang":"zh","toc":[{"text":"Modern.js 插件系统","id":"modernjs-插件系统","depth":2,"charIndex":3},{"text":"插件可以做什么","id":"插件可以做什么","depth":2,"charIndex":544}],"domain":"","content":"#\n\n\nModern.js 插件系统#\n\nModern.js 用于扩展项目运行、请求、渲染等不同阶段功能的系统，主要分为三个部分：Hook 模型、管理器，上下文共享机制。\n\nHook 模型用于确定当前 Hook 的执行方式，不同 Hook 模型的函数拥有不同的执行逻辑。管理器用于控制 Hook 的执行与调度。上下文共享机制用于在不同\nHook 间传递信息。\n\n目前 Modern.js 提供几种不同的 Hook 模型：\n\n * Pipeline\n   * Sync\n   * Async\n * Waterfall\n   * Sync\n   * Async\n * Workflow\n   * Sync\n   * Async\n   * Parallel(Async)\n\nNOTE\n\n后续章节详细介绍各个模型的执行方式。\n\n基于 Hook 模型和管理器，Modern.js 暴露了三套插件：CLI、Runtime、Server。\n\n其中 CLI 插件是 Modern.js 中主要的运行流程控制模型，Modern.js 中绝大部分功能都是主要通过这一套模型运行的。Runtime\n插件主要负责处理 React 组件渲染逻辑。Server 插件主要用于对服务端的生命周期以及用户请求的控制。\n\n\n插件可以做什么#\n\nModern.js 的所有功能都是通过这套插件实现的，这意味着 Modern.js\n中的所有能力是都对开发者开放的。开发者可以通过编写插件来扩展更多功能，适配复杂场景，包括但不限于：\n\n * 注册命令\n * 修改 Modern.js 配置、配置校验 Schema\n * 修改编译时的 Webpack/Babel/Less/Sass/Tailwind CSS/... 配置\n * 修改运行时需要渲染的 React 组件、Element\n * 修改页面路由\n * 修改服务器路由\n * 自定义控制台输出\n * 自定义动态 HTML 模版\n * 自定义 Node.js 服务器框架\n * 自定义 React 组件客户端/服务器端渲染\n * ...\n\n当 Modern.js 暂时没有覆盖到你所需要的功能或场景时，可以开发一个自定义插件，来实现适配特殊场景的相关功能。","frontmatter":{"title":"介绍","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/framework-plugin/introduction.mdx","_relativePath":"zh/guides/topic-detail/framework-plugin/introduction.mdx"},{"id":542,"title":"生命周期","routePath":"/guides/topic-detail/framework-plugin/lifecycle","lang":"zh","toc":[],"domain":"","content":"#\n\nModern.js 应用具有完整的生命周期，包括 CLI、Server Side 和 Runtime 三个阶段。\n\n目前 Modern.js 大致的生命周期如下：\n\nNOTE\n\n其中粉色框的矩形代表 Modern.js 提供的插件钩子，淡黄色底色椭圆代表与下一个阶段的连接点。\n\n","frontmatter":{"title":"生命周期","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/framework-plugin/lifecycle.mdx","_relativePath":"zh/guides/topic-detail/framework-plugin/lifecycle.mdx"},{"id":543,"title":"插件 API","routePath":"/guides/topic-detail/framework-plugin/plugin-api","lang":"zh","toc":[{"text":"API","id":"api","depth":2,"charIndex":347},{"text":"useConfigContext","id":"useconfigcontext","depth":3,"charIndex":354},{"text":"useResolvedConfigContext","id":"useresolvedconfigcontext","depth":3,"charIndex":646},{"text":"useAppContext","id":"useappcontext","depth":3,"charIndex":1039},{"text":"useHookRunners","id":"usehookrunners","depth":3,"charIndex":1530}],"domain":"","content":"#\n\n插件的 setup 函数会接收一个 api 入参，你可以调用 api 上提供的一些方法来获取到配置、应用上下文等信息。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup(api) {\n    // 获取应用原始配置\n    const config = api.useConfigContext();\n    // 获取应用运行上下文\n    const appContext = api.useAppContext();\n    // 获取解析之后的最终配置\n    const resolvedConfig = api.useResolvedConfigContext();\n  },\n});\n\n\n\nAPI#\n\n\nuseConfigContext#\n\n用于获取应用原始配置。\n\nconst useConfigContext: () => UserConfig;\n\ninterface UserConfig {\n  source?: SourceConfig;\n  output?: OutputConfig;\n  server?: ServerConfig;\n  deploy?: DeployConfig;\n  // ...other fields\n}\n\n\n具体配置字段的意义请参考 配置。\n\nTIP\n\n该方法获取到的是只读配置，不可修改。如果需要修改配置，请使用 config hook。\n\n\nuseResolvedConfigContext#\n\n用于获取被解析、合并之后的最终配置。\n\nconst useResolvedConfigContext: () => NormalizedConfig;\n\ninterface NormalizedConfig {\n  source: NormalizedSourceConfig;\n  output: NormalizedOutputConfig;\n  server: NormalizedServerConfig;\n  deploy: NormalizedDeployConfig;\n  _raw: UserConfig; // 原始配置对象\n  // ...other fields\n}\n\n\n配置字段的完整内容请参考 配置。\n\nTIP\n\n该方法获取到的是只读配置，不可修改。如果需要修改配置，请使用 config hook。\n\n\nuseAppContext#\n\n用于获取应用运行上下文。\n\nconst useAppContext: () => IAppContext;\n\ninterface IAppContext {\n  appDirectory: string;\n  configFile: string | false;\n  ip?: string;\n  port?: number;\n  distDirectory: string;\n  packageName: string;\n  srcDirectory: string;\n  sharedDirectory: string;\n  nodeModulesDirectory: string;\n  internalDirectory: string;\n  plugins: {\n    cli?: any;\n    server?: any;\n  }[];\n  entrypoints: Entrypoint[];\n  serverRoutes: ServerRoute[];\n  htmlTemplates: HtmlTemplates;\n}\n\n\n\nuseHookRunners#\n\n用于获取 Hooks 的执行器，并触发特定的 Hook 执行。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  async setup(api) {\n    const hookRunners = api.useHookRunners();\n    // 触发 afterBuild Hook\n    await hookRunners.afterBuild();\n  },\n});\n","frontmatter":{"title":"插件 API","sidebar_position":6},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/framework-plugin/plugin-api.mdx","_relativePath":"zh/guides/topic-detail/framework-plugin/plugin-api.mdx"},{"id":544,"title":"插件之间的关系","routePath":"/guides/topic-detail/framework-plugin/relationship","lang":"zh","toc":[{"text":"插件排序","id":"插件排序","depth":2,"charIndex":300},{"text":"前置插件","id":"前置插件","depth":3,"charIndex":349},{"text":"后置插件","id":"后置插件","depth":3,"charIndex":570},{"text":"互斥插件","id":"互斥插件","depth":2,"charIndex":766},{"text":"必需插件","id":"必需插件","depth":2,"charIndex":977},{"text":"注册插件","id":"注册插件","depth":2,"charIndex":1197}],"domain":"","content":"#\n\nModern.js 的插件配置对象提供了一系列的字段，用于控制插件顺序、互斥等能力，可用的字段如下：\n\n * name: string，设置当前插件的名称。\n * pre: string[]，这些插件最终会调整到当前插件前面。\n * post: string[]，这些插件最终会调整到当前插件后面。\n * rivals: string[]，互斥插件，遇到这些插件时会报错。\n * required: string[]，必需插件，插件列表中没有对应的插件时会报错。\n * usePlugin: CliPlugin[]，注册其他插件。\n\n通过以上参数可以实现插件的前置、后置、互斥、必需等逻辑。\n\n\n插件排序#\n\nModern.js 的插件通过 pre、post 参数来实现了插件排序的功能。\n\n\n前置插件#\n\n默认情况下，插件会按照添加顺序依次执行，通过 pre 字段可以声明前置执行的插件。\n\n比如有下面两个插件：\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  pre: ['plugin-foo'],\n};\n\n\nbar 插件在 pre 字段中配置了 foo 插件，因此 foo 插件一定会在 bar 插件之前执行。\n\n\n后置插件#\n\n同样的，通过 post 字段可以声明后置执行的插件。\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  post: ['plugin-foo'],\n};\n\n\nbar 插件在 post 字段中配置了 foo 插件，因此 foo 插件一定会在 bar 插件之后执行。\n\n\n互斥插件#\n\n通过 rivals 字段可以声明插件间的互斥关系。\n\n有下面两个插件：\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  rivals: ['plugin-foo'],\n};\n\n\nbar 插件在 rivals 字段中配置了 foo 插件，因此同时添加了 foo 插件和 bar 插件就会报错。\n\n\n必需插件#\n\n通过 required 字段可以声明插件间的依赖关系。\n\n有下面两个插件：\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  required: ['plugin-foo'],\n};\n\n\nbar 插件在 required 字段中配置了 foo 插件，因此使用 bar 插件时，如果未配置 foo 插件就会报错。\n\n\n注册插件#\n\n当插件之间存在依赖关系时，我们也可以在一个插件中通过 usePlugin 主动注册另一个插件：\n\nconst foo = () => ({\n  name: 'plugin-foo',\n});\n\nconst bar = () => ({\n  name: 'plugin-bar',\n  usePlugin: [foo()],\n});\n\n\n当使用者配置了 bar 插件时，foo 插件也会自动注册生效，使用者就不需要去额外注册 foo 插件了。","frontmatter":{"title":"插件之间的关系","sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/framework-plugin/relationship.mdx","_relativePath":"zh/guides/topic-detail/framework-plugin/relationship.mdx"},{"id":545,"title":"配置参数","routePath":"/guides/topic-detail/generator/create/config","lang":"zh","toc":[{"text":"通用配置","id":"通用配置","depth":2,"charIndex":93},{"text":"solution","id":"solution","depth":3,"charIndex":101},{"text":"scenes","id":"scenes","depth":3,"charIndex":214},{"text":"Web 应用","id":"web-应用","depth":2,"charIndex":263},{"text":"language","id":"language","depth":3,"charIndex":273},{"text":"packageManager","id":"packagemanager","depth":3,"charIndex":330},{"text":"buildTools","id":"buildtools","depth":3,"charIndex":415},{"text":"Npm 模块","id":"npm-模块","depth":2,"charIndex":490},{"text":"packageName","id":"packagename","depth":3,"charIndex":500},{"text":"文档站","id":"文档站","depth":2,"charIndex":578},{"text":"Monorepo","id":"monorepo","depth":2,"charIndex":-1}],"domain":"","content":"#\n\n@modern-js/create 提供了 --config 参数，用于提前指定执行过程中交互问题的答案。\n\n这里将介绍不同情况下，可以在 config 中配置的字段及字段值。\n\n\n通用配置#\n\n\nsolution#\n\n问题：请选择你想创建的工程类型\n\n选项：\n\n * Web 应用 -- mwa\n\n * Npm 模块 -- module\n\n * 文档站 -- doc\n\n * Monorepo -- monorepo\n\n\nscenes#\n\n问题：请选择项目场景\n\n选项：\n\n使用自定义生成器插件时的插件关键字列表。\n\n\nWeb 应用#\n\n\nlanguage#\n\n问题：请选择开发语言\n\n选项：\n\n * TS -- ts\n\n * ES6+ -- js\n\n\npackageManager#\n\n问题：请选择包管理工具\n\n选项：\n\n * pnpm -- pnpm\n\n * Yarn -- yarn\n\n * npm -- npm\n\n\nbuildTools#\n\n问题：请选择构建工具\n\n选项：\n\n * webpack -- webpack\n\n * Rspack -- rspack\n\n\nNpm 模块#\n\n\npackageName#\n\n问题：请填写项目名称\n\nINFO\n\nNpm 模块的 package.json 的 name 字段值，该配置值为字符串类型。\n\n\n文档站#\n\n\nMonorepo#","frontmatter":{"sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/create/config.mdx","_relativePath":"zh/guides/topic-detail/generator/create/config.mdx"},{"id":546,"title":"CLI 参数","routePath":"/guides/topic-detail/generator/create/option","lang":"zh","toc":[{"text":"[projectDir]","id":"[projectdir]","depth":2,"charIndex":991},{"text":"--version","id":"--version","depth":2,"charIndex":1164},{"text":"--lang <lang>","id":"--lang-<lang>","depth":2,"charIndex":-1},{"text":"-c, --config <config>","id":"-c,---config-<config>","depth":2,"charIndex":-1},{"text":"-d,--debug","id":"-d,--debug","depth":2,"charIndex":1612},{"text":"--mwa","id":"--mwa","depth":2,"charIndex":1683},{"text":"--module","id":"--module","depth":2,"charIndex":1708},{"text":"--monorepo","id":"--monorepo","depth":2,"charIndex":1736},{"text":"-p, --plugin <plugin>","id":"-p,---plugin-<plugin>","depth":2,"charIndex":-1},{"text":"--generator <generator>","id":"--generator-<generator>","depth":2,"charIndex":-1},{"text":"--dist-tag <distTag>","id":"--dist-tag-<disttag>","depth":2,"charIndex":-1},{"text":"--packages <packages>","id":"--packages-<packages>","depth":2,"charIndex":-1},{"text":"--registry <registry>","id":"--registry-<registry>","depth":2,"charIndex":-1},{"text":"--no-need-install","id":"--no-need-install","depth":2,"charIndex":2423},{"text":"clean-cache","id":"clean-cache","depth":2,"charIndex":2513}],"domain":"","content":"#\n\n@modern-js/create 提供了很多配置参数用于配置其执行过程中的行为，可以通过 --help 参数进行查看：\n\nnpx @modern-js/create@latest --help\n\nUsage: npx @modern-js/create@latest [projectDir]\n\n创建 Modern.js 工程方案\n\nOptions:\n  --version                当前 create 工具版本号\n  --lang             设置 create 工具语言(zh 或者 en)\n  -c, --config     创建项目默认配置(JSON 字符串) (default: \"{}\")\n  -d,--debug               开启 Debug 模式，打印调试日志信息 (default: false)\n  --mwa                    一键创建 Web 应用(使用默认配置) (default: false)\n  --module                 一键创建 Module 应用(使用默认配置) (default: false)\n  --monorepo               一键创建 Monorepo 应用(使用默认配置) (default: false)\n  --generator   使用自定义生成器\n  -p, --plugin     使用生成器插件创建新的工程方案类型或定制化 Modern.js 工程方案 (default: [])\n  --dist-tag      生成项目时生成器使用特殊的 npm Tag (default: \"\")\n  --packages     创建项目指定特定依赖版本信息 (default: \"{}\")\n  --registry     在创建过程中定制 npm Registry (default: \"\")\n  --no-need-install        无需安装依赖\n  -h, --help               display help for command\n\nCommands:\n  clean-cache              清除本地生成器缓存\n\n\n下面将针对这些参数做详细介绍：\n\n\n[projectDir]#\n\n项目目录名称。\n\n执行 @modern-js/create 时，默认会在当前目录创建 projectDir\n文件夹，并在该文件夹下初始化项目。该参数为空时，将会在当前目录直接生成初始化项目。\n\nINFO\n\n如果 projectDir 所在目录内容不为空，将会提示是否继续创建，推荐在空目录下进行项目初始化操作。\n\n\n--version#\n\n获取 @modern-js/create 工具版本。\n\nnpx @modern-js/create@latest --version\n\n[INFO] @modern-js/create v2.21.1\n\n\n\n--lang #\n\n执行执行语言，支持 zh 和 en。\n\n默认情况下，@modern-js/create 会自动识别用户的系统语言，选择使用中文或者英文，如果识别失败或者不符合使用习惯，可以使用该参数手动指定。\n\n\n-c, --config #\n\n指定项目默认配置。\n\n默认情况下，@modern-js/create 在执行过程中会出现选择语言、包管理工具等交互问题，当需要提前指定这些配置内容时，可以通过该字段传入。\n\n该字段为 JSON 字符串，例如需指定包管理工具时：\n\nnpx @modern-js/create@latest --config '{\"packageManager\": \"pnpm\"}'\n\n\nconfig 支持的参数可查看配置参数。\n\n\n-d,--debug#\n\n展示调试日志。\n\n当在使用过程中遇到问题时，可以使用该参数显示调试日志，方便快速定位问题位置及对问题进行排查。\n\n\n--mwa#\n\n快速创建 Web 应用项目。\n\n\n--module#\n\n快速创建 Npm 模块项目。\n\n\n--monorepo#\n\n快速创建 Monorepo 项目。\n\n\n-p, --plugin #\n\n指定生成器插件。\n\n@modern-js/create 支持使用生成器插件定制 Modern.js 默认的工程方案类型或者添加工程方案类型场景，详情可查看开发生成器插件。\n\n\n--generator #\n\n指定微生成器。\n\n@modern-js/create 支持使用微生成器完全定制项目生成流程。\n\n\n--dist-tag #\n\n指定生成器及 Modern.js 相关依赖版本。\n\n@modern-js/create 执行过程中会执行更小的微生成器，默认会使用 latest\n的微生成器版本，使用该参数可以指定执行的微生成器的版本号和对应的安装 Modern.js 相关依赖的版本。\n\n比如使用 next 版本：\n\nnpx @modern-js/create@next --dist-tag next\n\n\n\n--packages #\n\n创建项目是指定特定包版本依赖。\n\n在创建项目时如果有需要指定特定包版本，可以使用该参数。该参数会在项目根目录的 package.json 中配置 pnpm.overrides(包管理工具选择\npnpm) 或者 resolutions 锁定包版本号。\n\n该参数值为 JSON 字符串。\n\n例如指定 react 版本：\n\nnpx @modern-js/create@latest --packages '{\"react\":\"^17\"}'\n\n\n\n--registry #\n\n指定执行子生成器和获取项目依赖版本的 npm registry。\n\n\n--no-need-install#\n\n忽略自动安装依赖。\n\n默认情况下，@modern-js/create 在创建项目完成后会自动安装依赖，使用该参数可以忽略安装依赖步骤。\n\n\nclean-cache#\n\n@modern-js/create 默认会在执行机器的 tmp\n目录生成子生成器缓存用于加快生成器执行速度，在需要刷新缓存或者缓存出现问题时可以使用该命令删除缓存。\n\nnpx @modern-js/create@latest clean-cache\n","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/create/option.md","_relativePath":"zh/guides/topic-detail/generator/create/option.md"},{"id":547,"title":"使用","routePath":"/guides/topic-detail/generator/create/use","lang":"zh","toc":[{"text":"环境准备","id":"环境准备","depth":2,"charIndex":128},{"text":"Node.js","id":"nodejs","depth":3,"charIndex":136},{"text":"pnpm","id":"pnpm","depth":3,"charIndex":688},{"text":"使用 @modern-js/create 创建项目","id":"使用-@modern-js/create-创建项目","depth":2,"charIndex":779},{"text":"创建 Web 应用项目","id":"创建-web-应用项目","depth":3,"charIndex":966},{"text":"创建 Npm 模块项目","id":"创建-npm-模块项目","depth":3,"charIndex":1089},{"text":"创建文档站项目","id":"创建文档站项目","depth":3,"charIndex":1218},{"text":"创建 Monorepo","id":"创建-monorepo","depth":3,"charIndex":1307}],"domain":"","content":"#\n\nModern.js 提供了 @modern-js/create 工具用于创建 Modern.js 提供的工程方案项目，例如 Web 应用、Npm\n模块、文档站、Monorepo 等。\n\n下面将介绍 @modern-js/create 的使用姿势。\n\n\n环境准备#\n\n\nNode.js#\n\n在开始使用前，你需要安装 Node.js，并保证 Node.js 版本不低于 14.17.6，我们推荐使用 Node.js 16 的 LTS 版本。\n\n你可以通过以下命令检查当前使用的 Node.js 版本：\n\nnode -v\n# v16.19.1\n\n\n如果你当前的环境中尚未安装 Node.js，或是安装的版本低于 14.17.6，可以通过 nvm 或 fnm 安装需要的版本。\n\n下面是通过 nvm 安装 Node.js 16 LTS 版本的例子：\n\n# 安装 Node.js 16 的长期支持版本\nnvm install 16 --lts\n\n# 将刚安装的 Node.js 16 设置为默认版本\nnvm alias default 16\n\n# 切换到刚安装的 Node.js 16\nnvm use 16\n\n\nnvm 和 fnm\n\nnvm 和 fnm 都是 Node.js 版本管理工具。相对来说，nvm 较为成熟和稳定，而 fnm 是使用 Rust 实现的，比 nvm 提供了更好的性能。\n\n此外，在安装 nvm 或 fnm 后，然后只要仓库根目录下有内容为 lts/gallium 的 .nvmrc 文件，进入这个仓库时就会自动安装或切换到正确的\nNode.js 版本。\n\n\npnpm#\n\n推荐使用 pnpm 来管理依赖：\n\nnpm install -g pnpm@7\n\n\nNOTE\n\nModern.js 同样支持使用 yarn、npm 进行依赖管理。\n\n\n使用 @modern-js/create 创建项目#\n\n不需要全局安装 @modern-js/create，直接使用 npx 执行即可：\n\nnpx @modern-js/create@latest [projectDir]\n\n\nINFO\n\n[projectDir] 为项目目录名称，不填写将会在当前目录创建项目。\n\n执行过程中需要根据提示完成交互，创建符合需求的项目。\n\n\n创建 Web 应用项目#\n\nnpx @modern-js/create@latest web-app\n? 请选择你想创建的工程类型 Web 应用\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n? 请选择构建工具 webpack\n\n\n\n创建 Npm 模块项目#\n\nnpx @modern-js/create@latest npm-module\n? 请选择你想创建的工程类型 Npm 模块\n? 请填写项目名称 npm-module\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n\n\n\n创建文档站项目#\n\nnpx @modern-js/create@latest doc-website\n? 请选择你想创建的工程类型 文档站\n? 请选择包管理工具 pnpm\n\n\n\n创建 Monorepo#\n\nnpx @modern-js/create@latest monorepo\n? 请选择你想创建的工程类型 Monorepo\n? 请选择包管理工具 pnpm\n","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/create/use.mdx","_relativePath":"zh/guides/topic-detail/generator/create/use.mdx"},{"id":548,"title":"配置参数","routePath":"/guides/topic-detail/generator/new/config","lang":"zh","toc":[{"text":"通用配置","id":"通用配置","depth":2,"charIndex":81},{"text":"actionType","id":"actiontype","depth":3,"charIndex":89},{"text":"Web 应用","id":"web-应用","depth":2,"charIndex":188},{"text":"element","id":"element","depth":3,"charIndex":198},{"text":"name","id":"name","depth":3,"charIndex":287},{"text":"function","id":"function","depth":3,"charIndex":340},{"text":"bffType","id":"bfftype","depth":3,"charIndex":677},{"text":"framework","id":"framework","depth":3,"charIndex":771},{"text":"refactor","id":"refactor","depth":3,"charIndex":864},{"text":"Npm 模块","id":"npm-模块","depth":2,"charIndex":934},{"text":"function","id":"function-1","depth":3,"charIndex":944},{"text":"Monorepo","id":"monorepo","depth":2,"charIndex":1108},{"text":"sub_solution","id":"sub_solution","depth":3,"charIndex":1120},{"text":"packageName","id":"packagename","depth":3,"charIndex":1253},{"text":"packagePath","id":"packagepath","depth":3,"charIndex":1329}],"domain":"","content":"#\n\nnew 命令提供了 --config 参数，用于提前指定执行过程中交互问题的答案。\n\n这里将介绍不同情况下，可以在 config 中配置的字段及字段值。\n\n\n通用配置#\n\n\nactionType#\n\n问题：请选择你想要的操作\n\n选项：\n\n * 创建工程元素 -- element\n\n * 启用可选功能 -- function\n\n * 自动重构 -- refactor\n\n\nWeb 应用#\n\n\nelement#\n\n问题：请选择创建元素类型\n\n选项：\n\n * 新建「应用入口」 -- entry\n\n * 新建「自定义 Web Server」源码目录 -- server\n\n\nname#\n\n问题： 请填写入口名称\n\nINFO\n\n新建应用入口时需要该配置，该配置值为字符串类型。\n\n\nfunction#\n\n问题：请选择功能名称\n\n选项：\n\n * 启用「Rspack 构建」 -- rspack\n\n * 启用 「Tailwind CSS」 支持 -- tailwindcss\n\n * 启用「BFF」功能 -- bff\n\n * 启用「SSG」功能 -- ssg\n\n * 启用「SWC 编译」-- swc\n\n * 启用「微前端」模式 -- micro_frontend\n\n * 启用「单元测试 / 集成测试」功能 -- test\n\n * 启用「基于 UA 的 Polyfill」功能 -- polyfill\n\n * 启用「全局代理」 -- proxy\n\n * 启用「Visual Testing (Storybook)」模式 -- mwa_storybook\n\n\nbffType#\n\n问题：请选择 BFF 类型\n\n选项：\n\n * 函数模式 -- func\n\n * 框架模式 -- framework\n\nINFO\n\n启用 BFF 功能时需要该配置。\n\n\nframework#\n\n问题：请选择运行时框架\n\n选项：\n\n * Express -- express\n\n * Koa -- koa\n\nINFO\n\n启用 BFF 功能时需要该配置。\n\n\nrefactor#\n\n问题：请选择重构类型\n\n选项：\n\n * 使用 React Router v5 -- react_router_5\n\n\nNpm 模块#\n\n\nfunction#\n\n问题：启用可选功能\n\n选项：\n\n * 启用「单元测试 / 集成测试」功能 -- test\n\n * 启用 「Tailwind CSS」 支持 -- tailwindcss\n\n * 启用「Storybook」 -- storybook\n\n * 启用「Runtime API」 -- runtime_api\n\n\nMonorepo#\n\n\nsub_solution#\n\n问题：请选择你想创建的工程类型\n\n选项：\n\n * Web 应用 -- mwa\n\n * Web 应用（测试）-- mwa_test\n\n * Npm 模块 -- module\n\n * Npm 模块（内部）-- inner_module\n\n\npackageName#\n\n问题：请填写子项目名称\n\nINFO\n\n子项目的 package.json 的 name 字段值，该配置值为字符串类型。\n\n\npackagePath#\n\n问题：请填写子项目目录名称\n\nINFO\n\n子项目基于 apps 或者 packages 目录的子目录名称，该字段为字符串类型。","frontmatter":{"sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/new/config.md","_relativePath":"zh/guides/topic-detail/generator/new/config.md"},{"id":549,"title":"CLI 参数","routePath":"/guides/topic-detail/generator/new/option","lang":"zh","toc":[{"text":"--lang <lang>","id":"--lang-<lang>","depth":2,"charIndex":-1},{"text":"-c, --config <config>","id":"-c,---config-<config>","depth":2,"charIndex":-1},{"text":"-d,--debug","id":"-d,--debug","depth":2,"charIndex":702},{"text":"--registry <registry>","id":"--registry-<registry>","depth":2,"charIndex":-1},{"text":"--dist-tag <distTag>","id":"--dist-tag-<disttag>","depth":2,"charIndex":-1}],"domain":"","content":"#\n\nnew 命令提供了很多配置参数用于配置其执行过程中的行为，可以通过 --help 参数进行查看：\n\nnpm run new --help\n\nUsage: modern new [options]\n\n启用可选功能\n\nOptions:\n  --lang           设置 new 命令执行语言(zh 或者 en)\n  -c, --config   生成器运行默认配置(JSON 字符串)\n  -d, --debug            开启 Debug 模式，打印调试日志信息 (default: false)\n  --dist-tag        生成器使用特殊的 npm Tag 版本\n  --registry   生成器运行过程中定制 npm Registry\n  -h, --help             display help for command\n\n\n下面将针对这些参数做详细介绍：\n\n\n--lang #\n\n执行执行语言，支持 zh 和 en。\n\n默认情况下，new 命令会自动识别用户的系统语言，选择使用中文或者英文，如果识别失败或者不符合使用习惯，可以使用该参数手动指定。\n\n\n-c, --config #\n\n指定项目默认配置。\n\n默认情况下，new 命令在执行过程中会出现选择操作类型、开启功能等交互问题，当需要提前指定这些配置内容时，可以通过该字段传入。\n\n该字段为 JSON 字符串，例如需指定 BFF 框架时：\n\nnpm run new --config '{\"framework\": \"express\"}'\n\n\nconfig 支持的参数可查看配置参数。\n\n\n-d,--debug#\n\n展示调试日志。\n\n当在使用过程中遇到问题时，可以使用该参数显示调试日志，方便快速定位问题位置及对问题进行排查。\n\n\n--registry #\n\n指定执行子生成器和获取项目依赖版本的 npm registry。\n\n\n--dist-tag #\n\n指定生成器版本。\n\nnew 命令执行过程中会执行更小的微生成器，默认会使用 latest 的微生成器版本，使用该参数可以指定执行的微生成器的版本号的版本。\n\n比如使用 next 版本：\n\nnpm run new --dist-tag next\n","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/new/option.md","_relativePath":"zh/guides/topic-detail/generator/new/option.md"},{"id":550,"title":"使用","routePath":"/guides/topic-detail/generator/new/use","lang":"zh","toc":[{"text":"Web 应用","id":"web-应用","depth":2,"charIndex":68},{"text":"Npm 模块","id":"npm-模块","depth":2,"charIndex":807},{"text":"Monorepo","id":"monorepo","depth":2,"charIndex":1069}],"domain":"","content":"#\n\n在 Web 应用、 Npm 模块和 Monorepo 项目中，我们提供了 new 命令用于创建项目元素、开启功能和创建子项目。\n\n\nWeb 应用#\n\nWeb 应用项目通过 @modern-js/app-tools 提供 new 命令。\n\nnew 命令提供了三种操作类型：\n\n * 创建工程元素\n\n * 启用可选功能\n\n * 自动重构\n\n每种操作类型都提供了对应支持的列表，可根据项目情况进行选择。\n\n例如：\n\n创建新的应用入口：\n\nnpm run new\n? 请选择你想要的操作 创建工程元素\n? 请选择创建元素类型 新建「应用入口」\n? 请填写入口名称 entry\n\n\n执行完成后将会在项目 src 目录创建新入口对应名称的文件夹及默认入口文件，并且自动帮忙整理之前 src 下入口文件到 package.json 中 name\n字段对应的文件夹中。\n\n开启 BFF 功能：\n\nnpm run new\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「BFF」功能\n? 请选择 BFF 类型 函数模式\n? 请选择运行时框架 Express\n\n\n执行完成后将会在项目安装 BFF 相关依赖，并创建 api 目录用于 BFF 模块的开发并提供提示信息用于注册 BFF 插件。\n\nINFO\n\n这里未帮助用户自动注册插件，原因是由于 modern.config.[tj]s\n在项目生命周期中变化比较复杂，可能存在模块之间互相引用问题，让用户手动注册能保证修改配置的正确性。\n\n在后续定制化的开发中，如果有类似的需求，也可以通过提示的方式给到使用方操作指南，让用户对文件进行手动操作。\n\nWARNING\n\n执行 new 命令时可能会出现需要开启的功能不在列表中，需要检查一下项目 package.json 中是否已经安装对应功能的插件，如果仍需使用 new\n命令开启，需要先手动移除对应的插件依赖。\n\n\nNpm 模块#\n\nNpm 模块项目通过 @modern-js/module-tools 提供 new 命令。\n\nnew 命令提供了启用可选功能的能力。\n\n例如：\n\n开启 Storybook 能力：\n\nnpm run new\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「Storybook」\n\n\n执行完成后将会在项目安装 Storybook 插件相关依赖，增加 storybook 命令，创建 stories 目录用于 Storybook\n模块的开发并提供提示信息用于注册 Storybook 插件。\n\n\nMonorepo#\n\nMonorepo 项目通过 @modern-js/monorepo-tools 提供 new 命令。\n\nnew 命令提供了创建子项目的能力。\n\n例如：\n\n创建 Web 应用子项目：\n\n? 请选择你想创建的工程类型 Web 应用\n? 请填写子项目名称 web_app\n? 请填写子项目目录名称 web_app\n? 请选择开发语言 TS\n? 请选择构建工具 webpack\n\n\n执行完成后将会在项目 apps 目录创建 web_app 的子项目，在子项目目录中依然可以执行 new 命令创建项目元素和开启功能。","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/new/use.md","_relativePath":"zh/guides/topic-detail/generator/new/use.md"},{"id":551,"title":"afterForged","routePath":"/guides/topic-detail/generator/plugin/api/afterForged","lang":"zh","toc":[{"text":"类型","id":"类型","depth":2,"charIndex":45},{"text":"API","id":"api","depth":2,"charIndex":416},{"text":"isInGitRepo","id":"isingitrepo","depth":3,"charIndex":447},{"text":"initGitRepo","id":"initgitrepo","depth":3,"charIndex":483},{"text":"gitAddAndCommit","id":"gitaddandcommit","depth":3,"charIndex":516},{"text":"install","id":"install","depth":3,"charIndex":581}],"domain":"","content":"#\n\nafterForged 为生成器插件中用于文件操作后其他步骤操作的生命周期函数。\n\n\n类型#\n\nexport type AfterForgedAPI = {\n  isInGitRepo: () => Promise;\n  initGitRepo: () => Promise;\n  gitAddAndCommit: (commitMessage: string) => Promise;\n  install: () => Promise;\n};\n\nexport type PluginAfterForgedFunc = (api: AfterForgedAPI, inputData: Record) => Promise;\n\nexport interface IPluginContext {\n   afterForged: (func: PluginAfterForgedFunc) => void;\n  ...\n}\n\n\n\nAPI#\n\n下面将分别介绍 api 参数提供的 API。\n\n\nisInGitRepo#\n\n判断当前项目是否为一个 Git 仓库。\n\n\ninitGitRepo#\n\n初始化当前项目为 Git 仓库。\n\n\ngitAddAndCommit#\n\n提交当前仓库变更。\n\n参数：\n\n * commitMessage: commit 信息。\n\n\ninstall#\n\n在项目根目录安装依赖。install 函数中将根据 packageManager 的值使用对应的包管理工具安装依赖。","frontmatter":{"sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/plugin/api/afterForged.md","_relativePath":"zh/guides/topic-detail/generator/plugin/api/afterForged.md"},{"id":552,"title":"context","routePath":"/guides/topic-detail/generator/plugin/api/context","lang":"zh","toc":[{"text":"类型","id":"类型","depth":2,"charIndex":77},{"text":"获取信息","id":"获取信息","depth":3,"charIndex":757},{"text":"locale","id":"locale","depth":4,"charIndex":764},{"text":"isFileExist","id":"isfileexist","depth":4,"charIndex":837},{"text":"readDir","id":"readdir","depth":4,"charIndex":1032},{"text":"input 操作","id":"input-操作","depth":3,"charIndex":1213},{"text":"addInputBefore","id":"addinputbefore","depth":4,"charIndex":1339},{"text":"addInputAfter","id":"addinputafter","depth":4,"charIndex":1639},{"text":"setInput","id":"setinput","depth":4,"charIndex":2166},{"text":"setInputValue","id":"setinputvalue","depth":4,"charIndex":2343},{"text":"setDefaultConfig","id":"setdefaultconfig","depth":4,"charIndex":2506},{"text":"setGitMessage","id":"setgitmessage","depth":4,"charIndex":2721},{"text":"生命周期函数","id":"生命周期函数","depth":3,"charIndex":2801}],"domain":"","content":"#\n\n生成器插件在 main 文件中默认导出了一个函数，函数参数为 context，生成器插件提供的所有 API 都是由这个 context 提供的。\n\n\n类型#\n\n我们先大概了解一下 context 的类型定义：\n\nexport interface IPluginContext {\n  locale?: string;\n  addInputBefore: (key: string, input: Schema) => void;\n  addInputAfter: (key: string, input: Schema) => void;\n  setInput: (key: string, field: string, value: unknown) => void;\n  setInputValue: (value: Record) => void;\n  setDefaultConfig: (value: Record) => void;\n  isFileExist: (fileName: string) => Promise;\n  readDir: (dir: string) => Promise;\n  setGitMessage: (gitMessage: string) => void;\n  onForged: (func: PluginForgedFunc) => void;\n  afterForged: (func: PluginAfterForgedFunc) => void;\n}\n\n\ncontext 提供的内容主要分为三类：\n\n * 获取当前生成器执行环境信息\n\n * 操作 input 输入\n\n * 生成器插件生命周期函数\n\n下面将从这三个分类分别介绍生成器插件 API。\n\n\n获取信息#\n\nlocale#\n\n获取生成器插件执行环境的语言。@modern-js/create 提供了 zh 和 en 两种语言，这里即为对应的这两种值。\n\nisFileExist#\n\n判断文件是否存在。我们很多时候需要在定义操作前确认目标项目文件是否已经存在，可以直接通过该 API 获取。\n\n例如我们需要获取 package.json 文件是否存在，然后做相应的操作：\n\nconst isExist = await context.isFileExist('package.json');\nif (isExist) {\n    ...\n}\n\n\nreadDir#\n\n获取文件夹内文件列表。我们很多时候需要在定义操作前获取目标项目文件夹下面文件列表，可以直接通过该 API 获取。\n\n例如我们需要获取 src 文件夹下所有文件，然后进行相应操作：\n\nconst files = await context.readDir('src');\n\nfiles.map(name => {\n    ...\n});\n\n\n\ninput 操作#\n\ninput 操作中使用的 key 参数可参考配置参数，需要在使用对应工程方案下的 key，即不支持在 solution 和 scenes。\n\ninput 操作中的 input 参数对应的 Schema 类型可参考 Input。\n\naddInputBefore#\n\n在指定的 input key 前添加问题。\n\n例如：\n\ncontext.addInputBefore('packageManager', {\n  type: 'object',\n  properties: {\n    language: {\n      type: 'string',\n      title: '开发语言',\n      enum: [\n        { label: 'TS', value: 'ts' },\n        { label: 'ES6+', value: 'js' },\n      ],\n    },\n  },\n});\n\n\naddInputAfter#\n\n在指定的 input key 后添加问题。\n\n例如：\n\ncontext.addInputAfter('packageManager', {\n  type: 'object',\n  properties: {\n    language: {\n      type: 'string',\n      title: '开发语言',\n      enum: [\n        { label: 'TS', value: 'ts' },\n        { label: 'ES6+', value: 'js' },\n      ],\n    },\n  },\n});\n\n\nINFO\n 1. 添加问题的 key 不能和 Modern.js 提供的工程方案自身的问题的 key 重复。\n 2. 添加问题 addInputAfter 的优先级高于 addInputBefore，当同时对一个 key 添加 After 问题和对其后一个key 添加\n    Before 问题时，After 问题会在 Before 之前。\n 3. 当需要在相同 key 前面或者后面添加多个问题时，可多次调用该方法，问题的顺序会按照调用顺序进行排列。\n\nsetInput#\n\n设置指定 input key 的属性。\n\n例如设置 packageName 的 title 属性：\n\ncontext.setInput('packageName', 'title', \"展示名称\");\n\n\nINFO\n\n对于 Modern.js 工程方案提供的输入选项，只支持删除，不支持增加，增加会造成代码中的逻辑判断存在问题。\n\nsetInputValue#\n\n设置指定 input key 的选项默认值。\n\n例如设置 packageManager 的默认值：\n\ncontext.setInputValue({\n  packageManager: 'npm',\n});\n\n\nINFO\n\n设置完成后，该问题还是需要交互，只是会使用生成器插件配置的默认值。\n\nsetDefaultConfig#\n\n设置指定 input key 的默认值。\n\n例如设置 packageManager 的默认值：\n\ncontext.setDefaultConfig({\n  packageManager: 'npm',\n});\n\n\nINFO\n\n设置完成后，将不再展示对应问题，和 @modern-js/create 制定 --config 行为一致。不支持设置 vertical 和\nprojectOrg。\n\nsetGitMessage#\n\n设置 Git 初始提交信息。Modern.js 默认 Git 初始化提交信息为 feat: init，通过该函数可以修改。\n\n\n生命周期函数#\n\n生命周期函数比较复杂，将通过后面两节 onForged 和 afterForged 分别介绍。","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/plugin/api/context.md","_relativePath":"zh/guides/topic-detail/generator/plugin/api/context.md"},{"id":553,"title":"Input","routePath":"/guides/topic-detail/generator/plugin/api/input","lang":"zh","toc":[{"text":"type","id":"type","depth":2,"charIndex":347},{"text":"title","id":"title","depth":2,"charIndex":478},{"text":"default","id":"default","depth":2,"charIndex":506},{"text":"enum","id":"enum","depth":2,"charIndex":536},{"text":"x-validator","id":"x-validator","depth":2,"charIndex":687},{"text":"x-reactions","id":"x-reactions","depth":2,"charIndex":1251},{"text":"properties","id":"properties","depth":2,"charIndex":1685}],"domain":"","content":"#\n\n生成器插件提供了 Input 的方式完成与用户的问题交互，使用 JSON Schema 的方式进行定义：\n\n例如：\n\nconst schema = {\n  type: 'object',\n  properties: {\n    language: {\n      type: 'string',\n      title: '开发语言',\n      enum: [\n        { label: 'TS', value: 'ts' },\n        { label: 'ES6+', value: 'js' },\n      ],\n    },\n  },\n};\n\n\nJSON Schema 的格式参考了开源的 Formily Schema 的格式，下面将对支持的字段进行介绍：\n\n\ntype#\n\n定义当前 Schema 类型，当前支持的类型为 string、number 和 object。字符串输入和下拉选项都需要使用 string 类型。 object\n类型用于实现 Schema 之间嵌套，需要配和 properties 属性使用。\n\n\ntitle#\n\n定义当前 Schema 展示名称。\n\n\ndefault#\n\n定义当前 Schema 的默认值。\n\n\nenum#\n\n当前 Schema 为下列选项时，定义选项内容。\n\n子项支持 string 或者 { label: string; value: string} 类型，当下拉选项中值和展示值相同时，可直接使用 string\n定义。\n\n当需要表示多选选项时，设置 default 字段为 [] 即可。\n\n\nx-validator#\n\n当前 Schema 的校验规则。当 Schema 为输入类型时，在输入完成后会自动完成校验。\n\n这里校验规则支持 Formily 提供的校验规则，例如最大值为 5：\n\nconst schema = {\n  type: 'object',\n  properties: {\n    max_5: {\n      type: 'number',\n      title: '最大值(>5报错)',\n      'x-validator': {\n        maximum: 5,\n      },\n    },\n  },\n};\n\n\n也支持直接使用验证函数：\n\nconst schema = {\n  type: 'object',\n  properties: {\n    path: {\n      type: 'string',\n      title: '只能包含数字和字母',\n      'x-validator': value => {\n        if (!/^[0-9a-zA-Z]*$/g.test(value)) {\n          return '格式不正确';\n        }\n        return '';\n      },\n    },\n  },\n};\n\n\n\nx-reactions#\n\n使用 Schema 之间的联动，这里和 Formily 联动规则完全相同。\n\n例如：\n\nconst schema = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string',\n      title: '名称',\n    },\n    path: {\n      type: 'string',\n      title: '路径',\n      'x-reactions': [\n        {\n          dependencies: ['name'],\n          fulfill: {\n            state: {\n              value: '{{$deps[0]}}',\n            },\n          },\n        },\n      ],\n    },\n  },\n};\n\n\n\nproperties#\n\n组织当前 Schema 的结构，定义子表单。properties 为对象，key 为 Schema 关键字，value 为上述描述的 Schema 对象。","frontmatter":{"sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/plugin/api/input.md","_relativePath":"zh/guides/topic-detail/generator/plugin/api/input.md"},{"id":554,"title":"onForged","routePath":"/guides/topic-detail/generator/plugin/api/onForged","lang":"zh","toc":[{"text":"类型","id":"类型","depth":2,"charIndex":35},{"text":"概念","id":"概念","depth":2,"charIndex":1006},{"text":"文件类型","id":"文件类型","depth":3,"charIndex":1012},{"text":"API","id":"api","depth":2,"charIndex":1319},{"text":"addFile","id":"addfile","depth":3,"charIndex":1350},{"text":"addManyFiless","id":"addmanyfiless","depth":3,"charIndex":2032},{"text":"updateJSONFile","id":"updatejsonfile","depth":3,"charIndex":2817},{"text":"updateTextRawFile","id":"updatetextrawfile","depth":3,"charIndex":3327},{"text":"updateModernConfig(不推荐)","id":"updatemodernconfig(不推荐)","depth":3,"charIndex":3727},{"text":"rmFile","id":"rmfile","depth":3,"charIndex":4140},{"text":"rmDir","id":"rmdir","depth":3,"charIndex":4216},{"text":"addHelper","id":"addhelper","depth":3,"charIndex":4291},{"text":"addPartial","id":"addpartial","depth":3,"charIndex":4426},{"text":"createElement","id":"createelement","depth":3,"charIndex":4559},{"text":"enableFunc","id":"enablefunc","depth":3,"charIndex":4716}],"domain":"","content":"#\n\nonForged 为生成器插件中用于文件操作的生命周期函数。\n\n\n类型#\n\nexport type ForgedAPI = {\n  addFile: (params: AddFileParams) => Promise;\n  addManyFiles: (params: AddManyFilesParams) => Promise;\n  updateJSONFile: (fileName: string, updateInfo: Record) => Promise;\n  updateTextRawFile: (fileName: string, update: (content: string[]) => string[]) => Promise;\n  updateModernConfig: (updateInfo: Record) => Promise;\n  rmFile: (fileName: string) => Promise;\n  rmDir: (dirName: string) => Promise;\n  addHelper: (name: string, fn: Handlebars.HelperDelegate) => void;\n  addPartial: (name: string, str: Handlebars.Template) => void;\n  createElement: (element: ActionElement, params: Record) => Promise;\n  enableFunc: (func: ActionFunction, params?: Record | undefined) => Promise;\n};\n\nexport type PluginForgedFunc = (\n  api: ForgedAPI,\n  inputData: Record,\n) => void | Promise;\n\nexport interface IPluginContext {\n  onForged: (func: PluginForgedFunc) => void;\n  ...\n}\n\n\nonForged 参数为一个回调函数，回调函数参数为 api 和 input，分别用于提供该生命周期函数提供的 API 及当前输入信息。\n\n\n概念#\n\n\n文件类型#\n\n生成器插件将文件类型分为撕四类：\n\n * 文本文件\n\n纯文本内容文件，可使用 Handlebars 或 EJS 进行模板处理的文件。\n\n * 二进制文件\n\n图片、音频、视频等文件。\n\n * JSON 文件\n\nJSON 格式的文件。\n\n * 文本列表文件\n\n文件由行文本组成的文件，例如 .gitignore, .editorconfig, .npmrc。\n\n对应四种文件的类型定义为：\n\nexport enum FileType {\n  Text = 'text',\n  Binary = 'binary',\n  Json = 'json',\n  TextRaw = 'textRaw',\n}\n\n\n\nAPI#\n\n下面将分别介绍 api 参数提供的 API。\n\n\naddFile#\n\n添加单个文件。\n\n参数类型：\n\nexport interface AddFileParams {\n  type: FileType;\n  file: string;\n  template?: string;\n  templateFile?: string;\n  force?: boolean;\n  data?: Record;\n}\n\n\n * type： 文件类型。\n * file：目标文件路径，相对于目标项目目录的相对路径。\n * template：模板内容，该字段值可直接用于模板渲染文件。优先级低于 templateFile。\n * templateFile：模板文件路径，相对于 templates 目录的相对路径即可。\n * force：是否强制覆盖，当目标文件存在时是否强制覆盖，默认为 false。\n * data：模板渲染数据。\n\nINFO\n\n文本类型文件默认使用 Handlebars 进行处理，当模板文件以 .ejs 结尾的话，会使用 EJS 进行模板渲染。\n\n例如添加模板文件 App.tsx.hanlebars 到 src/App.tsx 中:\n\ncontext.onForged(async (api: ForgedAPI, _input: Record) => {\n  await api.addFile({\n    type: FileType.Text,\n    file: `src/App.tsx`,\n    templateFile: `App.tsx.handlebars`,\n  });\n})\n\n\n\naddManyFiless#\n\n批量添加文件，一般用于添加多个文件到同一个目标目录。\n\n参数类型：\n\nexport interface AddManyFilesParams {\n  type: FileType;\n  destination: string;\n  templateFiles: string[] | (() => string[]);\n  templateBase?: string;\n  fileNameFunc?: (name: string) => string;\n  data?: Record;\n}\n\n\n * type： 文件类型。\n * destination：目标文件夹，相对于目标项目目录的相对路径。\n * templateFiles：模板文件列表，支持 globby 正则表达式\n * templateBase：模板文件的公共路径，使用该参数时目标文件会自动删除该路径。\n * fileNameFunc：重命名文件函数，添加文件过程中会依次将文件名传入到该函数，可以根据需要进行重命名。\n * data：模板渲染数据。\n\n例如将模板文件 src-ts 目录下所有文件渲染到 src 目录：\n\ncontext.onForged(async (api: ForgedAPI, _input: Record) => {\n  await api.addManyFiles({\n    type: FileType.Text,\n    destination: 'src',\n    templateFiles: ['src-ts/**/*'],\n    templateBase: 'src-ts',\n    fileNameFunc: name => name.replace('.handlebars', ''),\n  });\n})\n\n\n\nupdateJSONFile#\n\n更新 JSON 文件字段。\n\n参数类型：\n\nfileName: strings\nupdateInfo: Record\n\n\n * fileName：JSON 文件路径，相对于目标项目的路径。\n * updateInfo：更新信息，嵌套字段更新需要平铺，不然会更新整体造成内容丢失。\n\n例如更新 package.json 的 name 字段：\n\ncontext.onForged(async (api: ForgedAPI, _input: Record) => {\n  await api.updateJSONFile('package.json', { name: 'new_name' });\n})\n\n\n例如更新 dependencies 的 react-dom 版本:\n\ncontext.onForged(async (api: ForgedAPI, _input: Record) => {\n  await api.updateJSONFile('package.json', {\n    'dependencies.react-dom': '^18',\n  });\n})\n\n\n\nupdateTextRawFile#\n\n更新文本列表文件内容。\n\n参数类型：\n\nfileName: string\nupdate: (content: string[]) => string[]\n\n\n * fileName： 文本列表文件路径，相对于目标项目的路径。\n * update：更新函数，参数为当前文件内容以 \\n 进行分割的数组，返回值也为修改完成后的数组，@modern-js/create 会自动以 \\n\n   合并，并写入源文件。\n\n例如 .gitinore 文件中增加 dist 目录：\n\ncontext.onForged(async (api: ForgedAPI, _input: Record) => {\n  await api.updateTextRawFile('.gitinore', (content) => [...content, 'dist']);\n})\n\n\n\nupdateModernConfig(不推荐)#\n\nModern.js 配置除了可以在 modern.config.[tj]s 中配置外，还支持 package.json 中配置 modernConfig\n配置。该函数用于更新该字段。\n\n参数类型：\n\nupdateInfo: Record\n\n\n * updateInfo： 更新内容信息。updateModernConfig 是基于 updateJSONFile 的封装，将自动更新到\n   modernConfig 字段下，updateInfo 中只需填写 modernConfig 下的配置字段即可。\n\n例如开启 ssr：\n\ncontext.onForged(async (api: ForgedAPI, _input: Record) => {\n  await api.updateModernConfig({ 'server.ssr': true });\n})\n\n\n\nrmFile#\n\n删除文件。\n\n参数类型：\n\nfileName: string\n\n\n * fileName：删除的文件路径，相对于目标项目的路径。\n\n\nrmDir#\n\n删除文件夹。\n\n参数类型：\n\ndirName: string\n\n\n * dirName：删除的文件夹路径，相对于目标项目的路径。\n\n\naddHelper#\n\n添加 handlebrs 渲染的自定义 Helper。\n\n参数类型：\n\nname: string\nfn: Handlebars.HelperDelegate\n\n\n * name：Helper 函数名称。\n * fn：Helper 函数实现。\n\n\naddPartial#\n\n添加 Handlebars 渲染的 Partial。\n\n参数类型：\n\nname: string\nstr: Handlebars.Template\n\n\n * name：Partial 名称。\n * str：Partial 的模板字符串。\n\n\ncreateElement#\n\n自动调用 new 命令创建工程元素。\n\n参数类型：\n\nelement: ActionElement\nparams: Record\n\n\n * element：工程元素类型，新建入口或者新建自定义 Web Server 源码目录。\n * params：对应创建工程元素的其他参数。\n\n\nenableFunc#\n\n自动调用 new 命令开启可选功能。\n\n参数类型：\n\nfunc: ActionFunction\nparams?: Record\n\n\n * func：开启功能名称。\n * params：对应开启功能的其他参数。\n\nINFO\n\n创建工程元素和开启功能配置可参考配置参数。","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/plugin/api/onForged.md","_relativePath":"zh/guides/topic-detail/generator/plugin/api/onForged.md"},{"id":555,"title":"类型","routePath":"/guides/topic-detail/generator/plugin/category","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"标识","id":"标识","depth":2,"charIndex":155},{"text":"扩展","id":"扩展","depth":3,"charIndex":201},{"text":"自定义","id":"自定义","depth":3,"charIndex":257},{"text":"创建初始项目","id":"创建初始项目","depth":2,"charIndex":489},{"text":"扩展","id":"扩展-1","depth":3,"charIndex":499},{"text":"自定义","id":"自定义-1","depth":3,"charIndex":712},{"text":"执行顺序","id":"执行顺序","depth":2,"charIndex":985},{"text":"扩展","id":"扩展-2","depth":3,"charIndex":1051},{"text":"自定义","id":"自定义-2","depth":3,"charIndex":1329}],"domain":"","content":"#\n\n\n介绍#\n\n生成器插件分为两类：\n\n * 扩展：Web 应用( Npm 模块) = Web 应用( Npm 模块) + 生成器插件\n\n * 自定义：新应用(模块) = Web 应用(模块) + 生成器插件\n\n简单理解就是扩展还是使用 Modern.js 原本的工程方案名称，自定义会创建一个新的名称。\n\n\n标识#\n\n生成器插件的类型通过 package.json 中的 meta 字段来提供：\n\n\n扩展#\n\n{\n \"meta\": {\n    \"extend\": \"mwa\" // module\n }\n}\n\n\n\n自定义#\n\n{\n \"meta\": {\n    \"key\": \"new_app\",\n    \"name\": \"新应用\",\n    \"type\": \"mwa\" // module 和 custom\n }\n}\n\n\nINFO\n\n自定义类型的 type 支持 custom 类型，custom 为使用 Modern.js 提供的一些项目开发的最佳实践模板，比如\n.gitignore、.editorConfig 等文件，其他业务相关代码模板需要手动通过生成器插件提供。\n\n\n创建初始项目#\n\n\n扩展#\n\nnpx @modern-js/create@latest plugin --plugin @modern-js/generator-plugin-plugin\n? 请选择你想创建的工程类型 Npm 模块\n? 请选择项目场景 生成器插件\n? 请输入生成器插件插件包名 plugin\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n? 请选择插件类型 extend\n? 请选择插件基础类型 Web 应用\n\n\n\n自定义#\n\nnpx @modern-js/create@latest plugin --plugin @modern-js/generator-plugin-plugin\n? 请选择项目类型 生成器插件\n? 请选择项目组织方式 独立项目\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n? 请输入生成器插件插件包名 plugin\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n? 请选择插件类型 custom\n? 请输入插件关键字 new_app\n? 请输入插件展示名称 新应用\n? 请选择插件基础类型 Web 应用\n\n\n\n执行顺序#\n\n生成器插件支持同时使用多个，也就是执行 @modern-js/create 时支持多个 --plugin 参数。\n\n\n扩展#\n\n扩展生成器插件支持在执行时会按照声明的生成器插件参数的顺序，依次执行对应 extend 的工程方案的生命周期函数。\n\n例如存在 A 和 B 两个生成器插件，A 和 B 都是 extend 的 Web 应用工程方案，A 插件声明添加 a.ts 文件，B 插件声明添加 b.ts\n文件， 执行 npx @modern-js/create@latest --plugin A --plugin B 时，选择 Web 应用工程时，会先生成\nWeb 应用默认的项目文件，然后执行 A 插件创建 a.ts 文件，再执行 B 插件，生成 b.ts 文件。\n\n\n自定义#\n\n自定义生成器插件只支持同一时间运行一个生成器插件，当 @modern-js/create 声明 --plugin\n参数时，会在选择工程方案之后增加选择工程方案场景选项，即为上述 package.json 中定义的新 name，选择对应 name\n的生成器插件，即会在默认工程方案执行完成后，执行对应的生成器插件逻辑。声明 --plugin 参数时，工程方案场景下将会逐一列举出对应的生成器插件名称供选择。","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/plugin/category.md","_relativePath":"zh/guides/topic-detail/generator/plugin/category.md"},{"id":556,"title":"Context","routePath":"/guides/topic-detail/generator/plugin/context","lang":"zh","toc":[{"text":"自定义 Input","id":"自定义-input","depth":2,"charIndex":319},{"text":"生命周期","id":"生命周期","depth":2,"charIndex":660},{"text":"onForged","id":"onforged","depth":2,"charIndex":768},{"text":"afterForged","id":"afterforged","depth":2,"charIndex":1411}],"domain":"","content":"#\n\n生成器插件默认会导出一个函数，函数参数为 context，在执行过程中 context 会自动注入到生成器插件中。\n\n\n\nexport default function (context: IPluginContext) {\n  context.onForged(async (_api: ForgedAPI, _input: Record) => {\n    /**\n     * Todo\n     */\n  });\n}\n\n\ncontext 提供了两类 API，分别用于自定义 Input 和定义生成器插件声明周期逻辑。\n\nINFO\n\n下面只对部分 API 做简单示例讲解，完整的 API 请移步 生成器插件 API 查看。\n\n\n自定义 Input#\n\nModern.js Web 应用和 Npm 模块工程方案都存在一些默认的 Input 交互，使用这里的 API 可以对这些 Input\n进行添加、修改、隐藏、提供默认值等操作。\n\n例如：\n\n * 添加问题\n\ncontext.addInputBefore('packageManager', {\n  type: 'object',\n  properties: {\n    'username': {\n      type: 'string',\n      title: '用户名',\n    },\n  },\n});\n\n\n * 通过设置 config 隐藏问题\n\ncontext.setDefaultConfig({ langauge: 'ts' });\n\n\n\n生命周期#\n\n生成器插件提供了两个生命周期钩子函数用于定义生成器插件行为：\n\n * onForged：完成文件操作后的生命周期。\n\n * afterForged：onForged 钩子函数执行完成后的生命周期。\n\n\nonForged#\n\n在 Modern.js 工程方案生成器完成文件操作之后的钩子函数，用于完成生成器插件中的文件操作，比如添加模板文件，覆盖现有文件，删除现有文件等。\n\n对于扩展类型同时执行多个生成器插件时，将会按照声明顺序依次执行对应生成器插件的 onForged 操作。\n\nonForged 函数参数为一个回调函数，参数为 api 和 input。\n\ncontext.onForged(async (api: ForgedAPI, input: Record) => {\n  const { language } = input;\n  api.addFile({\n      type: FileType.Text,\n      file: `src/index.${language as string}`,\n      templateFile: `index.${language as string}.handlebars`,\n      force: true,\n  });\n})\n\n\napi 上会提供生成器插件支持的文件操作相关方法。\n\ninput 为当前用户输入内容，包含 --config 参数定义的，默认工程方案交互的及生成器插件定义的用户输入。\n\n当需要添加新的文件模板时，将模板文件定义到 templates 目录，然后通过上述 api 上方法进行操作即可，生成器插件默认对 templates\n目录文件进行操作，无需再声明 templates 路径。\n\n\nafterForged#\n\nonForged 钩子函数执行完成后执行，这里主要用于进行安装依赖，Git 操作等。\n\n默认 Modern.js 工程方案在完成文件操作后会默认执行安装依赖及 Git 初始化，Git 初次提交等，该钩子函数可以不使用。\n\n对于自定义的生成器插件还支持 custom 类型，该类型只提供了少量最佳实践的项目配置，则需要在该钩子函数中完成安装依赖和 Git 初始化等操作。\n\nafterForged 函数参数也为一个回调函数，参数为 api 和 input。\n\n  context.afterForged(\n    async (api: AfterForgedAPI, input: Record) => {\n      const { packageManager } = input;\n      console.info('packageManager:', packageManager);\n      await api.install();\n    },\n  );\n","frontmatter":{"sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/plugin/context.md","_relativePath":"zh/guides/topic-detail/generator/plugin/context.md"},{"id":557,"title":"介绍及创建项目","routePath":"/guides/topic-detail/generator/plugin/structure","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"创建项目","id":"创建项目","depth":2,"charIndex":445},{"text":"package.json","id":"packagejson","depth":2,"charIndex":1091},{"text":"src/index.ts","id":"src/indexts","depth":2,"charIndex":1242},{"text":"templates","id":"templates","depth":2,"charIndex":1530}],"domain":"","content":"#\n\n\n介绍#\n\nModern.js 提供了 Web 应用、Npm 模块等工程方案，并通过使用 @modern-js/create\n工具可以创建工程方案的初始项目模板，初始项目模板会提供基本的代码开发环境、简单的示例代码及配置等。\n\nModern.js 提供的初始化模板具有通用性，能满足一些通用的项目开发需求。\n\n当你深度使用 Modern.js 时，必然会发现每次创建的项目都会进行一些针对自身项目的特定的相似改动，比如修改示例代码、增加一些配置、开启某些功能等。\n\n生成器插件可以帮你将这些针对个人或团队特定的改动沉淀下来，在执行 npx @modern-js/create@latest 只需简单的带上 --plugin\n参数即可避免每次创建完项目都需重复性修改项目的工作。\n\n生成器插件是在 Modern.js 提供的初始化模板项目的基础上，提供对模板进行增加、删除、修改的方法，并通过快捷的方式修改\npackage.json、modernConfig 配置和开启功能等操作。\n\n\n创建项目#\n\n使用 @modern-js/create 可直接创建生成器插件项目：\n\nnpx @modern-js/create@latest plugin --plugin @modern-js/generator-plugin-plugin\n? 请选择你想创建的工程类型 Npm 模块\n? 请选择项目场景 生成器插件\n? 请输入生成器插件插件包名 plugin\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n? 请选择插件类型 extend\n? 请选择插件基础类型 Web 应用\n\n\n创建完成后，我们可以看一下这个项目的目录结构：\n\n.\n├── .changeset\n│   └── config.json\n├── .eslintrc.js\n├── .gitignore\n├── .npmrc\n├── .nvmrc\n├── .prettierrc\n├── README.md\n├── modern.config.ts\n├── package.json\n├── src\n│   ├── modern-app-env.d.ts\n│   └── index.ts\n├── templates\n│   └── .gitkeep\n└── tsconfig.json\n\n\n项目是基于 Npm 模块项目创建的，核心是下面几个文件：\n\n*\n├── package.json\n├── src\n│   └── index.ts\n├── templates\n│   └── .gitkeep\n\n\n\npackage.json#\n\npackage.json 中除了正常的模块项目的字段外，提供了 meta 字段，用于描述生成器插件的信息。\n\n生成器插件分为两类：扩展和自定义，具体分类定义可查看类型。\n\n{\n  ...,\n  \"meta\": {\n    \"extend\": \"mwa\"\n  }\n}\n\n\n\nsrc/index.ts#\n\n该文件用于完成生成器插件的内容开发。\n\n\n\nexport default function (context: IPluginContext) {\n  context.onForged(async (_api: ForgedAPI, _input: Record) => {\n    /**\n     * todo\n     */\n  });\n}\n\n\n该文件默认导出一个函数，函数参数为 context，context 上提供了生成器插件支持的 API 方法，可用于实现生成器插件的逻辑。context\n提供的能力可以参考 context。\n\n\ntemplates#\n\ntemplates 目录存在当前定制化方式的模板文件，支持 Handlebars 和 EJS\n格式，将根据模板文件后缀使用不同的渲染引擎就行渲染，如果无后缀，将会直接复制模板文件到目标目录。\n\n如果模板文件为 js、ts 或者 json 文件，推荐直接使用 .handlebars 或者 .ejs 后缀，可避免项目 eslint 报错和在\nMonorepo 中项目识别问题。\n\n模板中 .gitignore 文件和 .npmrc 文件在发布 npm 包时会自动删除，需要使用 .handlebars 或者 .ejs 后缀将其保留。","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/plugin/structure.md","_relativePath":"zh/guides/topic-detail/generator/plugin/structure.md"},{"id":558,"title":"使用","routePath":"/guides/topic-detail/generator/plugin/use","lang":"zh","toc":[{"text":"绝对路径","id":"绝对路径","depth":2,"charIndex":68},{"text":"相对路径","id":"相对路径","depth":2,"charIndex":178},{"text":"npm 包","id":"npm-包","depth":2,"charIndex":302}],"domain":"","content":"#\n\n@modern-js/create 提供了 --plugin 参数用于运行生成器插件项目。\n\n--plugin 支持三种格式：\n\n\n绝对路径#\n\n适用于本地开发调试，开发完成后，在生成器插件执行 npm run build 构建项目，然后使用下面命令即可进行测试。\n\nnpx @modern-js/create@latest --plugin \n\n\n\n相对路径#\n\n适用于本地开发调试或者生成器插件项目和目标创建项目在同一个 Monorepo，无需发布 NPM 包，构建项目后，执行下面命令即可。\n\nnpx @modern-js/create@latest --plugin file:../\n\n\n\nnpm 包#\n\n适用于生成器插件发布于 npm 上，共享生成器插件场景。\n\nnpx @modern-js/create@latest --plugin \n","frontmatter":{"sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/generator/plugin/use.md","_relativePath":"zh/guides/topic-detail/generator/plugin/use.md"},{"id":559,"title":"微前端介绍","routePath":"/guides/topic-detail/micro-frontend/c01-introduction","lang":"zh","toc":[{"text":"微前端关键词","id":"微前端关键词","depth":2,"charIndex":161},{"text":"功能简介","id":"功能简介","depth":2,"charIndex":264}],"domain":"","content":"#\n\n微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来\n仍然是内聚的单个产品。\n\n它主要解决了两个问题：\n\n * 随着项目迭代应用越来越庞大，难以维护。\n * 跨团队或跨部门协作开发项目导致效率低下的问题。\n\n\n微前端关键词#\n\n在微前端研发模式中，应用会被分成 主应用、和 子应用。\n\n * 主应用：微前端项目的基座工程，所有子应用都会由它来加载。\n * 子应用：独立开发、独立部署的应用，最终会被主应用加载。\n\n\n功能简介#\n\n * 基于 Garfish\n * 生成器支持微前端应用\n * 支持 React 组件式引用微前端子应用\n * 支持 loading\n * 支持主应用线上、子应用线下调试模式\n\n可以在 体验微前端 一节学习如何开发微前端主子应用。","frontmatter":{"sidebar_position":1,"title":"微前端介绍"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/micro-frontend/c01-introduction.mdx","_relativePath":"zh/guides/topic-detail/micro-frontend/c01-introduction.mdx"},{"id":560,"title":"体验微前端","routePath":"/guides/topic-detail/micro-frontend/c02-development","lang":"zh","toc":[{"text":"创建应用","id":"创建应用","depth":2,"charIndex":56},{"text":"创建约定式路由主应用","id":"创建约定式路由主应用","depth":3,"charIndex":205},{"text":"加载约定式路由子应用","id":"加载约定式路由子应用","depth":4,"charIndex":1037},{"text":"加载自控式路由子应用","id":"加载自控式路由子应用","depth":4,"charIndex":1167},{"text":"路由跳转","id":"路由跳转","depth":4,"charIndex":1306},{"text":"创建自控式路由主应用","id":"创建自控式路由主应用","depth":3,"charIndex":1472},{"text":"加载子应用","id":"加载子应用","depth":4,"charIndex":1802},{"text":"创建约定式路由子应用","id":"创建约定式路由子应用","depth":3,"charIndex":2351},{"text":"创建自控式路由子应用","id":"创建自控式路由子应用","depth":3,"charIndex":2914},{"text":"调试","id":"调试","depth":2,"charIndex":3646},{"text":"Modern.js 微前端和直接使用 Garfish 的区别","id":"modernjs-微前端和直接使用-garfish-的区别","depth":2,"charIndex":3878},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":4603}],"domain":"","content":"#\n\n通过本章你可以了解到：\n\n * 如何创建微前端项目的主应用、子应用。\n * 微前端项目开发的基本流程。\n\n\n创建应用#\n\n目前支持两种路由模式\n\n * 自控式路由\n * 约定式路由\n\n首先明确主应用的路由模式 创建约定式路由主应用 或 创建自控式路由主应用\n\n在本次体验中我们会为主应用创建两个子应用 Table 和 Dashboard (Table 为约定式路由，Dashboard 为自控式路由)\n\n\n创建约定式路由主应用#\n\n通过命令行工具初始化项目：\n\nmkdir masterApp && cd masterApp\nnpx @modern-js/create@latest\n\n\n? 请选择你想创建的工程类型：Web 应用\n? 请选择开发语言：TS\n? 请选择包管理工具：pnpm\n\n\n完成项目创建后我们可以通过 pnpm run new 来开启 微前端 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并添加开启微前端主应用，并增加子应用列表：\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n然后我们在 routes 文件夹下新建两个目录\n\n * table (用于加载约定式路由子应用)\n * dashboard (用于加载自控式路由子应用)\n\n在这两个目录下我们需要新建一个 $.tsx 文件作为主应用约定式路由的入口($ 代表模糊匹配，即 /table 和 /table/test 都会匹配到这个\n$.tsx 作为该路由的入口文件，这会保证在微前端场景下正确加载子应用路由)\n\n加载约定式路由子应用#\n\n\n\nconst Index = () => {\n  const { Table } = useModuleApps();\n\n  return (\n    \n\n      \n  )\n}\n\nexport default Index;\n\n\n加载自控式路由子应用#\n\n\n\nconst Index = () => {\n  const { Dashboard } = useModuleApps();\n\n  return (\n    \n\n      \n    \n  )\n}\n\nexport default Index;\n\n\n路由跳转#\n\n此时主应用配置已经完成，通过路由即可加载子应用，修改主应用的 layout.tsx 来跳转路由\n\n\n\nconst Layout = () => (\n  \n\n    \n加载约定式路由子应用\n    \n加载自控式路由子应用\n    \n卸载子应用\n    \n  \n);\n\nexport default Layout;\n\n\n\n创建自控式路由主应用#\n\n通过命令行工具初始化项目：\n\nmkdir masterApp && cd masterApp\nnpx @modern-js/create@latest\n\n\n完成项目创建后我们可以通过 pnpm run new 来开启 微前端 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并添加开启微前端主应用，并增加子应用列表：\n\n由于是自控式路由，我们删除掉 routes 文件夹并在 src 目录下增加 App.tsx 文件，此处如果使用的 非 MApp 组件，需要通过 React\nRouter v6 的 createBrowserRouter API 来创建路由\n\n加载子应用#\n\n\n\n\n\nconst AppLayout = () => (\n  <>\n    \n加载约定式路由子应用\n    \n加载自控式路由子应用\n    \n卸载子应用\n    \n  </>\n)\n\nexport default () => {\n  const { apps, MApp, Table, Dashboard } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      }>\n        } />\n        } />\n      \n    )\n  );\n\n  return (\n    // 方法一：使用 MApp 自动根据配置的 activeWhen 参数加载子应用(本项目配置在 modern.config.ts 中)\n    // \n    //   \n    // \n\n    // 方法二：手动写 Route 组件方式加载子应用，方便于需要鉴权等需要前置操作的场景\n    <>\n      \n    </>\n  );\n};\n\n\n\n创建约定式路由子应用#\n\n通过命令行工具初始化项目：\n\nmkdir table && cd table\nnpx @modern-js/create@latest\n\n\n按照如下选择，生成项目：\n\n我们执行 pnpm run new 来开启 微前端 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并修改 modern.config.ts，添加微前端子应用的配置 deploy.microFrontend：\n\n\n\n\nexport default defineConfig({\n  dev: {\n    port: 8081\n  },\n  runtime: {\n    router: true,\n    state: true,\n  },\n  deploy: {\n    microFrontend: true,\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n添加 src/routes/page.tsx 代码\n\nconst Index = () => {\n  return (\n    \nsubApp: 约定式路由的子应用的根路由\n  )\n}\n\nexport default Index;\n\n\n\n创建自控式路由子应用#\n\n通过命令行工具初始化项目：\n\nmkdir dashboard && cd dashboard\nnpx @modern-js/create@latest\n\n\n按照如下选择，生成项目：\n\n我们执行 pnpm run new 来开启 微前端：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并修改 modern.config.ts，添加微前端子应用的配置 deploy.microFrontend：\n\n\n\n\nexport default defineConfig({\n  dev: {\n    port: 8082\n  },\n  runtime: {\n    router: true,\n    state: true,\n  },\n  deploy: {\n    microFrontend: true,\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n自控式路由需要删除掉 routes 文件夹并在 src 目录下新建 App.tsx\n\n并在 src/App.tsx 添加代码，注意需要从 props 中解析并传递 basename 给 BrowserRouter\n\n\n\nexport default (props: {basename: string}) => {\n  const { basename } = props;\n\n  return (\n    \n      \n        自控式路由子应用根路由} />\n        自控式路由子应用子路由} />\n      \n    \n  );\n};\n\n\n\n调试#\n\n按顺序在目录执行 pnpm run dev 命令启动应用：\n\n * masterApp 主应用 http://localhost:8080\n * table 子应用(约定式路由) http://localhost:8081\n * dashboard 子应用(自控式路由) http://localhost:8082\n\n访问主应用地址 http://localhost:8080\n\n在完成了微前端整体开发流程的体验后，你可以进一步了解如何 开发主应用\n\n\nModern.js 微前端和直接使用 Garfish 的区别#\n\n使用纯 Garfish API 开发微前端应用时\n\n * 主应用：\n   * 安装 Garfish 依赖并使用 Garfish.run 注册子应用 参考\n   * 提供一个常驻的 DOM 节点供子应用挂载 参考\n * 子应用：\n   * 导出 provider 参考\n   * 设置应用的 basename 参考\n\n区别于直接使用 Garfish 运行时 API 开发微前端项目，Modern.js 的微前端方案更加开箱即用。 使用 pnpm new 启用微前端模式后会自动在\nModern.js 应用中集成 Garfish 插件，在 Garfish 插件的加持下，你只需要\n\n * 主应用：\n   * 配置 runtime.masterApp.apps 参数注册子应用\n   * 使用 useModuleApps API 获取子应用实例并在组件中完成渲染\n * 子应用：\n   * 配置 deploy.microFrontend\n\n所以插件中为你做了如下事情\n\n * 帮助你通过 Garfish 运行时 API 自动注册子应用（主应用）\n * useModulesApps 函数的返回值提供了一个常驻的 DOM 节点供子应用挂载（主应用）\n * 帮助你正确导出了 provider（子应用）\n * 帮助你正确设置了 basename 给 Modern.js 运行时提供 Router 实例，如果是自控式路由或手动引入的 react-router-dom\n   那么需要从 App.tsx 的 props 中获取 basename 手动传递给引入的 Router 实例（子应用）\n\n\n常见问题#\n\n自查手册: https://www.garfishjs.org/issues/","frontmatter":{"sidebar_position":2,"title":"体验微前端"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/micro-frontend/c02-development.mdx","_relativePath":"zh/guides/topic-detail/micro-frontend/c02-development.mdx"},{"id":561,"title":"开发主应用","routePath":"/guides/topic-detail/micro-frontend/c03-main-app","lang":"zh","toc":[{"text":"注册子应用信息","id":"注册子应用信息","depth":2,"charIndex":554},{"text":"直接注册子应用信息","id":"直接注册子应用信息","depth":3,"charIndex":635},{"text":"自定义远程应用列表","id":"自定义远程应用列表","depth":3,"charIndex":1021},{"text":"渲染子应用","id":"渲染子应用","depth":2,"charIndex":1451},{"text":"子应用组件","id":"子应用组件","depth":3,"charIndex":1587},{"text":"集中式路由","id":"集中式路由","depth":3,"charIndex":2790},{"text":"两种模式混用","id":"两种模式混用","depth":3,"charIndex":3079},{"text":"添加 loading","id":"添加-loading","depth":3,"charIndex":3197},{"text":"增加错误状态","id":"增加错误状态","depth":4,"charIndex":3411},{"text":"避免 loading 闪退","id":"避免-loading-闪退","depth":4,"charIndex":3620},{"text":"增加超时状态","id":"增加超时状态","depth":4,"charIndex":4110}],"domain":"","content":"#\n\n在上一章 体验微前端 通过一个示例演示了如何创建和配置微前端子应用，通过本章你可以进一步了解如何开发主应用，以及它的常见配置。\n\n在通过 @modern-js/create 命令创建应用工程后，可以在项目中执行 pnpm run new（实际执行了 modern new\n命令），在选择了「微前端」模式后，会安装微前端依赖依赖，只需手动注册插件即可。\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n\n注册子应用信息#\n\n当在 masterApp 配置上提供了信息后，将会认为该应用为主应用，目前存在两种子应用信息的配置方式，这两种方式分别应用于不同的场景。\n\n\n直接注册子应用信息#\n\n可以直接通过配置注册子应用信息：\n\n提示\n\n可以通过 API defineConfig 在运行时进行配置。 当参数为函数时无法被序列化到产物代码，所以在涉及到函数之类的配置时请通过\ndefineConfig 来进行配置\n\n\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [{\n      name: 'Table',\n      entry: 'http://localhost:8001',\n      // activeWhen: '/table'\n    }, {\n      name: 'Dashboard',\n      entry: 'http://localhost:8002'\n      // activeWhen: '/dashboard'\n    }]\n  },\n});\n\n\n\n自定义远程应用列表#\n\n通过该函数可以拉取远程的子应用列表，并将其注册至运行时框架：\n\ndefineConfig(App, {\n  masterApp: {\n    manifest: {\n      getAppList: async () => {\n        // 可以从其他远程接口获取\n        return [{\n          name: 'Table',\n          entry: 'http://localhost:8001',\n          // activeWhen: '/table'\n        }, {\n          name: 'Dashboard',\n          entry: 'http://localhost:8002'\n          // activeWhen: '/dashboard'\n        }];\n      },\n    },\n  },\n});\n\n\n\n渲染子应用#\n\n在微前端中分为两种加载子应用的方式：\n\n 1. 子应用组件 获取到每个子应用的组件，之后就可以像使用普通的 React 组件一样渲染微前端的子应用。\n 2. 集中式路由 通过集中式的路由配置，自动根据当前页面 pathname 激活渲染对应的子应用。\n\n\n子应用组件#\n\n开发者使用 useModuleApps 方法可以获取到各个子应用的组件。\n\n再通过 router 组件的结合运用，开发者可以自控式的根据不同的路由渲染不同的子应用。\n\n假设我们的子应用列表配置如下：\n\n编辑主应用 App.tsx 文件如下：\n\n\n\n\n\nconst AppLayout = () => (\n  <>\n    \n加载约定式路由子应用\n    \n加载自控式路由子应用\n    \n卸载子应用\n    \n  </>\n)\n\nexport default () => {\n  const { apps, MApp } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      }>\n        {apps.map(app => {\n          const { Component } = app;\n          // 模糊匹配，path 需要写成类似 abc/* 的模式\n          return (\n             {\n                    if (error) {\n                      return \nerror: {error?.message};\n                    } else if (pastDelay) {\n                      return \nloading;\n                    } else {\n                      return null;\n                    }\n                  },\n                }}\n              />\n              }\n            />\n          )\n        })}\n      \n    )\n  );\n\n  return (\n    // 方法一：使用 MApp 自动根据配置的 activeWhen 参数加载子应用(本项目配置在 modern.config.ts 中)\n    // \n    //   \n    // \n\n    // 方法二：手动写 Route 组件方式加载子应用，方便于需要鉴权等需要前置操作的场景\n    <>\n      \n    </>\n  );\n};\n\n\n这里通过 Route 组件自定义了 Table 的激活路由为 /table， Dashboard 的激活路由为 /dashboard。\n\n\n集中式路由#\n\n集中式路由 是将子应用的激活路由集中配置的方式。我们给子应用列表信息添加 activeWhen 字段来启用 集中式路由。\n\n然后在主应用中使用 useModuleApp 方法获取 MApp 组件, 并在主应用渲染 MApp。\n\n\n\nfunction App() {\n  const { MApp } = useModuleApps();\n\n  return (\n    \n\n      \n    \n  );\n}\n\n\n这样启动应用后，访问 /table 路由，会渲染 Table 子应用，访问 /dashboard 路由，会渲染 Dashboard 子应用。\n\n\n两种模式混用#\n\n当然 子应用组件 和 集中式路由 是可以混合使用的。\n\n * 一部分子应用作为 子应用组件 激活，另外一部分作为 集中式路由 激活。\n * 一部分子应用既可以作为 集中式路由 激活，也可以作为 子应用组件 激活。\n\n\n添加 loading#\n\n通过配置 loadable 配置，可以为「集中式路由」、「子应用」添加 loading\n组件，并可以考虑错误、超时、闪烁等情况的出现，从而为用户提供更好的用户体验。该功能的设计与实现参考至 react-loadable，基本功能较为相似。\n\nfunction Loading() {\n  return \nLoading...;\n}\n\nfunction App(){\n  return <>\n    \n\n增加错误状态#\n\n当微前端子应用加载失败或渲染失败时，loading component 将会接收 error 参数（若没有错误时 error 是 null）\n\nfunction Loading({ error }) {\n  if (error) {\n    return \nError msg {error?.message};\n  } else {\n    return \nLoading...;\n  }\n}\n\n\n避免 loading 闪退#\n\n有时 loading 组件的显示时间可能小于 200ms，这个时候会出现 loading 组件闪退的情况。许多用户研究证明，loading\n闪退的情况会导致用户感知加载内容的耗时比实际耗时更长，在 loading 小于 200ms 时，不展示内容，用户会认为它更快。\n\n所以 loading 组件还提供了 pastDelay 参数，超过设置的延迟展示时才会为 true，可以通过 delay 参数设置延迟的时长\n\nfunction Loading({ error, pastDelay }) {\n  if (error) {\n    return \nError! {error?.message};\n  } else if (pastDelay) {\n    return \nLoading...;\n  } else {\n    return null;\n  }\n}\n\n\ndelay 的默认值为 200ms，可以通过 loadable 中的 delay 来设置延迟展示的时间\n\n\nfunction App(){\n  return <>\n    \n\n增加超时状态#\n\n有时因为网络的原因，从而导致微前端子应用加载失败，从而导致一直展示 loading\n的状态，这对于用户而言非常糟糕，因为他们不知道合适才会获得具体的响应，他们是否需要刷新页面，通过增加超时状态可以很好的解决该问题。\n\nloading 组件在超时时会获得 timeOut 参数，当微前端应用加载超时时将会获得 timeOut 属性值为 true\n\nfunction Loading({ error, timeOut, pastDelay }) {\n  if (error) {\n    return \nError! {error?.message};\n  } else if (timeOut) {\n    return \nLoading timed out, please refresh the page... ;\n  } else if (pastDelay) {\n    return \nLoading...;\n  } else {\n    return null;\n  }\n}\n\n\n超时状态是关闭的，可以通过在 loadable 中设置 timeout 参数开启\n\n\nfunction App(){\n  return <>\n    ","frontmatter":{"sidebar_position":3,"title":"开发主应用"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/micro-frontend/c03-main-app.mdx","_relativePath":"zh/guides/topic-detail/micro-frontend/c03-main-app.mdx"},{"id":562,"title":"主子应用通信","routePath":"/guides/topic-detail/micro-frontend/c04-communicate","lang":"zh","toc":[{"text":"props 通信","id":"props-通信","depth":2,"charIndex":3},{"text":"channel 通信","id":"channel-通信","depth":2,"charIndex":306}],"domain":"","content":"#\n\n\nprops 通信#\n\nModern.js 中，会将子应用包裹成一个 React 组件，直接通过给 React 组件传递 props 即可实现主应用和子应用通信的目的。\n\nfunction App() {\n  const { MApp } = useModuleApps();\n\n  return (\n    \n\n      \n    \n  );\n}\n\n\nfunction App(props) {\n  console.log(props);\n  return ...\n}\n\n\n子应用将会打印 {count: 0}，目前尚未支持子应用渲染响应式，及时在主应用上更改 count 的数据也不会触发视图更新\n\n\nchannel 通信#\n\nGarfish.channel 用于应用间的通信。它是 EventEmitter2 的实例\n\n// 子应用监听登录事件\nconst App = () => {\n  const handleLogin = userInfo => {\n    console.log(`${userInfo.name} has login`);\n  };\n\n  useEffect(() => {\n    window?.Garfish.channel.on('login', handleLogin);\n    return () => {\n      window?.Garfish.channel.removeListener('login', handleLogin);\n    };\n  });\n};\n\n// 主应用触发监听事件\napi.getLoginInfo.then(res => {\n  if (res.code === 0) {\n    window.Garfish.channel.emit('login', res.data);\n  }\n});\n","frontmatter":{"sidebar_position":4,"title":"主子应用通信"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/micro-frontend/c04-communicate.mdx","_relativePath":"zh/guides/topic-detail/micro-frontend/c04-communicate.mdx"},{"id":563,"title":"混合技术栈","routePath":"/guides/topic-detail/micro-frontend/c05-mixed-stack","lang":"zh","toc":[{"text":"子应用是 Modern.js","id":"子应用是-modernjs","depth":2,"charIndex":167},{"text":"主应用是 Modern.js","id":"主应用是-modernjs","depth":2,"charIndex":300}],"domain":"","content":"#\n\nModern.js 微前端方案是基于 Garfish 封装的，提供了一些更开箱即用的使用方式。\n\n当你的主应用和子应用不全是 Modern.js 应用的时候，可以参考这篇文档。\n\n 1. 子应用是 Modern.js，主应用使用的原生 Garfish 微前端。\n 2. 主应用是 Modern.js，子应用有的是其它技术栈。\n\n\n子应用是 Modern.js#\n\nModern.js 子应用编译后会生成标准的 Garfish 子应用导出。 所以可以直接接入标准的微前端主应用。\n\nINFO\n\n子应用是 Modern.js，主应用使用的原生 Garfish 微前端时，子应用调试模式 不可用。\n\n\n主应用是 Modern.js#\n\n主应用是 Modern.js，子应用用的其它技术栈。子应用按照 Garfish 子应用标准 开发即可。","frontmatter":{"sidebar_position":5,"title":"混合技术栈"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/micro-frontend/c05-mixed-stack.mdx","_relativePath":"zh/guides/topic-detail/micro-frontend/c05-mixed-stack.mdx"},{"id":564,"title":"自动生成 Actions","routePath":"/guides/topic-detail/model/auto-actions","lang":"zh","toc":[{"text":"原始数据类型","id":"原始数据类型","depth":2,"charIndex":153},{"text":"数组类型","id":"数组类型","depth":2,"charIndex":419},{"text":"简单对象类型","id":"简单对象类型","depth":2,"charIndex":848}],"domain":"","content":"#\n\n在 快速上手 中，我们实现最简单的计数器 Model 也需要 10 行代码。 实际上，Modern.js 支持根据声明的 state 类型，自动生成常用的\nActions，从而简化模板代码量。当前支持的类型有：\n\n * 原始数据类型\n * 数组类型\n * 简单对象类型（Plain Object）\n\n\n原始数据类型#\n\nconst countModel = model('count').define({ state: 1 });\n\n\n如上我们仅用一行就完成了一个简单的 countModel。使用 Model 的示例代码如下：\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  useEffect(() => {\n    // 增加 1\n    actions.setState(state + 1);\n  }, []);\n}\n\n\n\n数组类型#\n\n当 State 为数组类型时，自动生成 Actions 的示例代码如下：\n\nconst countModel = model('count').define({ state: [] });\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  useEffect(() => {\n    actions.push(1);\n    actions.pop();\n    actions.shift();\n    actions.unshift(1);\n    actions.concat([1]);\n    actions.splice(0, 1, 2);\n    actions.filter(value => value > 1);\n  }, []);\n}\n\n\n我们可以使用 JavaScript Array 对象的方法，修改 State。\n\n\n简单对象类型#\n\n当 State 为简单对象类型时，自动生成 Actions 的示例代码如下：\n\nconst countModel = model('count').define({\n  state: {\n    a: 1,\n    b: [],\n    c: {},\n  },\n});\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  useEffect(() => {\n    actions.setA(2);\n    actions.setB([1]);\n    actions.setC({ a: 1 });\n  }, []);\n}\n\n\n根据 a、b、c 三个不同的字段分别生成 setA、setB、setC 三个 Actions。\n\nINFO\n\n当用户自定义的 Action 和 Modern.js 自动生成的 Action 名字一致时，用户自定义的 Action 优先级更高。例如，countModel\n中已经自定义 setA 这个 Action，调用 actions.setA() 时，最终执行的是用户自定义的 setA。\n\n在\n\n补充信息\n\n相关 API 的更多介绍，请参考这里。","frontmatter":{"sidebar_position":6,"title":"自动生成 Actions"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/auto-actions.mdx","_relativePath":"zh/guides/topic-detail/model/auto-actions.mdx"},{"id":565,"title":"衍生状态","routePath":"/guides/topic-detail/model/computed-state","lang":"zh","toc":[{"text":"只依赖自身的 State","id":"只依赖自身的-state","depth":2,"charIndex":160},{"text":"依赖其他 Model 的 State","id":"依赖其他-model-的-state","depth":2,"charIndex":1244},{"text":"函数类型的衍生状态","id":"函数类型的衍生状态","depth":2,"charIndex":1743}],"domain":"","content":"#\n\n一些场景中，组件需要对 Model 中的 State 进行进一步计算，才能在组件中使用，这部分逻辑可以直接写在组件内部，也可以通过 Model 的衍生状态实现。\n衍生状态定义在 Model 中的 computed 字段下。根据依赖的 Model 的不同、返回类型的不同，衍生状态的定义方法可以分为以下 3 种。\n\n\n只依赖自身的 State#\n\n衍生状态只依赖当前 Model 的 State，State 会作为第一个参数，传入衍生状态的定义函数中。\n\n例如， todo 应用的 State 有 items 和 filter，filter 用于过滤当前页面显示的 todo 项，所以我们定义了一个\nvisibleTodos 的衍生状态可以直接在组件中使用。示例代码如下：\n\n/**\n *  假设 todo item 结构如下：\n{\n    id: string;          // id\n    text: string;        // todo 事项\n    completed: boolean;  // 完成状态：0 代表未完成，1 代表完成\n}\n**/\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n    filter: 'ALL', // ALL: 显示全部；COMPLETED：显示完成的事项；ACTIVE：显示未完成的事项\n  },\n  computed: {\n    visibleTodos: state => {\n      switch (state.filter) {\n        case 'ALL':\n          return state.items;\n        case 'COMPLETED':\n          return todos.filter(t => t.completed);\n        case 'ACTIVE':\n          return todos.filter(t => !t.completed);\n        default:\n          return [];\n      }\n    },\n  },\n});\n\n\n衍生状态最终会和 Model 的 State 进行合并，因此，可以通过 Model 的 State 对象访问到衍生状态，例如，visibleTodos\n在组件内的使用方式如下：\n\nfunction Todo() {\n  const [state, actions] = useModel(todoModel);\n\n  return (\n    \n\n      \n\n        {state.visibleTodos.map(item => (\n          \n{item.text}\n        ))}\n      \n    \n  );\n}\n\n\n\n依赖其他 Model 的 State#\n\n除了依赖当前 Model 的 State，衍生状态还依赖其他 Model 的 State，这时候衍生状态的定义格式为：\n\n[stateKey]: [...depModels, (selfState, ...depModels) => computedState]\n\n\n下面的示例，演示了 barModel 的衍生状态 combinedValue 是如何依赖 fooModel 的 State 的。\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 'foo',\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    value: 'foo',\n  },\n  computed: {\n    combinedValue: [\n      fooModel,\n      (state, fooState) => state.value + fooState.value,\n    ],\n  },\n});\n\n\n\n函数类型的衍生状态#\n\n衍生状态还可以返回一个函数。这时候衍生状态的定义格式为：\n\n[stateKey]: (state) => (...args) => computedState    // 只依赖自身的 state\n[stateKey]: [...depModels, (selfState, ...depModels) => (...args) => computedState]  // 依赖其他 Model 的 state\n\n\n假设，todo 应用的 state 不存储 filter 状态，而是直接在组件中使用，那么 visibleTodos\n可以是一个函数类型的值，这个函数在组件中使用的时候，接收 filter 参数。如下所示：\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n  },\n  computed: {\n    visibleTodos: state => filter => {\n      switch (filter) {\n        case 'ALL':\n          return state.items;\n        case 'COMPLETED':\n          return todos.filter(t => t.completed);\n        case 'ACTIVE':\n          return todos.filter(t => !t.completed);\n        default:\n          return [];\n      }\n    },\n  },\n});\n\nfunction Todo(props) {\n  // filter 状态通过 props 传入\n  const { filter } = props;\n  const [state, actions] = useModel(todoModel);\n\n  // 计算得到最终要显示的 todos\n  const todos = state.visibleTodos(filter);\n\n  return (\n    \n\n      \n\n        {todos.map(item => (\n          \n{item.text}\n        ))}\n      \n    \n  );\n}\n\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":4,"title":"衍生状态"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/computed-state.mdx","_relativePath":"zh/guides/topic-detail/model/computed-state.mdx"},{"id":566,"title":"创建 Model","routePath":"/guides/topic-detail/model/define-model","lang":"zh","toc":[],"domain":"","content":"#\n\n上一节的计数器应用中，我们简单演示了如何创建一个 Model。本节我们将详细介绍 Model 的创建方法。\n\n通过 model API 创建 Model，例如，model('foo') 表示要创建一个名为 foo 的 Model，通过调用 model('foo')\n返回的 define 函数，定义 Model 包含的 State、Actions 等：\n\n\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 'foo',\n  },\n  actions: {\n    setValue: (state, payload){\n      state.value = payload\n    }\n  }\n});\n\n\nINFO\n * Model 中的 Action 中不能包含有副作用的逻辑，如请求 HTTP 接口，访问 localStorage 等。\n * setValue 内部直接修改了入参 State，看起来是违反了纯函数的定义，实际上 Reduck 内部使用 immer\n   来修改不可变对象，保证了这种写法不会影响对象的不可变性，所以 setValue 仍然是一个纯函数。当然，你也可以直接在 Action\n   中返回一个新对象，不过这样的写法会更加复杂一些。\n\ndefine 接收的参数，只是对 Model 原始结构的描述：内部定义的 State、Actions 等。define 返回值 fooModel\n才是真正创建得到的 Model 对象。例如，虽然 setValue，有 2 个参数，但是当真正调用 setValue 这个 Action 时，我们只需要传入\npayload 一个参数，因为我们调用的是 fooModel 上的 Action 方法，而不是 Model 原始结构上描述的 Action 方法。详细参考使用\nModel。\n\ndefine 除了接收对象类型的参数，还可以接收函数类型的参数。例如：\n\n\n\nconst fooModel = model('foo').define((context, utils) => {\n  return {\n    state: {\n      value: 'foo',\n    },\n    actions: {\n      setValue: (state, payload){\n        state.value = payload\n      }\n    }\n  }\n});\n\n\n通过函数定义 Model 时，函数内部会自动传入 context、utils 2 个参数，context 是 Reduck 的上下文对象，可以获取到 store\n对象，utils 提供了一组工具函数，方便实现 Model 通信等复杂功能需求。\n\nModel 支持复制。例如：\n\nconst barModel = fooModel('bar');\n\n\nbarModel 是基于 fooModel 创建出一个的新的 Model 对象，类比面向对象编程语言中的概念，barModel 和 fooModel\n是基于同一个类（Class）创建出的 2 个实例对象。当两个模块的状态管理逻辑相同，例如一个页面中的两个 tab\n模块，使用的数据的结构和逻辑相同，区别只是从不同的接口获取数据，那么可以通过 Model 复制的方式，创建 2 个不同的 Model 对象。\n\n补充信息\n\n本节涉及的 API 的详细定义，请参考这里。","frontmatter":{"sidebar_position":2,"title":"创建 Model"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/define-model.mdx","_relativePath":"zh/guides/topic-detail/model/define-model.mdx"},{"id":567,"title":"常见问题","routePath":"/guides/topic-detail/model/faq","lang":"zh","toc":[{"text":"浏览器兼容性","id":"浏览器兼容性","depth":2,"charIndex":3},{"text":"微前端子应用 Model 访问主应用 Model","id":"微前端子应用-model-访问主应用-model","depth":2,"charIndex":141}],"domain":"","content":"#\n\n\n浏览器兼容性#\n\nReduck 的编译构建产物默认使用 ES6 语法，如果你需要支持更低版本的浏览器，请将 @modern-js-reduck\n命名空间下的所有包加入到应用的编译过程。\n\n补充信息\n\nReduck 使用的 @babel/preset-env 的详细配置。\n\n\n微前端子应用 Model 访问主应用 Model#\n\n微前端子应用 Model 访问主应用 Model 时，如果该 Model 在主应用尚未挂载，会自动挂载到子应用上。\n\n示例：\n\n\n\n\nfunction SubModelApp() {\n  const [state, actions] = useModel(parentModel);\n\n  return \n...;\n}\n\n\n\n\n为了避免意外降级挂载，建议将主应用所需要共享的 Model 预先挂载：\n\n// App 是主应用的入口组件，sharedModel1、sharedModel2 是需要共享的 Model。\nApp.models = [sharedModel1, sharedModel2];\n","frontmatter":{"sidebar_position":13,"title":"常见问题"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/faq.mdx","_relativePath":"zh/guides/topic-detail/model/faq.mdx"},{"id":568,"title":"副作用管理","routePath":"/guides/topic-detail/model/manage-effects","lang":"zh","toc":[{"text":"副作用对 State 修改","id":"副作用对-state-修改","depth":2,"charIndex":158},{"text":"副作用不影响 state","id":"副作用不影响-state","depth":2,"charIndex":3956},{"text":"副作用函数返回值","id":"副作用函数返回值","depth":2,"charIndex":4574}],"domain":"","content":"#\n\nModel 中的 Action 必须是一个纯函数，执行过程中不会产生任何副作用。但在真实的业务中，我们会遇到很多副作用场景，如：请求 HTTP\n接口获取状态数据，或者在更新状态的同时修改 localStorage、发送事件等。在 Reduck 中，是通过 Model 的 Effects\n函数管理副作用的。\n\n\n副作用对 State 修改#\n\n副作用修改 State，最常见的场景就是请求 HTTP 接口，更新状态数据。\n\n我们以一个简单的 todoModel 为例。其有一个 load 的副作用函数，请求远端的 TODO 列表，请求成功之后更新 state.items 字段。\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  actions: {\n    load: {\n      pending(state) {\n        state.loading = true;\n      },\n      fulfilled(state, items) {\n        state.items = items;\n        state.loading = false;\n      },\n      rejected(state, error) {\n        state.error = error;\n        state.loading = false;\n      },\n    },\n  },\n  effects: {\n    // Promise 副作用\n    async load() {\n      return new Promise(resolve => {\n        setTimeout(() => resolve(['Learn Modern.js']), 2000);\n      });\n    },\n  },\n});\n\n\n副作用函数统一定义在 effects 字段下。这里我们写了一个 load 函数，它返回一个 Promise，Promise 执行成功后，返回 TODO 列表\n[\"Lerna Modern.js\"]。\n\n副作用函数需要和 actions 配合使用，才能完成状态的修改。因此，我们在 actions 中定义了一个 load（命名需要和 effects\n下的副作用函数的名字保持一致）对象，包含 pending、fulfilled、rejected 3 个 action，分别是对副作用函数 load 返回的\nPromise 的三种状态（ pending、fulfilled、rejected ）的处理：\n\n * pending：接收当前状态 state 作为参数，新的状态中 loading 设为 true。\n * fulfilled：接收当前状态 state 和 Promise fulfilled 状态的值 items 为参数，新的状态中 items 等于参数\n   items、loading 设为 false。\n * rejected：接收当前状态 state 和 Promise rejected 状态的错误 error 为参数，新的状态中 error 等于参数\n   error、loading 设为 false。\n\n组件中如何调用 effects 函数呢？ effects 函数会被合并到 actions 对象上，因此可以通过 actions 对象调用 effects\n函数，如下所示：\n\nfunction Todo() {\n  const [state, actions] = useModel(todoModel);\n\n  useEffect(() => {\n    // 调用 effects 函数\n    actions.load();\n  }, []);\n\n  if (state.loading) {\n    return \nloading....;\n  }\n\n  return (\n    \n\n      \n\n        {state.items.map((item, index) => (\n          \n{item}\n        ))}\n      \n    \n  );\n}\n\n\n上面的示例中， pending、fulfilled、rejected 3 个 action，对于用于获取数据的 HTTP\n请求场景下，一般都是需要的。Reduck 提供了一个工具函数 handleEffect，用于简化这种场景下的 action 创建。\n\nhandleEffect 约定这种副作用场景下， Model 的 State 结构包含 result、error、pending 3 个字段，初始值为：\n\n{\n  result: null,\n  error: null,\n  pending: false，\n}\n\n\n调用 handleEffect 会返回如下数据结构:\n\n{\n  pending() { // ... },\n  fulfilled() { // ... },\n  rejected() { // ... }\n}\n\n\n这个数据结构和我们在 actions 下的 load 对象的数据结构是相同的。handleEffect 返回的对象，其实就是对应了 Effects 函数需要的\n3 个 action。\n\n利用 handleEffect，改写 todoModel：\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  actions: {\n    load: handleEffect({ result: 'items' }),\n  },\n  effects: {\n    // Promise 副作用\n    async load() {\n      return new Promise(resolve => {\n        setTimeout(() => resolve(['Learn Modern.js']), 2000);\n      });\n    },\n  },\n});\n\n\nhandleEffect 接收的参数对象，将 result 设置为 item。因为 todoModel 的 state，使用 items 作为 key 保存\ntodo 列表数据，而不是使用 handleEffect 默认的 result 作为 key，所以这里需要进行配置。\n\n明显可见，通过 handleEffect 实现的 todoModel 比之前的实现有了很大精简。\n\n如果不希望 pending、fulfilled、rejected 3 种状态都被 handleEffect 自动处理，例如 fulfilled\n需要手动处理较复杂的数据类型，但是 pending、rejected 依旧想进行自动化处理，可以参考如下写法：\n\n  actions: {\n    load: {\n      ...handleEffect(),\n      fulfilled(state, payload) {\n        // 手动处理\n      },\n    },\n  },\n\n\n补充信息\n\nhandleEffect API。\n\nEffects 函数中，也支持手动调用 Actions，例如：\n\nconst todoModel = model('todo').define((context, utils) => ({\n  state: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  actions: {\n    pending(state) {\n      state.loading = true;\n    },\n    fulfilled(state, items) {\n      state.items = items;\n      state.loading = false;\n    },\n  },\n  effects: {\n    async load() {\n      // 通过 utils.use 获取当前 Model 对象的 actions\n      const [, actions] = utils.use(todoModel);\n      // 手动调用 action\n      actions.pending();\n\n      return new Promise(resolve => {\n        setTimeout(() => {\n          const items = ['Learn Modern.js'];\n          // 手动调用 action\n          actions.fulfilled(items);\n          resolve(items);\n        }, 2000);\n      });\n    },\n  },\n}));\n\n\nINFO\n\n可以使用 use 函数加载其它 Model（包括 Model 自身），实现 Model 间通信。\n\n\n副作用不影响 state#\n\n有些场景下，我们只需要读取 State，执行相关副作用逻辑，副作用不会修改 State。\n\n例如，存储某些 State 到 localStorage：\n\nconst fooModel = model('foo').define((context, utils) => ({\n  state: {\n    value: 'foo',\n  },\n  effects: {\n    setLocalStorage(key) {\n      const [state] = utils.use(fooModel);\n      localStorage.set(key, state.value);\n      return 'success';\n    },\n  },\n}));\n\n\n或者是向服务端发送数据：\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 'foo',\n  },\n  effects: {\n    async sendData(data) {\n      const res = await fetch('url', {\n        method: 'POST',\n        body: data,\n      });\n      return res.json();\n    },\n  },\n});\n\n\n\n副作用函数返回值#\n\n有时候，我们希望能根据副作用函数的执行结果，直接执行后续逻辑。这时候，就需要使用 Effects 函数的返回。\n\n例如，当点击发送按钮，发送数据成功后，立即关闭当前的弹窗；如果失败，显示错误信息。我们可以通过如下代码实现：\n\n// 代码仅做示意，不能执行\n// 组件内部 发送按钮 的响应函数\nconst handleClick = async () => {\n  // sendData 返回代表状态的字符串\n  const result = await actions.sendData('some data');\n  if (result === 'success') {\n    // 关闭弹窗\n    closeModal();\n  } else {\n    // 显示错误\n    showError(result);\n  }\n};\n\n\n补充信息\n\n示例代码","frontmatter":{"sidebar_position":5,"title":"副作用管理"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/manage-effects.mdx","_relativePath":"zh/guides/topic-detail/model/manage-effects.mdx"},{"id":569,"title":"Model 通信","routePath":"/guides/topic-detail/model/model-communicate","lang":"zh","toc":[{"text":"Model 间通信","id":"model-间通信","depth":2,"charIndex":67},{"text":"Model 内通信","id":"model-内通信","depth":2,"charIndex":2625}],"domain":"","content":"#\n\nModel 通信，既指不同 Model 间的通信，也指同一个 Model 内部 Effects、Actions 之间的通信。\n\n\nModel 间通信#\n\nModel 之间不是孤立的，是可以进行通信的。主要分为两种场景：\n\n 1. 在 Model 中访问其它 Model 的 State 和 Actions。\n 2. 在 Model 中监听其它 Model 变化。\n\n这里将 快速上手 一节的简单计数器应用改造成一个可设置步频的计数器应用。可以通过设置步频，从而影响每次计数器增加的幅度。\n\n我们抽象出两个 Model，分别为 stepModel（步频）、counterModel（计数器）：\n\n\n\nconst stepModel = model('step').define({\n  state: 1,\n});\n\nconst counterModel = model('count').define((context, { use, onMount }) => {\n  const [, , subscribeStep] = use(stepModel);\n\n  onMount(() => {\n    return subscribeStep(() => {\n      console.log(\n        `Subscribe in counterModel: stepModel change to ${use(stepModel)[0]}`,\n      );\n    });\n  });\n\n  return {\n    state: {\n      value: 1,\n    },\n    actions: {\n      add(state) {\n        const step = use(stepModel)[0];\n        state.value += step;\n      },\n    },\n  };\n});\n\nexport { stepModel, counterModel };\n\n\nstepModel 只声明一个 state，初始值为 1。\n\ncounterModel 通过 use 函数加载 stepModel，拿到返回的 subscribeStep 函数，用来监听 stepModel 状态的变更。\nonMount 是 Model 挂载完成后的钩子函数，counterModel 挂载完成后开始订阅 stepModel 状态的变更，打印出 stepModel\n的最新值。\n\ncounterModel 通过 use 函数访问 stepModel，在 add 里可以获取到当前 stepModel 的值（步频），以此值来做自增。\n\n注意\n\n当需要访问其他 Model 的 State 时，必须要在当前 Actions 或 Effects 函数（本例中对应 add 函数 ）真正执行的阶段调用\nuse，以保证获取的 State 是最新值。因此，我们虽然在 define 的回调函数中也调用了 use(stepModel)，但是我们并没有解构\nstepModel 的 state 值，因为 define 的回调函数是在 Model 的挂载阶段执行的，这个时候获取到的 stepModel 的 state\n可能和 add 执行时获取到的值是不同的。\n\n修改 App.tsx\n\n\n\n\nfunction Counter() {\n  const [state, actions] = useModel(counterModel);\n  const [step, stepActions] = useModel(stepModel);\n\n  return (\n    \n\n      \nstep: {step}\n       stepActions.setState(step + 1)}>add step\n      \ncounter: {state.value}\n       actions.add()}>add counter\n    \n  );\n}\n\nexport default function App() {\n  return ;\n}\n\n\n补充信息\n\nModern.js 默认开启 自动生成 actions，所以 stepModel 中虽然没有手动定义 Actions，但可以使用自动生成的 setState。\n\n * 点击 add step 增加步频。\n * 点击 add counter 触发计数器增加。\n\n最终效果如下：\n\n\n\n补充信息\n * 本节完整的示例代码。\n * 相关 API 的更多介绍，请参考：model。\n\n前面 counterModel 的例子，我们是在 Actions 的函数内部调用 use 获取其他 Model 对象的。如果只需要调用其它 Model 的\nActions，因为 Actions 都是函数，不存在值过期问题，所以也可以在 define 的回调函数中调用 use 获取 Model 的\nActions。例如：\n\nconst barModel = model('bar').define({\n  // 省略\n});\n\nconst fooModel = model('foo').define((context, utils) => {\n  // 获取 barModel 的 actions\n  const [, actions] = utils.use(barModel);\n  return {\n    // 省略 state、actions\n    effects: {\n      async loadA() {\n        // 省略副作用逻辑\n        // 调用 barModel 的 action\n        barModel.actionA();\n      },\n      async loadB() {\n        // 省略副作用逻辑\n        // 调用 barModel 的 action\n        barModel.actionB();\n      },\n    },\n  };\n});\n\n\n这样，我们不需要在 loadA、loadB 中重复获取 barModel 对象，简化了代码逻辑。\n\n\nModel 内通信#\n\nModel 内通信，也主要分为两种场景：\n\n 1. Effects 函数调用自身 Model 的 Actions 函数、或其他 Effects 函数。\n 2. Actions 函数调用自身 Model 的 其他 Actions 函数。\n\n在 副作用管理 一节，我们演示过 Effects 函数如何调用 Actions 函数。\n\n这里我们再来举一个例子：\n\nconst fooModel = model('foo').define((context, { use, onMount }) => ({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.a = payload;\n    },\n  },\n  effects: {\n    async loadA() {\n      // 通过 use 获取当前 Model 的 actions\n      const [, actions] = use(fooModel);\n      const res = await mockFetchA();\n      actions.setA(res);\n    },\n    async loadB() {\n      // 通过 use 获取当前 Model 的 actions\n      const [, actions] = use(fooModel);\n      const res = await mockFetchB();\n      actions.setB(res);\n    },\n  },\n}));\n\n\n这个例子中，fooModel 的两个 Effects 函数，需要调用自身的 Actions 函数。这里我们在每个 Effects 函数中，都调用了一次\nuse，为什么不能像 Model 间通信的例子中，在 define 的回调函数中，统一调用 use 获取 Model 自身的 Actions 呢？这是因为调用\nuse 获取 Model 时，会先检查这个 Model 是否已经挂载，如果还没有挂载，会先执行挂载逻辑，而 define 的回调函数又是在 Model\n的挂载阶段执行的，这样一来，在挂载阶段调用 use 获取 Model 自身，会出现死循环（代码实际执行过程会抛出错误）。所以，一定不能在 define\n的回调函数中，调用 use 获取 Model 自身对象。\n\n不过，我们可以利用 onMount 这个钩子函数，在 Model 挂载完成后，再通过 use 获取 Model 自身对象：\n\nconst fooModel = model('foo').define((context, { use, onMount }) => {\n  let actions;\n\n  onMount(() => {\n    // fooModel 挂载完成后，通过 use 获取当前 Model 的 actions\n    [, actions] = use(fooModel);\n  });\n\n  return {\n    state: {\n      a: '',\n      b: '',\n    },\n    actions: {\n      setA(state, payload) {\n        state.a = payload;\n      },\n      setB(state, payload) {\n        state.a = payload;\n      },\n    },\n    effects: {\n      async loadA() {\n        const res = await mockFetchA();\n        actions.setA(res);\n      },\n      async loadB() {\n        const res = await mockFetchB();\n        actions.setB(res);\n      },\n    },\n  };\n});\n\n\n这样，我们也可以实现代码的简化。","frontmatter":{"sidebar_position":7,"title":"Model 通信"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/model-communicate.mdx","_relativePath":"zh/guides/topic-detail/model/model-communicate.mdx"},{"id":570,"title":"性能优化","routePath":"/guides/topic-detail/model/performance","lang":"zh","toc":[{"text":"Model 拆分","id":"model-拆分","depth":2,"charIndex":90},{"text":"状态筛选","id":"状态筛选","depth":2,"charIndex":893},{"text":"衍生状态缓存","id":"衍生状态缓存","depth":2,"charIndex":1425}],"domain":"","content":"#\n\nReduck 内部已经做了大量性能优化工作，一般情况下不需要考虑性能问题。不过当对性能比较敏感、或者遇到了性能问题，可以考虑从以下 3\n个方面，进行更有针对性的性能优化。\n\n\nModel 拆分#\n\n当 useModel 返回 Model 对象的完整 State 时，State 任意部分的变化都会导致调用了 useModel 的组件重新渲染。\n\n例如：\n\nconst fooModel = model('foo').define({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\nfunction ComponentA() {\n  const [state] = useModel(fooModel);\n\n  return \n{state.a};\n}\n\n\n组件 ComponentA 虽然只需要使用 a 状态，但当 b 状态发送变化时， ComponentA 仍然会重新渲染。这种情况，我们可以考虑把\nfooModel 拆分，a、b 分别由不同的 Model 负责管理：\n\nconst fooModel = model('foo').define({\n  state: {\n    a: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    b: '',\n  },\n  actions: {\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\n\n\n状态筛选#\n\nuseModel 支持传入 selector 函数，对返回给组件的 State 和 Actions 做筛选。我们可以通过 selector\n函数，确保返回给组件的 State 是组件直接需要使用的，从而保证组件不会因为其他无关状态的变化而重新渲染。\n\n对于上面同样的例子，我们采用 selector 函数进行性能优化，代码如下：\n\nconst fooModel = model('foo').define({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\nfunction ComponentA() {\n  // 通过传入 selector 函数，只返回 a 状态给组件\n  const [stateA] = useModel(fooModel, state => state.a);\n\n  return \n{stateA};\n}\n\n\n\n衍生状态缓存#\n\n当 Model 存在 computed 时，每次调用useModel 都会执行 computed 函数。\n\n考虑如下代码：\n\nconst barModel = model('bar').define({\n  state: {\n    value: 'bar',\n  },\n  computed: {\n    combineA: [\n      fooModel, // fooModel 定义同上\n      (state, fooState) => {\n        return state + fooState.a;\n      },\n    ],\n  },\n  actions: {\n    setValue(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\nfunction ComponentB() {\n  const [state, actions] = useModel(fooModel);\n  const [{ combineA }] = useModel(barModel);\n  // 省略\n}\n\n\nbarModel 的衍生状态 combineA 依赖 barModel 自身状态 和 fooModel 的状态 a，但是即使是 fooModel 的状态 b\n发生了变化，组件重新渲染时， combineA （更准确的说法是 combineA 的最后一个函数类型的元素 ）依然会被调用执行。\n\n一般情况下，computed 函数中的逻辑都是非常轻量的，但当 computed 函数逻辑比较复杂时，我们可以考虑对计算逻辑做缓存。例如，我们使用\nreselect 对 barModel 的 combineA 做缓存：\n\n\n\n// 创建缓存函数\nconst selectCombineA = createSelector(\n  (state) => state.bar.value,\n  (state) => state.foo.a,\n  (barState, fooState) => {\n    return barState + fooState;\n  }\n);\n\nconst barModel = model(\"bar\").define({\n  state: {\n    value: \"bar\",\n  },\n  computed: {\n    combineA: [\n      fooModel,\n      (state, fooState) => {\n        return selectCombineA({\n          foo: fooState,\n          bar: state,\n        });\n      },\n    ],\n  },\n  actions: {\n    setValue(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\n\n我们创建缓存函数 createSelector，仅当 barModel 的状态发生改变或 fooModel 的 a 状态发生改变时，才会重新计算\ncombineA 的值。\n\n补充信息\n\n本节完整的示例代码","frontmatter":{"sidebar_position":8,"title":"性能优化"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/performance.mdx","_relativePath":"zh/guides/topic-detail/model/performance.mdx"},{"id":571,"title":"快速上手","routePath":"/guides/topic-detail/model/quick-start","lang":"zh","toc":[{"text":"核心概念","id":"核心概念","depth":2,"charIndex":592},{"text":"基本用法","id":"基本用法","depth":2,"charIndex":868}],"domain":"","content":"#\n\nReduck 是 Modern.js 团队开发的遵循 MVC 模式的状态管理库，底层状态存储基于 Redux 实现，同时提供更高层级的抽象，并完全兼容\nRedux 生态。\n\nReduck 的目标是以 MVC 模式组织 React 应用开发结构，将业务逻辑维护在 Model 层，业务逻辑与 UI\n解耦，让开发业务逻辑更集中、更简单，同时通过更高层级的抽象，减少重复工作（样板代码）。\n\nReduck 在 MVC 模式中，扮演 M(Model) 的角色，React UI Component 对应 V(View)，从 Reduck 中获取\nModel 并修改 Model 的 React Container Component 对应 C(View Controller/Container)。\n\nModern.js 的状态管理解决方案，是通过内置 Reduck 实现的。在 Modern.js 中使用 Reduck，不仅免去了手动集成的环节，而且所有\nReduck API 都可以从 Modern.js 的 Runtime 包中直接导入使用，具有更好的一致性体验。\n\nINFO\n 1. Modern.js 中使用 Reduck API，需要先设置 runtime.state 以启用状态管理插件。\n 2. Reduck 也可以脱离 Modern.js 作为状态管理库单独使用。\n\n\n核心概念#\n\nReduck 中的核心概念只有 4 个： Model、State、Actions、Effects。\n\nModel: 对独立模块的逻辑和所需状态的封装，由 State、Actions、Effects 组成。\n\nState: Model 中保存的状态。\n\nActions: 用于修改 State 的纯函数，函数必须是同步的。\n\nEffects: 用于修改 State 的带有副作用的函数，函数可以是异步的。Effects 中可以调用自身或其他 Model 的 Actions 和\nEffects。\n\nReduck 数据流如下图所示：\n\n\n\n\n基本用法#\n\n下来我们以一个简单的 计数器 应用为例，演示 Reduck 的基本用法。\n\n首先，我们定义一个名为 count 的 Model：\n\n\n\nconst countModel = model('count').define({\n  state: {\n    value: 1,\n  },\n});\n\nexport default countModel;\n\n\n我们使用 API model 创建 countModel，countModel 当前只包含存储计数器值的状态，即代码中的 value。\n\n我们定义一个 action，用于计算器自增加 1：\n\n\n\nconst countModel = model('count').define({\n  state: {\n    value: 1,\n  },\n  actions: {\n    add(state) {\n      state.value += 1;\n    },\n  },\n});\n\nexport default countModel;\n\n\n在 add action 中，我们可以直接修改 state 的值，进行加 1 操作，而不需要把 state 作为不可变对象进行操作，这是因为 Reduck\n集成了 immer，可以直接修改原 state 对象。\n\n接下来，我们演示如何在组件中使用 Model。\n\n新建一个组件 Counter，在组件内通过 useModel API 使用 countModel：\n\n\n\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  return (\n    \n\n      \ncounter: {state.value}\n       actions.add()}>add\n    \n  );\n}\n\n\nuseModel 获取 countModel 的 state 和 actions，组件展示当前计算器的值，点击 add 按钮，计数器自增 1。\n\nINFO\n\n由于使用的案例比较简单，这里并没有严格按照 MVC 模式进行分层，组件 Counter 同时起到了 V 和 C 两层的作用。\n\n最终演示效果如下：\n\n\n\n这样，我们就完了一个简单的计数器应用。本节完整的示例代码可以在这里查看。","frontmatter":{"sidebar_position":1,"title":"快速上手"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/quick-start.mdx","_relativePath":"zh/guides/topic-detail/model/quick-start.mdx"},{"id":572,"title":"Redux 生态集成","routePath":"/guides/topic-detail/model/redux-integration","lang":"zh","toc":[],"domain":"","content":"#\n\nReduck 基于 Redux 实现，因此可以使用 Redux 生态的库，实现功能增强。通过 Provider 、createApp 和 createStore\n等 API ，可以设置使用 Redux 的 中间件 和 Store Enhancer；使用 createStore 还可以完全掌控 Store 的创建过程。\n\n例如，我们希望使用中间件 redux-logger，示例代码如下：\n\nReactDOM.render(\n  \n    // 通过 Provider 的 config 参数设置 中间件\n    \n  ,\n  document.getElementById('root'),\n);\n\n\nCAUTION\n\nReduck 基于 Redux 底层 API 做了上层封装，屏蔽了 Redux 的一些底层概念，如 Reducer 等。Reduck 对于 Model\n是动态挂载的，而 Redux 是在 Store 创建时就会挂载应用所需的全部状态。基于这些实现上的差异，有些 Redux 生态的库是无法直接在 Reduck\n中使用的。","frontmatter":{"sidebar_position":11,"title":"Redux 生态集成"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/redux-integration.mdx","_relativePath":"zh/guides/topic-detail/model/redux-integration.mdx"},{"id":573,"title":"测试 Model","routePath":"/guides/topic-detail/model/test-model","lang":"zh","toc":[],"domain":"","content":"#\n\n好的测试对代码的稳健性至关重要。下面以 快速上手 的 countModel 为例，演示在 Modern.js 中，如何对 Model 进行单元测试。\n\n使用测试功能，需要先开启该功能。在项目根目录下，执行 pnpm run new，进行如下选择：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用「单元测试 / 集成测试」功能\n\n\n即可开启测试功能支持。\n\n新增 count.test.ts 文件，代码如下：\n\n\n\n\ndescribe('test model', () => {\n  it('count value should plus one after add', () => {\n    const store = createStore();\n    const [state, { add }] = store.use(countModel);\n\n    expect(state).toEqual({ value: 1 });\n\n    add();\n\n    expect(store.use(countModel)[0]).toEqual({ value: 2 });\n  });\n});\n\n\nINFO\n\n这里使用的 createStore 是从 @modern-js/runtime/testing 导入的，内部会使用 runtime.state 的配置去创建\nstore。\n\n在测试用例里，我们新建一个 store 来挂载 countModel，通过 store.use 获取 countModel 的 State 和\nActions。然后调用 add Action 更新状态，并断言更新后的状态值。\n\n执行 pnpm run test 命令，触发测试用例的执行。","frontmatter":{"sidebar_position":9,"title":"测试 Model"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/test-model.mdx","_relativePath":"zh/guides/topic-detail/model/test-model.mdx"},{"id":574,"title":"TS 最佳实践","routePath":"/guides/topic-detail/model/typescript-best-practice","lang":"zh","toc":[{"text":"定义 Model 的 State 类型","id":"定义-model-的-state-类型","depth":2,"charIndex":87},{"text":"衍生状态的依赖类型","id":"衍生状态的依赖类型","depth":2,"charIndex":711},{"text":"获取 Model 类型信息的 Hooks","id":"获取-model-类型信息的-hooks","depth":2,"charIndex":1010}],"domain":"","content":"#\n\nReduck 对 TS 提供了良好的支持，大部分使用场景下，无需任何额外工作，就可以直接获得 API 的 TS\n类型提示。本节，将对其他的一些使用场景，做补充介绍。\n\n\n定义 Model 的 State 类型#\n\n为 Model 的 State 声明类型信息，是在 TS 中使用 Reduck 的最佳实践。\n\ninterface State {\n  data: string;\n}\n\nexport const foo = model('foo').define({\n  state: {\n    data: '',\n  },\n  computed: {\n    withSuffix: state => state.data + 'suffix',\n  },\n  actions: {\n    setData: (state, payload: string) => {\n      state.data = payload;\n    },\n  },\n});\n\n\n当为 Model 的 State 声明类型信息后，Model 的 computed、actions\n都能获取正确的类型信息。事实上，上面的示例代码中，即使我们不定义 State 类型信息，也会根据 state 的初始值信息自动推导出 State\n的类型信息。不过，仍然建议你在定义 Model 时，声明 State 的类型信息，因为根据 state 的初始值信息推导出的 State\n类型信息可能不完整(缺少字段或字段的类型信息缺少)，而且当使用函数类型定义 Model 时，State 的类型信息也是无法根据 state\n的初始值信息自动推导的。\n\n\n衍生状态的依赖类型#\n\n当 Model 的衍生状态依赖其他 Model 时，需要手动指定其他 Model 的 State。\n\ninterface State {\n  data: string;\n}\n\nexport const bar = model('bar').define({\n  state: {\n    data: '',\n  },\n  computed: {\n    // 为 fooState 指定类型\n    withFoo: [foo, (state, fooState: FooState) => state.data + fooState.data],\n  },\n});\n\n\n\n获取 Model 类型信息的 Hooks#\n\nReduck 提供了一组用于获取 Model 类型信息的工具类型：\n\n * GetModelState： 获取 Model 的 State（包含衍生状态）类型信息。\n * GetModelActions：获取 Model 的 Actions（包含 Effects 函数）类型信息。\n\nexport const foo = model('foo').define({\n  // 省略\n});\n\n// 获取 foo 的 State 类型\nlet fooActions: GetModelActions;\n// 获取 foo 的 Actions 类型\nlet fooState: GetModelState;\n","frontmatter":{"sidebar_position":10,"title":"TS 最佳实践"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/typescript-best-practice.mdx","_relativePath":"zh/guides/topic-detail/model/typescript-best-practice.mdx"},{"id":575,"title":"使用 Model","routePath":"/guides/topic-detail/model/use-model","lang":"zh","toc":[{"text":"在组件内使用","id":"在组件内使用","depth":2,"charIndex":3},{"text":"作为全局状态使用","id":"作为全局状态使用","depth":3,"charIndex":13},{"text":"作为静态状态使用","id":"作为静态状态使用","depth":3,"charIndex":1768},{"text":"作为局部状态使用","id":"作为局部状态使用","depth":3,"charIndex":2899},{"text":"在组件外使用","id":"在组件外使用","depth":2,"charIndex":3418}],"domain":"","content":"#\n\n\n在组件内使用#\n\n\n作为全局状态使用#\n\n通过 useModel 可以获取 Model 的 State、Actions 等。当 Model 的 State 通过 Actions\n进行修改后，任何其他使用了该 Model 的组件，都会自动重新渲染。\n\n在 快速上手 的计数器案例中，我们已经演示了 useModel 的使用，不再重复。\n\nuseModel 支持传入多个 Model，多个 Model 的 State 和 Actions 会进行合并后作为返回结果。例如：\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 1,\n  },\n  actions: {\n    add(state) {\n      state += 1;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    title: 'bar',\n  },\n  actions: {\n    set(state, payload) {\n      state.title = payload;\n    },\n  },\n});\n\nconst [state, actions] = useModel([fooModel, barModel]);\n// 或\nconst [state, actions] = useModel(fooModel, barModel);\n\n\nstate 和 actions 的值分别为：\n\nstate = {\n  value: 1,\n  title: 'bar',\n};\n\nactions = {\n  add(state) {\n    state += 1;\n  },\n  set(state, payload) {\n    state.title = payload;\n  },\n};\n\n\nuseModel 还支持对 State 和 Actions 做 selector 操作，实现对 State 和 Actions 的筛选或重命名，例如：\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 1,\n  },\n  actions: {\n    add(state) {\n      state += 1;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    value: 'bar',\n  },\n  actions: {\n    set(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\nconst [state, actions] = useModel(\n  [fooModel, barModel],\n  (fooState, barState) => ({\n    fooValue: fooState.value,\n    barValue: barState.value,\n  }), // stateSelector\n  (fooActions, barActions) => ({ add: fooActions.add }), // actionsSelector\n);\n\n\n我们通过 stateSelector ，把 fooModel 和 barModel 中重名的状态做了命名修改，通过 actionsSelector ，过滤掉了\nbarModel 的 Actions。\n\n如果只需要设置 actionsSelector，可以把 stateSelector 设置为 undefined，作为参数占位。例如：\n\nconst [state, actions] = useModel(\n  [fooModel, barModel],\n  undefined,\n  (fooActions, barActions) => ({ add: fooActions.add }), // actionsSelector\n);\n\n\n\n作为静态状态使用#\n\n通过 useStaticModel 获取 Model ，将 Model 中的状态作为静态状态使用。可以保证组件每次访问到的 Model 的 State\n都是最新值，但是 Model 的 State 的变化，并不会引起当前组件的重新渲染。\n\nINFO\n\nuseStaticModel 的使用方式和 useModel 完全一致。\n\n考虑下面一种场景，有一个组件 Input 负责用户输入，另外一个组件 Search\n负责根据用户的输入信息，在点击查询按钮后执行查询操作，我们不希望用户输入过程中的状态变化引起 Search 重新渲染，这时候就可以使用\nuseStaticModel：\n\n\n\nfunction Search() {\n  // 这里注意不要解构 state\n  const [state] = useStaticModel(searchModel);\n\n  return (\n    \n\n       {\n          const result = await mockSearch(state.input);\n          console.log(result);\n        }}\n      >\n        Search\n      \n    \n  );\n}\n\n\n注意\n\n不要解构 useStaticModel 返回的 state，例如改成如下写法： const [{input}] =\nuseStaticModel(searchModel); 将始终获取到 Input 的初始值。\n\nuseStaticModel 还适合和 react-three-fiber 等动画库一起使用，因为在动画组件 UI\n里绑定会快速变化的状态，容易引起性能问题。这种情况就可以选择使用\nuseStaticModel，它只会订阅状态，但不会引起视图组件的重新渲染。下面是一个简化示例：\n\nfunction ThreeComponent() {\n  const [state, actions] = useStaticModel(modelA);\n\n  useFrame(() => {\n    state.value; // 假设初始化为 0\n    actions.setValue(1);\n    state.value; // 这里会得到1\n  });\n}\n\n\n使用 React 的 refs 也可以实现类似效果，其实 useStaticModel 内部也使用到了 refs。不过直接 useStaticModel\n有助于将状态的管理逻辑从组件中解耦，统一收敛到 Model 层。\n\n完整的示例代码可以在这里查看。\n\n\n作为局部状态使用#\n\n通过 useLocalModel 获取 Model ，将 Model 中的状态作为局部状态使用。此时 Model State\n的变化，只会引起当前组件的重新渲染，但是不会引起其他使用了该 Model 的组件重新渲染。效果和通过 React 的 useState\n管理状态类似，但是可以将状态的管理逻辑从组件中解耦，统一收敛到 Model 层。\n\nINFO\n\nuseLocalModel 的使用方式和 useModel 完全一致。\n\n例如，我们修改计数器应用的代码，添加一个有局部状态的计数器组件 LocalCounter：\n\n\n\nfunction LocalCounter() {\n  const [state, actions] = useLocalModel(countModel);\n\n  return (\n    \n\n      \nlocal counter: {state.value}\n       actions.add()}>add\n    \n  );\n}\n\n\n分别点击 Counter 和 LocalCounter 的 add 按钮，两者的状态互不影响：\n\n\n\n完整的示例代码可以在这里查看。\n\n\n在组件外使用#\n\n在实际业务场景中，有时候我们需要在 React 组件外使用 Model，例如在工具函数中访问 State、执行 Actions 等。这个时候，我们就需要使用\nStore。 Store 是一个底层概念，一般情况下用户接触不到，它负责存储和管理整个应用的状态。Reduck 的 Store 基于 Redux 的 Store\n实现，增加了 Reduck 特有的 API，如 use 。\n\n首先，在组件内调用 useStore 获取当前应用使用的 store 对象，并挂载到组件外的变量上：\n\nlet store; // 组件外部 `store` 对象的引用\nfunction setStore(s) {\n  store = s;\n}\nfunction getStore() {\n  return store;\n}\n\nfunction Counter() {\n  const [state] = useModel(countModel);\n  const store = useStore();\n  // 通过 useMemo 避免不必要的重复设置\n  useMemo(() => {\n    setStore(store);\n  }, [store]);\n\n  return (\n    \n\n      \ncounter: {state.value}\n    \n  );\n}\n\n\n通过 store.use 可以获取 Model 对象，store.use 的用法同 useModel 相同。以计数器应用为例，我们在组件树外，每 1s\n对计数器值 执行自增操作：\n\nsetInterval(() => {\n  const store = getStore();\n  const [, actions] = store.use(countModel);\n  actions.add();\n}, 1000);\n\n\n完整的示例代码可以在这里查看。\n\nINFO\n\n如果是通过 createStore 手动创建的 Store 对象，无需通过 useStore 在组件内获取，即可直接使用。\n\n补充信息\n\n本节涉及的 API 的详细定义，请参考这里。","frontmatter":{"sidebar_position":3,"title":"使用 Model"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/use-model.mdx","_relativePath":"zh/guides/topic-detail/model/use-model.mdx"},{"id":576,"title":"单独使用 Reduck","routePath":"/guides/topic-detail/model/use-out-of-modernjs","lang":"zh","toc":[],"domain":"","content":"#\n\n在 Modern.js 以外，单独集成 Reduck 使用时，主要需要做以下修改：\n\n 1. 安装 Reduck 相关包\n\n在项目中安装 Reduck 包：@modern-js-reduck/react。\n\n 2. API 导入包名\n\n在 Modern.js 中使用时，Reduck 导出 API 的包名为：@modern-js/runtime/model。单独使用 Reduck\n时，导出包名为：@modern-js-reduck/react。\n\n 3. 包裹 Provider 组件\n\nModern.js 自动在应用的入口组件上，包裹了用于注入 Reduck 全局 Store 的 Provider 组件。单独使用 Reduck\n时，需要手动完成。\n\n示例：\n\n// 根组件\nconst Root = () => {\n  return (\n    \n      {/* 应用入口组件 */}\n      \n    \n  );\n};\n\n\n 4. 功能配置\n\n在 Modern.js 中使用时，可以通过 runtime.state 对 Reduck 功能进行配置。单独使用时，需要通过 Provider 的 config\n或 store 参数配置。\n\n示例：\n\nconst Root = () => {\n  return (\n    {/* 关闭 Redux DevTools */}\n    \n      \n    \n  )\n}\n","frontmatter":{"sidebar_position":12,"title":"单独使用 Reduck"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/model/use-out-of-modernjs.mdx","_relativePath":"zh/guides/topic-detail/model/use-out-of-modernjs.mdx"},{"id":577,"title":"创建子项目","routePath":"/guides/topic-detail/monorepo/create-sub-project","lang":"zh","toc":[],"domain":"","content":"#\n\n本章将要介绍如何在 Monorepo 工程下创建子项目。\n\n> Modern.js 支持使用 pnpm 和 Yarn 的 Monorepo，这里以使用 pnpm 为例。以下命令可以以同样方式使用 Yarn 来执行。\n\nModern.js 针对 Monorepo 工程提供了生成器功能，它用于在 Monorepo 工程下创建不同类型的 Monorepo\n子项目。在生成器中提供以下类型子项目的创建：\n\n * 「应用」类型\n * 「模块」类型\n\n要启动 Monorepo 的生成器功能，可以在 Monorepo 工程根目录下执行命令：\n\npnpm run new\n\n\n补充信息\n\n使用 Yarn 的方式：yarn new\n\n执行成功后，可以看到如下内容：\n\n? 请选择你想创建的工程类型 (Use arrow keys)\n❯ Web 应用\n  Web 应用（测试）\n  Npm 模块\n  Npm 模块（内部）\n\n\nINFO\n\n「应用」与「应用（测试）」都是「应用」类型的项目，区别是「应用」类型的子项目会创建在 ./apps 目录下，而 「应用（测试）」类型的子项目会创建在\n./examples 目录下。\n\nINFO\n\n「模块」与「模块（内部）」都是「模块」类型的项目，区别之一是「模块」类型的子项目会创建在 ./packages 目录下，而「模块（内部）」类型的子项目会创建在\n./features 目录下。\n\n对于「模块」类型的子项目允许被发布到外部（例如\nnpm)，而对于「模块（内部）」的子项目则可以在应用项目中直接使用其源码（该特性是「模块」项目不具备的，应用项目对于「模块（内部）」子项目做了特殊处理），因此这\n类子项目不需要发布到外部。\n\n然后根据不同的需求选择对应的类型项目选项，选择之后便开始出现对应子项目类型的问题和选项。例如选择「应用」后会出现：\n\n? 请选择你想创建的工程类型：Web应用\n? 请填写子项目名称\n\n\n当完成所有生成器问题之后，便开始进行项目的创建和项目依赖的下载。当创建成功之后，可以看到类似以下内容：\n\n[INFO] 依赖自动安装成功\n[INFO] 创建成功！\n可在新项目的目录下运行以下命令：\npnpm run dev          # 启动开发服务器\npnpm run build        # 构建生产环境产物\npnpm run serve        # 启动生产环境服务\npnpm run lint         # 运行 ESLint 并自动修复问题\npnpm run new          # 启用可选功能或创建项目要素\n","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/monorepo/create-sub-project.mdx","_relativePath":"zh/guides/topic-detail/monorepo/create-sub-project.mdx"},{"id":578,"title":"Monorepo 工程介绍","routePath":"/guides/topic-detail/monorepo/intro","lang":"zh","toc":[],"domain":"","content":"#\n\nModern.js 提供了对于 Monorepo 工程方案的支持，其主要通过 @modern-js/monorepo-tools 来提供功能。\n\n该专题将从以下方面来讲解如何使用 Modern.js 对 Monorepo 进行管理：\n\n * 在 Monorepo 中创建子项目\n * Monorepo 下子项目之间的联调开发\n * 发布 Monorepo 的子项目\n * 部署 Monorepo 子项目","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/monorepo/intro.mdx","_relativePath":"zh/guides/topic-detail/monorepo/intro.mdx"},{"id":579,"title":"可复用模块的发布","routePath":"/guides/topic-detail/monorepo/publish","lang":"zh","toc":[{"text":"准备工作","id":"准备工作","depth":2,"charIndex":74},{"text":"生成变更记录","id":"生成变更记录","depth":2,"charIndex":121},{"text":"版本更新","id":"版本更新","depth":2,"charIndex":1740},{"text":"发布","id":"发布","depth":2,"charIndex":1979}],"domain":"","content":"#\n\n在 Monorepo 中有时会需要把多个模块项目发布到 NPM 上，本章将要介绍如果在 Monorepo 中对子项目进行版本更新以及发布。\n\n\n准备工作#\n\n接着 子项目联调 章节的例子，我们对 components 模块进行发布。\n\n\n生成变更记录#\n\n在开发阶段，当某个模块的功能开完完成之后，一般需要提交代码（例如提交到 GitHub 上）并需要记录本次修改的内容。在 Modern.js 的 Monorepo\n工程中，我们可以在 monorepo 根目录执行命令：\n\npnpm run change\n\n\n然后根据提示选择变更或者将要发布的包以及选择包升级的版本，并填写变更信息。变更信息的内容可以包含此次开发的功能、修复的问题等。\n\n那么对于上面的例子，我们选择变更的项目为 components，并填写此次变更的内容：\n\n$ modern change\n🦋  Which packages would you like to include? · components\n🦋  Which packages should have a major bump? · No items were selected\n🦋  Which packages should have a minor bump? · components\n🦋  Please enter a summary for this change (this will be in the changelogs). Submit empty line to open external editor\n🦋  Summary · add features\n🦋  === Releasing the following packages ===\n🦋  [Minor]\n🦋    components\n🦋  ╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗\n🦋  ║                                                      ========= NOTE ========                                                       ║\n🦋  ║All dependents of these packages that will be incompatible with the new version will be patch bumped when this changeset is applied.║\n🦋  ╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝\n🦋  Is this your desired changeset? (Y/n) · true\n🦋  Changeset added! - you can now commit it\n🦋\n🦋  If you want to modify or expand on the changeset summary, you can find it here\n🦋  info /Users/demo/modern-js/official/monorepo-pnpm/.changeset/silent-tigers-run.md\n\n\n该命令完成后，在 .changeset 中会有新的 silent-tigers-run.md\n文件生成，其中包含了刚刚填写的信息，这些新生成的文件将用于后面发布流程中使用。因此在提交代码的时候，需要将.changeset 目录下的文件一并提交。\n\n\n版本更新#\n\n在模块发布之前，还需要将模块的版本进行更新。。在 Modern.js 的 Monorepo 工程中，可以在 Monorepo 项目根目录下执行：\n\npnpm run bump\n\n\n该命令会根据之前生成在 .changeset 目录下的文件自动更新对应模块的版本号和 CHANGELOG 信息，执行成功后会看到：\n\n🦋  All files have been updated. Review them and commit at your leisure\n\n\n\n发布#\n\n最后执行 pnpm run prepare --filter {./packages} && pnpm run release，便可以发布对应的模块了。\n\n补充信息\n\n在上面的命令中 --filter {./packages} 用于筛选位于 ./packages 目录下的子项目，可以通过 PNPM Filtering\n来了解更多它的使用。","frontmatter":{"sidebar_position":4},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/monorepo/publish.mdx","_relativePath":"zh/guides/topic-detail/monorepo/publish.mdx"},{"id":580,"title":"子项目联调","routePath":"/guides/topic-detail/monorepo/sub-project-interface","lang":"zh","toc":[{"text":"准备工作","id":"准备工作","depth":2,"charIndex":38},{"text":"在使用 pnpm 的 Monorepo 中进行项目联调","id":"在使用-pnpm-的-monorepo-中进行项目联调","depth":2,"charIndex":1351},{"text":"在使用 Yarn 的 Monorepo 中进行项目联调","id":"在使用-yarn-的-monorepo-中进行项目联调","depth":2,"charIndex":2001}],"domain":"","content":"#\n\n本章将要介绍如何在 Monorepo 下进行子项目之间的联调使用。\n\n\n准备工作#\n\n按照 「创建子项目」 章节的介绍（如果还没有看过，可以先了解一下），我们首先创建以下三个子项目：\n\n * 一个「应用」子项目\n * 一个「模块（内部）」子项目\n * 一个「模块」子项目\n\n执行 pnpm run new，并按照如下进行选择：\n\n「应用」子项目：\n\n? 请选择你想创建的工程类型：Web 应用\n? 请填写子项目名称：app\n? 请填写子项目目录名称：app\n? 请选择开发语言：TS\n\n\n「模块（内部）」子项目：\n\n? 请选择你想创建的工程类型：Npm 模块（内部）\n? 请填写子项目名称：internal-lib\n? 请填写子项目目录名称：internal-lib\n? 请选择开发语言：TS\n\n\n「模块」子项目：\n\n? 请选择你想创建的工程类型：Npm 模块\n? 请填写子项目名称：components\n? 请填写子项目目录名称：components\n? 请选择开发语言：TS\n\n\n创建成功后，会得到以下项目：\n\n * ./apps/app\n * ./packages/components\n * ./features/internal-lib\n\n然后修改一下默认的代码和新增文件：\n\n重命名 ./pakcages/components/src/index.tsx\n\nimport './index.css';\n\nexport default function ({ text }: { text: string }) {\n  return (\n    \n\n      This is UI Components Log: \n\n{text}\n    \n  );\n}\n\n\n新增 ./pakcages/components/src/index.css\n\n.log {\n  color: gray;\n}\n\n\n修改 ./features/internal-lib/src/index.ts\n\nexport default function (text: string) {\n  return text.toUpperCase();\n}\n\n\n修改 ./apps/app/src/App.tsx\n\n\n\n\n\nimport './App.css';\n\nconst App = () => (\n  \n    \n      \n\n        \n        {/* 省略... */}\n      \n    \n    \n      \n404\n    \n  \n);\n\nexport default App;\n\n\n到此为止我们创建了一个可以被发布到外部的组件项目、一个转换字符串的内部模块项目以及一个使用组件和内部模块的应用项目，如果直接运行应用项目还暂时无法正常使用。接下\n来将要介绍如何让它们能够互相联调使用，成功的使应用子项目 apps/app 正常运行。\n\nINFO\n\n启动 apps/app 项目之前需要先构建（pnpm run build） packages/component。\n\n由于 Modern.js 支持 pnpm 与 Yarn 的 Monorepo 工程，接下来会从这两个方面分别介绍。\n\n\n在使用 pnpm 的 Monorepo 中进行项目联调#\n\n在 pnpm 的 Monorepo 项目中，我们通过在 apps/app 子项目下分别执行：\n\npnpm add components\n\n\n以及\n\npnpm add internal-lib -D\n\n\nINFO\n\n注意这里将 internal-lib 作为 apps/app 项目的开发依赖，因为在构建环境会被打包到构建产物中。\n\n将 packages/components 与 features/internal-lib 子项目加入到应用的依赖列表当中。\n\n执行成功后，在 apps/app/package.json 会发生如下变化：\n\n{\n  \"dependencies\": {\n++  \"components\": \"workspace:^0.1.0\"\n  },\n  \"devDependencies\": {\n++  \"internal-lib\": \"workspace:^0.1.0\"\n  },\n}\n\n\n补充信息\n\nworkspace:^0.1.0 是一种 PNPM 提供的 Workspace 协议。\n\n当依赖安装成功之后，我们还需要将 packages/components 进行构建，因为需要使用其构建产物。\n\n到此为止，app/apps 应用子项目可以正常的运行了。在修改 features/internal-lib 的源码，或者修改\npackages/components 的源码并构建之后都会触发应用子项目的热更新。\n\n\n在使用 Yarn 的 Monorepo 中进行项目联调#\n\n在 Yarn 的 Monorepo 项目中，默认情况下可以直接在 apps/app 应用项目中直接使用组件项目和内部模块项目。\n\n补充信息\n\n之所以可以直接在应用中使用使用组件项目和内部模块项目，是因为 Yarn 将这些子项目模块提升到了顶层的 node_modules内。\n\n但是由于组件 components 是非内部模块，因此建议在 apps/app/package.json 中进行依赖声明：\n\n{\n  \"dependencies\": {\n++  \"components\": \"0.1.0\"\n  },\n}\n","frontmatter":{"sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/topic-detail/monorepo/sub-project-interface.mdx","_relativePath":"zh/guides/topic-detail/monorepo/sub-project-interface.mdx"},{"id":581,"title":"构建相关问题","routePath":"/guides/troubleshooting/builder","lang":"zh","toc":[{"text":"通用类问题","id":"通用类问题","depth":2,"charIndex":28},{"text":"功能类问题","id":"功能类问题","depth":2,"charIndex":177},{"text":"异常类问题","id":"异常类问题","depth":2,"charIndex":304},{"text":"热更新问题","id":"热更新问题","depth":2,"charIndex":491}],"domain":"","content":"#\n\n如果你遇到了构建相关的问题，可以参考以下文档：\n\n\n通用类问题#\n\n请参考 「Modern.js Builder - 通用类问题」，其中包含一些概念类的通用问题，比如：\n\n * Modern.js Builder 和 Modern.js 的关系？\n * Builder 能否用于构建工具库或组件库？\n * Builder 是否会接入 Vite？\n\n\n功能类问题#\n\n请参考 「Modern.js Builder - 功能类问题」，其中包含一些常见构建功能的介绍，比如：\n\n * 如何配置组件库按需引入？\n * 如何在编译过程中进行 ESLint 代码校验？\n * 如何配置静态资源的 CDN 路径？\n\n\n异常类问题#\n\n请参考 「Modern.js Builder - 异常类问题」，其中包含一些常见构建问题的处理方法，比如：\n\n * webpack 编译出现 'compilation' argument 报错？\n * 编译时报错 You may need additional loader？\n * 打开页面后报错，提示 exports is not defined？\n\n\n热更新问题#\n\n请参考 「Modern.js Builder - 热更新问题」，比如：\n\n * 打包时 external React 后，热更新不生效？\n * 开发环境设置文件名的 hash 后，热更新不生效？\n * React 组件的热更新无法生效？","frontmatter":{"sidebar_position":3},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/troubleshooting/builder.mdx","_relativePath":"zh/guides/troubleshooting/builder.mdx"},{"id":582,"title":"命令行问题","routePath":"/guides/troubleshooting/cli","lang":"zh","toc":[{"text":"使用 pnpm 时无法正确传递命令行参数？","id":"使用-pnpm-时无法正确传递命令行参数？","depth":3,"charIndex":3}],"domain":"","content":"#\n\n\n使用 pnpm 时无法正确传递命令行参数？#\n\npnpm v6 和 pnpm v7 版本在执行命令时使用姿势不完全一致，需要注意以下事项：\n\npnpm v7：\n\n在使用 pnpm 调用 package.json 中的命令时，如果需要传递参数至 pnpm，需要将参数放到命令前。\n\n例如使用 pnpm --filter 参数执行 prepare 命令：\n\npnpm run --filter \"./packages/**\" prepare\n\n\n如果需要传递参数至命令，需要将参数放到命令后。\n\n例如，在如下 package.json 配置中：\n\n{\n  \"scripts\": {\n    \"command\": \"modern command\"\n  }\n}\n\n\n执行 command 命令时携带参数方式为：\n\npnpm run command --options\n\n\npnpm v6:\n\n在如下 package.json 配置中：\n\n{\n  \"scripts\": {\n    \"command\": \"modern command\"\n  }\n}\n\n\n当需要执行 modern command --option：\n\n使用 pnpm 时，需要执行 pnpm run command -- --option。\n\n这是因为 pnpm 对于命令参数的处理与 Yarn 并不相同，但是与 npm 类似：在不加 -- 字符串的时候，传递的是 pnpm 的参数；在使用 --\n字符串的时候，传递的是执行脚本的参数。\n\n在上述例子里参数 --option 传递给了 modern command。如果执行 pnpm run command --option，则参数\n--option 将传递给 pnpm。\n\n总结来说：\n\n在使用 pnpm v7 时，如果传递参数给 pnpm，需要将参数放置到命令前。\n\n在使用 pnpm v6 时，如果传递的参数给 pnpm，不需要加 --；如果传递的参数是给脚本使用，需要增加 -- 字符串。","frontmatter":{"sidebar_position":2},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/troubleshooting/cli.mdx","_relativePath":"zh/guides/troubleshooting/cli.mdx"},{"id":583,"title":"依赖安装问题","routePath":"/guides/troubleshooting/dependencies","lang":"zh","toc":[{"text":"如何查看项目里某个依赖实际安装的版本？","id":"如何查看项目里某个依赖实际安装的版本？","depth":3,"charIndex":3},{"text":"安装依赖时提示 The engine \\\"node\\\" is incompatible？","id":"安装依赖时提示-the-engine-\\\"node\\\"-is-incompatible？","depth":3,"charIndex":-1},{"text":"升级依赖后出现 ReactNode 类型错误？","id":"升级依赖后出现-reactnode-类型错误？","depth":3,"charIndex":1050},{"text":"执行 pnpm install 之后，控制台出现 peer dependencies 相关 warning？","id":"执行-pnpm-install-之后，控制台出现-peer-dependencies-相关-warning？","depth":3,"charIndex":1692},{"text":"Modern.js 框架最低支持的 React 版本是多少？","id":"modernjs-框架最低支持的-react-版本是多少？","depth":3,"charIndex":1968}],"domain":"","content":"#\n\n\n如何查看项目里某个依赖实际安装的版本？#\n\n可以使用包管理器自带的 ls 命令来查看项目里依赖的版本。\n\n下面是一些基本的示例，详细用法请查看各个包管理器的文档。\n\nnpm / yarn\n\n对于使用 npm 或 yarn 的项目，可以使用 npm ls 命令。\n\n比如执行 npm ls @modern-js/core，可以看到如下结果：\n\nproject\n└─┬ @modern-js/app-tools@2.0.0\n  └── @modern-js/core@2.0.0\n\n\npnpm\n\n对于使用 pnpm 的项目，可以使用 pnpm ls 命令。\n\n比如执行 pnpm ls @modern-js/core --depth Infinity，可以看到如下结果：\n\ndevDependencies:\n@modern-js/app-tools 2.0.0\n└── @modern-js/core 2.0.0\n\n\n--------------------------------------------------------------------------------\n\n\n安装依赖时提示 The engine \"node\" is incompatible？#\n\n安装依赖时如果出现以下报错提示，说明当前环境使用的 Node.js 版本过低，需要升级 Node.js 到更高版本。\n\nThe engine \"node\" is incompatible with this module.\n\nExpected version \">=14.17.6\". Got \"12.20.1\"\n\n\n使用 Modern.js 时，建议使用 Node.js 14.x 或 Node.js 16.x 的最新版本。\n\n如果当前环境的 Node.js 版本低于上述要求的版本，则可以使用 nvm 或 fnm 等工具进行版本切换。\n\n下面是使用 nvm 的示例：\n\n# 安装 Node.js v14\nnvm install 14\n\n# 切换到 Node 14\nnvm use 14\n\n# 将 Node 14 设置为默认版本\nnvm default 14\n\n\n在本地开发环境推荐使用 fnm，它的用法与 nvm 相似，但拥有比 nvm 更好的性能。\n\n--------------------------------------------------------------------------------\n\n\n升级依赖后出现 ReactNode 类型错误？#\n\n升级项目的依赖后，如果出现以下类型报错，说明项目中安装了错误的 @types/react 版本。\n\nThe types returned by 'render()' are incompatible between these types.\nType 'React.ReactNode' is not assignable to type 'import(\"/node_modules/@types/react/index\").ReactNode'.\nType '{}' is not assignable to type 'ReactNode'.\n\n\n出现这个问题的原因是 React 18 与 React 16/17 中的 ReactNode 类型定义不同，如果项目中出现多个不同 @types/react\n版本，就会出现 ReactNode 类型冲突，导致以上报错。\n\n解决方法为将项目中的 @types/react 和 @types/react-dom 锁定在统一的版本上，比如 v17。\n\n{\n  \"@types/react\": \"^17\",\n  \"@types/react-dom\": \"^17\"\n}\n\n\n关于锁定依赖版本的方法，请参考 锁定子依赖。\n\n--------------------------------------------------------------------------------\n\n\n执行 pnpm install 之后，控制台出现 peer dependencies 相关 warning？#\n\n出现该警告的原因是，某些三方 npm 包声明的 peer dependencies 版本范围与 Modern.js 中安装的版本范围不一致。\n\n绝大多数情况下，peer dependencies 的警告不会影响项目运行，不需要额外进行处理，请忽略相关 warning。\n\n--------------------------------------------------------------------------------\n\n\nModern.js 框架最低支持的 React 版本是多少？#\n\nModern.js 框架推荐使用的 React 版本为 >= 18.0.0，并且不同功能对 React 版本的要求有所不同。\n\n * 如果你在使用 React 17，那么部分框架功能将无法使用，比如 Steaming SSR，因为它依赖 React 18 提供的新特性。\n * 如果你仍然在使用 React 16，那么将无法使用 Modern.js 的运行时或服务端能力。你可以考虑使用 Modern.js 的构建模式，即只使用\n   Modern.js 的构建能力，这种情况可以继续使用 React 16。\n\n在 Modern.js 未来的 major 版本中，我们会逐步移除对 React 16 和 React 17 的支持。因此，请尽快升级到 React 18\n以上版本。","frontmatter":{"sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/guides/troubleshooting/dependencies.mdx","_relativePath":"zh/guides/troubleshooting/dependencies.mdx"},{"id":585,"title":"创建项目","routePath":"/tutorials/first-app/c01-start","lang":"zh","toc":[{"text":"环境准备","id":"环境准备","depth":2,"charIndex":65},{"text":"Node.js","id":"nodejs","depth":3,"charIndex":73},{"text":"pnpm","id":"pnpm","depth":3,"charIndex":625},{"text":"初始化项目","id":"初始化项目","depth":2,"charIndex":716},{"text":"调试项目","id":"调试项目","depth":2,"charIndex":1453},{"text":"修改代码","id":"修改代码","depth":2,"charIndex":1723},{"text":"开启 SSR","id":"开启-ssr","depth":2,"charIndex":2570}],"domain":"","content":"#\n\n从这一章节开始，我们将进入实战教程部分。在实战教程中，我们将会从环境准备开始，从简单到复杂，一步一步搭建一个真实的项目。\n\n\n环境准备#\n\n\nNode.js#\n\n在开始使用前，你需要安装 Node.js，并保证 Node.js 版本不低于 14.17.6，我们推荐使用 Node.js 16 的 LTS 版本。\n\n你可以通过以下命令检查当前使用的 Node.js 版本：\n\nnode -v\n# v16.19.1\n\n\n如果你当前的环境中尚未安装 Node.js，或是安装的版本低于 14.17.6，可以通过 nvm 或 fnm 安装需要的版本。\n\n下面是通过 nvm 安装 Node.js 16 LTS 版本的例子：\n\n# 安装 Node.js 16 的长期支持版本\nnvm install 16 --lts\n\n# 将刚安装的 Node.js 16 设置为默认版本\nnvm alias default 16\n\n# 切换到刚安装的 Node.js 16\nnvm use 16\n\n\nnvm 和 fnm\n\nnvm 和 fnm 都是 Node.js 版本管理工具。相对来说，nvm 较为成熟和稳定，而 fnm 是使用 Rust 实现的，比 nvm 提供了更好的性能。\n\n此外，在安装 nvm 或 fnm 后，然后只要仓库根目录下有内容为 lts/gallium 的 .nvmrc 文件，进入这个仓库时就会自动安装或切换到正确的\nNode.js 版本。\n\n\npnpm#\n\n推荐使用 pnpm 来管理依赖：\n\nnpm install -g pnpm@7\n\n\nNOTE\n\nModern.js 同样支持使用 yarn、npm 进行依赖管理。\n\n\n初始化项目#\n\n我们创建新的目录，通过命令行工具初始化项目：\n\nmkdir myapp && cd myapp\nnpx @modern-js/create@latest\n\n\n@modern-js/create 会提供一个可交互的问答界面，根据结果初始化项目，按照默认的选择进行初始化：\n\n? 请选择你想创建的工程类型 Web 应用\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n? 请选择构建工具 webpack\n\n\n在生成项目后，Modern.js 会自动安装依赖、创建 git 仓库。\n\n[INFO] 依赖自动安装成功\n[INFO] git 仓库初始化成功\n[INFO] 创建成功！\n可在新项目的目录下运行以下命令：\npnpm run dev          # 启动开发服务器\npnpm run build        # 构建生产环境产物\npnpm run serve        # 启动生产环境服务\npnpm run lint         # 运行 ESLint 并自动修复问题\npnpm run new          # 启用可选功能或创建项目要素\n\n\n现在，项目结构如下：\n\n.\n├── node_modules\n├── src\n│   ├── modern-app-env.d.ts\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n├── modern.config.ts\n├── package.json\n├── pnpm-lock.yaml\n├── README.md\n└── tsconfig.json\n\n\n\n调试项目#\n\n在项目中执行 pnpm run dev 即可启动项目：\n\n$ pnpm run dev\n\n> modern dev\n\ninfo    Starting dev server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n Client ✔ done in 76.10ms\n\n\n在浏览器中打开 http://localhost:8000/，可以看到页面内容。\n\n\n修改代码#\n\n我们将原本的示例代码删除，替换成一个简单的联系人列表：\n\nconst getAvatar = (users: Array<{ name: string; email: string }>) =>\n  users.map(user => ({\n    ...user,\n    avatar: `https://avatars.dicebear.com/v2/identicon/${user.name}.svg`,\n  }));\n\nconst mockData = getAvatar([\n  { name: 'Thomas', email: 'w.kccip@bllmfbgv.dm' },\n  { name: 'Chow', email: 'f.lfqljnlk@ywoefljhc.af' },\n  { name: 'Bradley', email: 'd.wfovsqyo@gpkcjwjgb.fr' },\n  { name: 'Davis', email: '\"t.kqkoj@utlkwnpwk.nu' },\n]);\n\nfunction App() {\n  return (\n    \n   \n         {mockData.map(({ name, avatar, email }) => (\n           \n * \n              ---\n             {name} ---\n             {email}\n           \n   \n         ))}\n       \n  );\n}\n\nexport default App;\n\n\n删除多余的 css 文件，保持目录没有多余的文件：\n\nrm src/routes/index.css\n\n\n因为框架默认支持 HMR，可以看到 http://localhost:8080/ 里的内容会自动更新为：\n\n\n\n此刻的页面还没有样式。下一章节将展开这部分的内容。\n\n\n开启 SSR#\n\n接下来，我们修改项目中的 modern.config.ts，开启 SSR 能力：\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n  },\n  plugins: [appTools()],\n});\n\n\n重新执行 pnpm run dev，可以发现项目已经在服务端完成了页面渲染。","frontmatter":{"title":"创建项目"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/tutorials/first-app/c01-start.mdx","_relativePath":"zh/tutorials/first-app/c01-start.mdx"},{"id":586,"title":"编写 UI 组件","routePath":"/tutorials/first-app/c02-component","lang":"zh","toc":[],"domain":"","content":"#\n\n上一章节中，我们学习了如何初始化项目，并使用配置修改 Modern.js 的默认行为。\n\n这一章节中，我们继续沿用上一章节的项目代码，继续完善联系人列表。\n\n为了做更好的 UI 展示和交互，我们引入组件库 Antd 来开发，使用 组件来代替原始的列表。先添加依赖：\n\npnpm add antd\n\n\n修改 src/routes/page.tsx，在顶部导入组件：\n\n\n\n\n修改 组件的实现：\n\nfunction App() {\n  return (\n    \n\n       (\n          \n            }\n              title={name}\n              description={email}\n            />\n          \n        )}\n      />\n    \n  );\n}\n\n\n执行 pnpm run dev，查看运行结果：\n\n\n\n可以看到 Ant Design 导出的组件，已经具备了完整的样式。\n\nINFO\n\nModern.js 会自动按需导入 Ant Design 组件需要的 CSS。\n\nNOTE\n\n我们也可以使用其他组件库来实现同样的功能，例如 Arco Design。","frontmatter":{"title":"编写 UI 组件"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/tutorials/first-app/c02-component.mdx","_relativePath":"zh/tutorials/first-app/c02-component.mdx"},{"id":587,"title":"添加样式","routePath":"/tutorials/first-app/c03-css","lang":"zh","toc":[{"text":"使用 CSS 写 JS 组件","id":"使用-css-写-js-组件","depth":2,"charIndex":54},{"text":"使用 Utility","id":"使用-utility","depth":2,"charIndex":1033},{"text":"自定义 Utility Class","id":"自定义-utility-class","depth":2,"charIndex":3111}],"domain":"","content":"#\n\n上一章节中，我们学习了如何使用使用三方库中的组件。\n\n这一章节中，我们将学习如何实现 UI 组件。\n\n\n使用 CSS 写 JS 组件#\n\n首先我们希望自己控制联系人头像的展示，实现这种设计稿：\n\n\n\n假设没有现成的组件可以实现，那就需要自己写些 CSS 了，这里我们使用 styled-components，来实现类似的需求。Modern.js 开箱即用的支持\nstyled-components，既不需要安装依赖，也不需要做任何配置。\n\nstyled-components 通过模块化的方式，避免了传统 CSS 写法上的诸多问题。例如直接在元素的 style 属性上写样式，UI 视觉上的细节也会跟\nUI 结构上的细节和业务逻辑混在一起。或是 classname 需要避免全局空间重名，需要用到命名规范的问题。\n\n在 src/routes/page.tsx 里修改顶部的代码：\n\n\n\n\n添加以下代码：\n\nconst Avatar = styled.img`\n  width: 50px;\n  height: 50px;\n  border: 4px solid #0ef;\n  border-radius: 50%;\n`;\n\n\n修改 List.Item.Meta 的代码：\n\n}\n  title={name}\n  description={email}\n/>\n\n\n执行 pnpm run dev，可以看到预期的运行结果：\n\n\n\n接下来我们做一点重构，为了增强可读性，让代码更容易维护，可以把 Avatar 组件拆分出去。我们在终端执行以下命令，创建新的文件：\n\n把 src/routes/page.tsx 里的 实现删掉，修改为：\n\n\n\n\nsrc/components/Avatar/index.tsx 的内容，修改为：\n\n\n\nconst Avatar = styled.img`\n  width: 50px;\n  height: 50px;\n  border: 4px solid #0ef;\n  border-radius: 50%;\n`;\n\nexport default Avatar;\n\n\n执行 pnpm run dev，运行结果应该是一样的。\n\nINFO\n\n采用目录形式 Avatar/index.tsx 而不是单文件形式 Avatar.tsx\n的原因是，之后可以方便的在目录内部增加子文件，包括专用的资源（图片等）、专用子组件、CSS 文件等。\n\n\n使用 Utility#\n\n我们已经使用 style-components 实现 组件，但当前的 UI 仍然不能让人满意，缺乏专业感，例如列表项内部的布局有点粗糙，很多地方没对齐。\n\n现在，我们自己来实现一个更好的 Item 组件，实现这样的设计稿：\n\n\n\n这次要实现的 UI 更复杂，有内部结构，但另一方面，并没有 组件的很粗的亮蓝色边框这样很特殊的\nUI，都是很常规的水平垂直布局、居中、字体样式等。这种情况下，其实根本没必要写 CSS，有更高效的、跟 styled-components\n互补的实现方式：Utility Class。\n\nModern.js 集成了主流、轻量、通用的 Utility Class 工具库 Tailwind CSS。\n\n执行 pnpm run new，进行如下选择，开启 Tailwind CSS：\n\n? 请选择你想要的操作 启用可选功能\n? 请选择功能名称 启用 「Tailwind CSS」 支持\n\n\n在 modern.config.ts 中注册 Tailwind 插件:\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n  },\n  plugins: [appTools(), tailwindcssPlugin()],\n});\n\n\n在 src/routes/page.tsx 顶部引入 Tailwind CSS 的 css 文件，就可以开始快速实现专业的 UI：\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\n\n\n先创建 Item 组件：\n\n修改 src/routes/page.tsx，把 List 的 render 实现交给 Item 组件：\n\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\n\n\nconst getAvatar = (users: Array<{ name: string, email: string }>) =>\n  users.map(user => ({\n    ...user,\n    avatar: `https://avatars.dicebear.com/v2/identicon/${user.name}.svg`,\n  }));\n\nconst mockData = getAvatar([\n  { name: 'Thomas', email: 'w.kccip@bllmfbgv.dm' },\n  { name: 'Chow', email: 'f.lfqljnlk@ywoefljhc.af' },\n  { name: 'Bradley', email: 'd.wfovsqyo@gpkcjwjgb.fr' },\n  { name: 'Davis', email: '\"t.kqkoj@utlkwnpwk.nu' },\n]);\n\nfunction Index() {\n  return (\n    \n\n       }\n      />\n    \n  );\n}\n\nexport default Index;\n\n\n在父容器的上使用了 Utility Class ，快速实现了最基本的最大宽度、居中等样式。\n\n接下来实现 src/components/Item/index.tsx：\n\n\n\ntype InfoProps = {\n  avatar: string;\n  name: string;\n  email: string;\n  archived?: boolean;\n};\n\nconst Item = ({ info }: { info: InfoProps }) => {\n  const { avatar, name, email, archived } = info;\n  return (\n    \n\n      \n      \n\n        \n\n          \n\n{name}\n          \n\n{email}\n        \n        \n          Archive\n        \n      \n    \n  );\n};\n\nexport default Item;\n\n\n执行 pnpm run dev，可以看到预期的运行结果：\n\n\n\n我们只使用了少量 Utility Class，比如 Flex、Padding、Margin、Text、Font、Border，不写一行 CSS\n就实现了符合设计稿的专业 UI。\n\n\n自定义 Utility Class#\n\n我们也可以自己实现新的 Utility Class，方便在代码间复用。\n\nUtility Class 本身也是一种面向组件的技术（将不同 class 用在一个组件上，等价于给这个组件设置了一些来自基类的属性），但 Utility\nClass 的 classname 是全局的（因为要用在任意组件/元素上），很适合用独立 CSS 文件来实现。\n\n创建一个新的 CSS 文件：\n\n在 src/routes/page.tsx 里导入 utils.css：\n\nimport '../styles/utils.css';\n\n\n在 src/routes/styles/utils.css 里实现一个名为 custom-text-gray 的 Utility Class。\n\n:root {\n  --custom-text-color: rgb(113, 128, 150);\n}\n\n.custom-text-gray {\n  color: var(--custom-text-color);\n}\n\n\nINFO\n\nModern.js 集成了 PostCSS，支持现代 CSS 语法特性，比如 custom properties。\n\n在 src/routes/components/Item/index.tsx 里使用，把：\n\n\n\n\n改成：\n\n\n\n\n执行 pnpm run dev，可以看到字体颜色改变了：\n\n\n\nINFO\n\n此处只是为了演示 Utility Class 用法。真实项目中，在有 Tailwind CSS 的情况下，这种 Utility Class\n没什么价值，应该通过配置 Design System 的 theme 来增加字体颜色。\n\nutils.css 也可以写成 utils.scss 或 utils.less，Modern.js 对 SCSS 和 Less 同样提供开箱即用的支持。\n\n不过在 PostCSS 的支持下，现代 CSS 应该足以满足这些开发需求，性能相较于预处理器也更好，建议优先用 .css 文件。","frontmatter":{"title":"添加样式"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/tutorials/first-app/c03-css.mdx","_relativePath":"zh/tutorials/first-app/c03-css.mdx"},{"id":588,"title":"添加客户端路由","routePath":"/tutorials/first-app/c04-routes","lang":"zh","toc":[],"domain":"","content":"#\n\n上一章节中，我们学习了如何为创建 UI 组件，并添加样式。\n\n这一章节中，我们将会学习如何添加客户端路由。\n\n之前我们已经为联系人列表增加了 Archive 按钮，接下来我们添加一个客户端路由 /archives，访问这个路由时，只显示已存档的联系人，而原有的 /\n继续显示所有联系人。\n\n新建 src/routes/archives/page.tsx 文件：\n\n添加如下代码：\n\n\n\n\n\nconst getAvatar = (users: Array<{ name: string; email: string }>) =>\n  users.map(user => ({\n    ...user,\n    avatar: `https://avatars.dicebear.com/v2/identicon/${user.name}.svg`,\n  }));\n\nconst getMockArchivedData = () =>\n  getAvatar([\n    { name: 'Thomas', email: 'w.kccip@bllmfbgv.dm' },\n    { name: 'Chow', email: 'f.lfqljnlk@ywoefljhc.af' },\n  ]);\nfunction Index() {\n  return (\n    \n\n      \n        Archives\n      \n       }\n      />\n    \n  );\n}\n\nexport default Index;\n\n\n这里使用了 React Helmet 的 Helmet 组件，在 src/routes/page.tsx 中也添加 Helmet 组件：\n\n\n\nfunction Index() {\n  return (\n    \n\n      \n        All\n      \n      ...\n    \n  );\n}\n\n\nINFO\n\nModern.js 默认集成了 react-helmet，也可以结合 SSR 使用，满足 SEO 需求。\n\n因为现在有多个页面，都需要用到前面的 Utility Class，因此我们需要把样式文件移动到 src/routes/layout.tsx：\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\nimport '../styles/utils.css';\n\n\n执行 pnpm run dev，访问 http://localhost:8080，可以看到完整的联系人，页面的标题是 All：\n\n\n\n访问 http://localhost:8080/archives，只会看到已存档的联系人，页面的标题是 Archives：\n\n\n\n查看页面 HTML 源码，可以看到两个页面的内容是一样，是在客户端针对不同 URL 渲染不同内容。\n\n接下来我们增加一个简单的导航栏，让用户能在两个列表之间切换。\n\n打开 src/routes/layout.tsx，在顶部导入 Radio 组件：\n\n\n\n\n然后将 UI 最顶部进行修改，增加一组单选框\n\nexport default function Layout() {\n  return (\n    \n\n      \n\n        \n          All\n          Archives\n        \n      \n      \n    \n  );\n}\n\n\n然后我们来实现 currentList 和 handleSetList。\n\n引入三个 React Hook：useState 和 useNavigate 和 useParams，以及 Ant Design 的事件类型定义：\n\n\n\n\n\n\n最后在 Layout 组件里增加局部状态和相关逻辑：\n\nexport default function Layout() {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [currentList, setList] = useState(location.pathname || '/');\n  const handleSetList = (e: RadioChangeEvent) => {\n    const { value } = e.target;\n    setList(value);\n    navigate(value);\n  };\n  return (\n  ...\n}\n\n\n到这里就已经完成了页面导航栏实现，执行 pnpm run dev 查看效果：\n\n\n\n点击导航栏中 Archives，可以看到单选框的选中状态和 URL 都会变化，页面没有刷新，只发生了 CSR。\n\n通过 URL 访问两个页面，可以看到 HTML 内容是不同的，这是因为在 SSR 阶段页面就执行了客户端路由的逻辑，HTML 里已经包含了最终的渲染结果。","frontmatter":{"title":"添加客户端路由"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/tutorials/first-app/c04-routes.mdx","_relativePath":"zh/tutorials/first-app/c04-routes.mdx"},{"id":589,"title":"添加 Loader","routePath":"/tutorials/first-app/c05-loader","lang":"zh","toc":[],"domain":"","content":"#\n\n上一章节中，我们学习了如何添加客户端路由。\n\n这一章节中，我们将会学习如何为路由组件添加 Loader。\n\n到目前为止，我们都是通过硬编码的方式，为组件提供数据。如果要从远端获取数据，通常情况下会使用 useEffect 来做。但在启用 SSR\n的情况下，useEffect 是不会在服务端执行的，所以这种 SSR 只能渲染很有限的 UI。\n\nModern.js 为提供了 Data Loader 的能力，支持同构的在组件中获取数据，让 SSR 的价值最大化。\n\n下面我们演示如何为路由组件添加 Data Loader，并模拟远端数据获取。我们使用 faker 来 mock 需要的数据，首先安装依赖：\n\npnpm add faker@5\npnpm add @types/faker@5 -D\n\n\n创建 src/routes/page.loader.ts：\n\n\n\ntype LoaderData = {\n  code: number;\n  data: {\n    name: string;\n    avatar: string;\n    email: string;\n  }[];\n};\n\nexport default async (): Promise => {\n  const data = new Array(20).fill(0).map(() => {\n    const firstName = name.firstName();\n    return {\n      name: firstName,\n      avatar: `https://avatars.dicebear.com/api/identicon/${firstName}.svg`,\n      email: internet.email(),\n    };\n  });\n\n  return {\n    code: 200,\n    data,\n  };\n};\n\n\nNOTE\n\nData Loader 并非只为 SSR 工作。在 CSR 项目中，Data Loader 也可以避免数据获取依赖 UI\n渲染，解决请求瀑布流的问题。未来，Modern.js 也会为这一特性添加更多能力，例如预获取、数据缓存等。\n\nModern.js 也提供了一个叫 useLoaderData 的 hooks API，我们修改 src/routes/page.tsx 导出的组件：\n\n\n\nfunction Index() {\n  const { data } = useLoaderData() as LoaderData;\n\n  return (\n    \n\n      \n        All\n      \n       }\n      />\n    \n  );\n}\n\nexport default Index;\n\n\n重新执行 pnpm run dev，查看 view-source:http://localhost:8080/，或在 devtools 的 Network\n面板里查看 HTML 请求的「 Preview 」，可以看到 SSR 渲染出来的 HTML 已经包含完整的 UI：\n\n","frontmatter":{"title":"添加 Loader"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/tutorials/first-app/c05-loader.mdx","_relativePath":"zh/tutorials/first-app/c05-loader.mdx"},{"id":590,"title":"添加业务模型（状态管理）","routePath":"/tutorials/first-app/c06-model","lang":"zh","toc":[{"text":"实现 Model","id":"实现-model","depth":2,"charIndex":309},{"text":"使用 Model","id":"使用-model","depth":2,"charIndex":2341}],"domain":"","content":"#\n\n上一章节中，我们把硬编码的 mockData 改成从 Data Loader 中加载。\n\n这一章节中，我们会进一步实现项目的功能，例如实现 Archive 按钮的功能，把联系人归档。\n\n因此会开始编写一些跟 UI 完全无关的业务逻辑，如果继续写在组件代码中，会产生越来越多的面条式代码。为此，我们引入了一种叫做 业务模型（Model）\n的代码模块，将这些业务逻辑和 UI 解耦。\n\n注意\n\n使用状态管理相关 API，需要先启用配置项 runtime.state：\n\n\n\nexport default defineConfig({\n  runtime: {\n    state: true,\n  },\n});\n\n\n\n实现 Model#\n\n创建一个完整的 Model 首先需要定义状态（state），包括状态中数据的名称和初始值。\n\n我们使用 Model 来管理联系人列表的数据，因此定义如下数据状态：\n\nconst state = {\n  items: [],\n};\n\n\n使用 TS 语法，可以定义更完整的类型信息，比如 items 里每个对象都应该有 name、email 字段。为了实现归档功能，还需要创建 archived\n字段保存这个联系人是否已被归档的状态。\n\n我们还需要一个字段用来访问所有已归档的联系人，可以定义 computed 类型的字段，对已有的数据做转换：\n\nconst computed = {\n  archived: ({ items }) => {\n    return items.filter(item => item.archived);\n  },\n};\n\n\ncomputed 类型字段的定义方式是函数，但使用时可以像普通字段一样通过 state 访问。\n\nINFO\n\nModern.js 集成了 Immer，能够像操作 JS 中常规的可变数据一样，去写这种状态转移的逻辑。\n\n实现 Archive 按钮时，我们需要一个 archive 函数，负责修改指定联系人的 archived 字段，我们把这种函数都叫作 action：\n\nconst actions = {\n  archive(draft, payload) {\n    const target = draft.items.find(item => item.email === payload);\n    if (target) {\n      target.archived = true;\n    }\n  },\n};\n\n\naction 函数是一种纯函数，确定的输入得到确定的输出（转移后的状态），不应该有任何副作用。\n\n函数的第一个参数是 Immer 提供的 Draft State，第二个参数是 action 被调用时传入的参数（后面会介绍怎么调用）。\n\n我们尝试完整实现它们：\n\nconst state = {\n  items: [],\n  pending: false,\n  error: null,\n};\n\nconst computed = {\n  archived: ({ items }) => {\n    return items.filter(item => item.archived);\n  },\n};\n\nconst actions = {\n  archive(draft, payload) {\n    const target = draft.items.find(item => item.email === payload);\n    if (target) {\n      target.archived = true;\n    }\n  },\n};\n\n\n接下来我们把上面的代码连起来，放在同一个 Model 文件里。首先执行以下命令，创建新的文件目录：\n\nmkdir -p src/models/\ntouch src/models/contacts.ts\n\n\n添加 src/models/contacts.ts 的内容：\n\n\n\ntype State = {\n  items: {\n    avatar: string;\n    name: string;\n    email: string;\n    archived?: boolean;\n  }[];\n  pending: boolean;\n  error: null | Error;\n};\n\nexport default model('contacts').define({\n  state: {\n    items: [],\n    pending: false,\n    error: null,\n  },\n  computed: {\n    archived: ({ items }: State) => items.filter(item => item.archived),\n  },\n  actions: {\n    archive(draft, payload) {\n      const target = draft.items.find(item => item.email === payload)!;\n      if (target) {\n        target.archived = true;\n      }\n    },\n  },\n});\n\n\n我们把一个包含 state，action 等要素的 plain object 称作 Model Spec，Modern.js 提供了 Model\nAPI，可以根据 Model Spec 生成 Model。\n\n\n使用 Model#\n\n现在我们直接使用这个 Model，把项目的逻辑补充起来。\n\n首先修改 src/components/Item/index.tsx，添加 Archive 按钮的 UI 和交互，内容如下：\n\n\n\ntype InfoProps = {\n  avatar: string;\n  name: string;\n  email: string;\n  archived?: boolean;\n};\n\nconst Item = ({\n  info,\n  onArchive,\n}: {\n  info: InfoProps;\n  onArchive?: () => void;\n}) => {\n  const { avatar, name, email, archived } = info;\n  return (\n    \n\n      \n      \n\n        \n\n          \n\n{name}\n          \n\n{email}\n        \n        \n          {archived ? 'Archived' : 'Archive'}\n        \n      \n    \n  );\n};\n\nexport default Item;\n\n\n接下来，我们修改 src/routes/page.tsx 和 src/routes/page.loader.ts，为 组件传递更多参数：\n\nexport type LoaderData = {\n  code: number;\n  data: {\n    name: string;\n    avatar: string;\n    email: string;\n  }[];\n};\n\nexport default async (): Promise => {\n  const data = new Array(20).fill(0).map(() => {\n    const firstName = name.firstName();\n    return {\n      name: firstName,\n      avatar: `https://avatars.dicebear.com/api/identicon/${firstName}.svg`,\n      email: internet.email(),\n      archived: false,\n    };\n  });\n\n  return {\n    code: 200,\n    data,\n  };\n};\n\n\n\n\n\n\n\n\n\n\nfunction Index() {\n  const { data } = useLoaderData() as LoaderData;\n  const [{ items }, { archive, setItems }] = useModel(contacts);\n  if (items.length === 0) {\n    setItems(data);\n  }\n\n  return (\n    \n\n      \n        All\n      \n       (\n           {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    \n  );\n}\n\nexport default Index;\n\n\nuseModel 是 Modern.js 提供的 hooks API。可以在组件中提供 Model 中定义的 state，或通过 actions 调用\nModel 中定义的 side effect 与 action，从而改变 Model 的 state。\n\nModel 是业务逻辑，是计算过程，本身不创建也不持有状态。只有在被组件用 hooks API 使用后，才在指定的地方创建状态。\n\n执行 pnpm run dev，点击 Archive 按钮，可以看到页面 UI 发生了变化。\n\nNOTE\n\n上述例子中，useLoaderData 其实在每次切换路由时都会执行。因为我们在 Data Loader 里使用了 fake\n数据，每次返回的数据是不同的。但我们优先使用了 Model 中的数据，因此切换路由时数据没有发生改变。","frontmatter":{"title":"添加业务模型（状态管理）"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/tutorials/first-app/c06-model.mdx","_relativePath":"zh/tutorials/first-app/c06-model.mdx"},{"id":591,"title":"添加容器组件","routePath":"/tutorials/first-app/c07-container","lang":"zh","toc":[{"text":"使用完整 Model","id":"使用完整-model","depth":2,"charIndex":220},{"text":"抽离容器组件","id":"抽离容器组件","depth":2,"charIndex":2116}],"domain":"","content":"#\n\n上一章节中，我们初步引入业务模型，从 UI 组件中拆分出这部分逻辑。page.tsx 中不再包含 UI 无关的业务逻辑实现细节，只需要使用\nModel，就能实现同样的功能。\n\n这一章节中，我们要进一步利用 Model 中实现的业务逻辑，让 page.tsx 和 archived/page.tsx 获取同一份数据。并实现 Archive\n按钮，点击按钮能把联系人归档，只显示在 Archives 列表里，不显示在 All 列表里。\n\n\n使用完整 Model#\n\n因为两个页面需要共用同一套状态（联系人列表数据、联系人是否被归档），都需要包含加载初始数据的逻辑，因此我们需要在更上一层完成数据获取。\n\nModern.js 支持在 layout.tsx 通过 Data Loader 获取数据，我们先数据获取这部分代码移动到\nsrc/routes/layout.tsx 中：\n\nexport type LoaderData = {\n  code: number;\n  data: {\n    name: string;\n    avatar: string;\n    email: string;\n  }[];\n};\n\nexport default async (): Promise => {\n  const data = new Array(20).fill(0).map(() => {\n    const firstName = name.firstName();\n    return {\n      name: firstName,\n      avatar: `https://avatars.dicebear.com/api/identicon/${firstName}.svg`,\n      email: internet.email(),\n    };\n  });\n\n  return {\n    code: 200,\n    data,\n  };\n};\n\n\n\nimport {\n  Outlet,\n  useLoaderData,\n  useLocation,\n  useNavigate,\n} from '@modern-js/runtime/router';\n\n\n\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\nimport '../styles/utils.css';\n\n\nexport default function Layout() {\n  const { data } = useLoaderData() as LoaderData;\n  const [{ items }, { setItems }] = useModel(contacts);\n  if (items.length === 0) {\n    setItems(data);\n  }\n\n  const navigate = useNavigate();\n  ...\n}\n\n\n在 src/routes/page.tsx 中，直接使用 Model，获取数据：\n\n\n\n\n\n\n\nfunction Index() {\n  const [{ items }, { archive }] = useModel(contacts);\n\n  return (\n    \n\n      \n        All\n      \n       (\n           {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    \n  );\n}\n\nexport default Index;\n\n\n同样在 archived/page.tsx 中，删除原本的 mockData 逻辑，使用 Model 中 computed 的 archived 值作为数据源：\n\n\n\n\n\n\n\nfunction Index() {\n  const [{ archived }, { archive }] = useModel(contacts);\n\n  return (\n    \n\n      \n        Archives\n      \n       (\n           {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    \n  );\n}\n\nexport default Index;\n\n\n执行 pnpm run dev，访问 http://localhost:8080/，点击 Archive 按钮后，可以看到按钮置灰：\n\n\n\n接下来点击顶部导航，切换到 Archives 列表，可以发现刚才 Archive 的联系人已经出现在列表当中：\n\n\n\n\n抽离容器组件#\n\n前面章节中，我们把项目中的业务逻辑拆分成了两个 layer，一个是视图组件，另一个是业务模块。前者负责 UI 展示、交互等，后者负责实现 UI\n无关的业务逻辑，专门管理状态。\n\n像 src/routes/page.tsx 和 src/routes/archives/page.tsx 这样使用了 useModel API 的组件，负责把\nView 和 Model 这两个 layer 连接起来，类似传统 MVC 架构中 Controller 的角色，在 Modern.js\n里我们沿用习惯，把它们称作容器组件（Container）。\n\n容器组件推荐放在专门的 containers/ 目录里，我们执行以下命令，创建新的文件：\n\n我们将原本两个 page.tsx 中公共的部分抽离出来，src/containers/Contacts.tsx 的代码如下：\n\n\n\n\n\n\n\n\n\n\n\nfunction Contacts({\n  title,\n  source,\n}: {\n  title: string;\n  source: 'items' | 'archived';\n}) {\n  const [state, { archive }] = useModel(contacts);\n\n  return (\n    \n\n      \n        {title}\n      \n       (\n           {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    \n  );\n}\n\nexport default Contacts;\n\n\n修改 src/routes/page.tsx 和 src/routes/archives/page.tsx 的代码：\n\n\n\nfunction Index() {\n  return ;\n}\n\nexport default Index;\n\n\n\n\nfunction Index() {\n  return ;\n}\n\nexport default Index;\n\n\n重构完成，现在的项目结构是：\n\n.\n├── README.md\n├── dist\n├── modern.config.ts\n├── node_modules\n├── package.json\n├── pnpm-lock.yaml\n├── src\n│   ├── components\n│   │   ├── Avatar\n│   │   │   └── index.tsx\n│   │   └── Item\n│   │       └── index.tsx\n│   ├── containers\n│   │   └── Contacts.tsx\n│   ├── models\n│   │   └── contacts.ts\n│   ├── modern-app-env.d.ts\n│   ├── routes\n│   │   ├── archives\n│   │   │   └── page.tsx\n│   │   ├── layout.tsx\n│   │   └── page.tsx\n│   └── styles\n│       └── utils.css\n└── tsconfig.json\n\n\ncomponents/ 里的视图组件，都是目录形式，如 Avatar/index.tsx。而 containers/ 里的容器组件，都是单文件形式，如\ncontacts.tsx。这是我们推荐的一种最佳实践。\n\n在 添加 UI 组件（Component） 章节提到过，视图组件用目录形式，是因为视图组件负责实现 UI\n展示和交互细节，可以演变的复杂。用目录形式，可以方便增加子文件，包括专用的资源（图片等）、专用子组件、CSS\n文件等。在这个目录内部可以随意重构，只考虑最小局部。\n\n而容器组件只负责连接，是一个胶水层，复杂的业务逻辑和实现细节都交给 View 层和 Model\n层去实现。容器组件自己应该保持简单清晰，不应该包含复杂实现细节，所以不应该有内部结构。采用单文件形式不但更简洁，也能起到约束作用，提醒开发者不要把容器组件写复杂\n。","frontmatter":{"title":"添加容器组件"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/tutorials/first-app/c07-container.mdx","_relativePath":"zh/tutorials/first-app/c07-container.mdx"},{"id":592,"title":"添加应用入口","routePath":"/tutorials/first-app/c08-entries","lang":"zh","toc":[{"text":"新建入口","id":"新建入口","depth":2,"charIndex":88},{"text":"按入口修改配置","id":"按入口修改配置","depth":2,"charIndex":1761},{"text":"下一步","id":"下一步","depth":2,"charIndex":2480}],"domain":"","content":"#\n\n上一个章节中，我们基本完成了联系人列表应用的开发，介绍了 Modern.js 中部分功能的用法，以及推荐的最佳实践。\n\n这一章节中，我们将介绍如何为应用添加新的入口。\n\n\n新建入口#\n\n一个完整的项目可能需要多个入口，Modern.js 支持自动创建新入口，前面的章节中提到过，pnpm run new 可以启用可选功能。\n\n我们也可以通过它来创建新的工程元素，在项目根目录下执行 pnpm run new：\n\n? 请选择你想要的操作 创建工程元素\n? 请选择创建元素类型 新建「应用入口」\n? 请填写入口名称 (entry) landing-page\n\n\n创建完成，项目会变成这样：\n\n.\n├── README.md\n├── modern.config.ts\n├── node_modules\n├── package.json\n├── pnpm-lock.yaml\n├── src\n│   ├── modern-app-env.d.ts\n│   ├── landing-page\n│   │   └── routes\n│   │       ├── index.css\n│   │       ├── layout.tsx\n│   │       └── page.tsx\n│   └── myapp\n│       ├── components\n│       │   ├── Avatar\n│       │   │   └── index.tsx\n│       │   └── Item\n│       │       └── index.tsx\n│       ├── containers\n│       │   └── Contacts.tsx\n│       ├── models\n│       │   └── contacts.ts\n│       ├── routes\n│       │   ├── archives\n│       │   │   └── page.tsx\n│       │   ├── layout.tsx\n│       │   └── page.tsx\n│       └── styles\n│           └── utils.css\n└── tsconfig.json\n\n\n可以看到联系人列表应用的文件，都被自动重构到 src/myapp/ 里。\n\n同时新建了一个 src/landing-page/，里面同样有 routes/*（pnpm run new\n命令只做了这些事，所以你也可以很容易的手动创建新入口或修改入口）\n\n执行 pnpm run dev，显示：\n\n\n\n访问 http://localhost:8080/，可以像之前一样看到应用程序。\n\n访问 http://localhost:8080/landing-page，可以看到刚创建的新入口 landing-page 的页面（Modern.js\n自动生成的默认页面）。\n\nModern.js 框架的设计原则之一是【约定优于配置（Convention over\nConfiguration）】，多数情况下可以按约定直接写代码，不需要做任何配置，这里 src/ 中的目录结构就是一种约定：\n\nsrc/myapp/ 和 src/landing-page/ 被自动识别为两个应用入口：myapp 和 landing-page。\n\n其中 src/myapp/ 的目录名跟项目名（package.json 里的 name）一致，会被认为是项目主入口，项目 URL 的根路径（开发环境里默认是\nhttp://localhost:8080/）会自动指向主入口。\n\n其他入口的 URL，是在根路径后追加入口名，比如 http://localhost:8080/landing-page。\n\n接下来，我们把 src/myapp/ 重命名为 src/contacts/：\n\nmv src/myapp src/contacts\n\n\n再次执行 pnpm run dev，结果变成：\n\n\n\n现在不再有主入口，联系人列表现在是一个普通入口，需要用 http://localhost:8080/contacts 访问。\n\n\n按入口修改配置#\n\n我们可以在 Modern.js 配置文件里，自己写代码来控制项目的配置。\n\n现在，修改 modern.config.ts，添加内容：\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n    ssrByEntries: {\n      'landing-page': false,\n    },\n  },\n  plugins: [appTools(), tailwindcssPlugin()],\n});\n\n\n执行 pnpm run dev，再用浏览器打开 view-source:http://localhost:8080/landing-page，可以看到\nlanding-page 网页内容是通过 js 动态加载的，且此页面的 SSR 功能被关闭。\n\n如果注释掉 ssrByEntries 和它的值，landing-page 的 SSR 功能就恢复开启了。\n\n还有一些时候，需要一些更复杂的逻辑来做设置，比如需要 JS 变量、表达式、导入模块等，例如在只在开发环境里开启 SSR：\n\nexport default defineConfig({\n  server: {\n    ssrByEntries: {\n      'landing-page': process.env.NODE_ENV !== 'production',\n    },\n  },\n};\n\n\n到底为止，我们的联系人列表应用的雏形就基本完成了 👏👏👏。\n\n\n下一步#\n\n接下来你可以通过了解指南、配置 等更多教程，进一步完善你的应用。","frontmatter":{"title":"添加应用入口"},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/tutorials/first-app/c08-entries.mdx","_relativePath":"zh/tutorials/first-app/c08-entries.mdx"},{"id":593,"title":"介绍","routePath":"/tutorials/foundations/introduction","lang":"zh","toc":[{"text":"Modern.js 是什么","id":"modernjs-是什么","depth":2,"charIndex":71},{"text":"实战教程","id":"实战教程","depth":2,"charIndex":129}],"domain":"","content":"#\n\n欢迎来到 Modern.js 教程！\n\n阅读本栏目后，你将初步理解 Modern.js，并使用 Modern.js 创建第一个应用。\n\n\nModern.js 是什么#\n\n如果你对 Modern.js 还不了解，可以先阅读 Modern.js 介绍。\n\n\n实战教程#\n\n我们准备了一个创建「联系人列表应用」的实战教程，你可以按照教程一步步创建一个应用，并了解到 Modern.js 中的以下实践：\n\n * 创建项目\n * 使用 antd 组件库\n * 集成 Tailwind CSS\n * 客户端路由\n * 数据获取\n * 状态管理\n * 容器组件\n * 新建入口\n * ...\n\n下面就让我们从 创建项目 开始吧！","frontmatter":{"title":"介绍","sidebar_position":1},"_filepath":"/home/runner/work/modern.js/modern.js/packages/document/main-doc/docs/zh/tutorials/foundations/introduction.mdx","_relativePath":"zh/tutorials/foundations/introduction.mdx"}]