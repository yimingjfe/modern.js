(self.webpackChunk_modern_js_main_doc=self.webpackChunk_modern_js_main_doc||[]).push([["docs_zh_guides_topic-detail_model_performance_mdx"],{39518:function(e,n,o){"use strict";Object.defineProperty(n,"__esModule",{value:!0});!function(e,n){for(var o in n)Object.defineProperty(e,o,{enumerable:!0,get:n[o]})}(n,{frontmatter:function(){return s},title:function(){return a},toc:function(){return c},default:function(){return l}});var t=o("9880"),d=o("23169"),s={sidebar_position:8,title:"性能优化"},a="性能优化",c=[{text:"Model 拆分",depth:2,id:"model-拆分"},{text:"状态筛选",depth:2,id:"状态筛选"},{text:"衍生状态缓存",depth:2,id:"衍生状态缓存"}];function r(e){var n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",div:"div"},(0,d.useMDXComponents)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"性能优化",children:["性能优化",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#性能优化",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"Reduck 内部已经做了大量性能优化工作，一般情况下不需要考虑性能问题。不过当对性能比较敏感、或者遇到了性能问题，可以考虑从以下 3 个方面，进行更有针对性的性能优化。"}),"\n",(0,t.jsxs)(n.h2,{id:"model-拆分",children:["Model 拆分",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#model-拆分",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["当 ",(0,t.jsx)(n.code,{children:"useModel"})," 返回 Model 对象的完整 State 时，State 任意部分的变化都会导致调用了 ",(0,t.jsx)(n.code,{children:"useModel"})," 的组件重新渲染。"]}),"\n",(0,t.jsx)(n.p,{children:"例如："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const fooModel = model('foo').define({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\nfunction ComponentA() {\n  const [state] = useModel(fooModel);\n\n  return <div>{state.a}</div>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["组件 ",(0,t.jsx)(n.code,{children:"ComponentA"})," 虽然只需要使用 ",(0,t.jsx)(n.code,{children:"a"})," 状态，但当 ",(0,t.jsx)(n.code,{children:"b"})," 状态发送变化时， ",(0,t.jsx)(n.code,{children:"ComponentA"})," 仍然会重新渲染。这种情况，我们可以考虑把 ",(0,t.jsx)(n.code,{children:"fooModel"})," 拆分，",(0,t.jsx)(n.code,{children:"a"}),"、",(0,t.jsx)(n.code,{children:"b"})," 分别由不同的 Model 负责管理："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const fooModel = model('foo').define({\n  state: {\n    a: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    b: '',\n  },\n  actions: {\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"状态筛选",children:["状态筛选",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#状态筛选",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"useModel"})," 支持传入 selector 函数，对返回给组件的 State 和 Actions 做筛选。我们可以通过 selector 函数，确保返回给组件的 State 是组件直接需要使用的，从而保证组件不会因为其他无关状态的变化而重新渲染。"]}),"\n",(0,t.jsx)(n.p,{children:"对于上面同样的例子，我们采用 selector 函数进行性能优化，代码如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const fooModel = model('foo').define({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\nfunction ComponentA() {\n  // 通过传入 selector 函数，只返回 a 状态给组件\n  const [stateA] = useModel(fooModel, state => state.a);\n\n  return <div>{stateA}</div>;\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"衍生状态缓存",children:["衍生状态缓存",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#衍生状态缓存",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["当 Model 存在 ",(0,t.jsx)(n.code,{children:"computed"})," 时，每次调用",(0,t.jsx)(n.code,{children:"useModel"})," 都会执行 ",(0,t.jsx)(n.code,{children:"computed"})," 函数。"]}),"\n",(0,t.jsx)(n.p,{children:"考虑如下代码："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const barModel = model('bar').define({\n  state: {\n    value: 'bar',\n  },\n  computed: {\n    combineA: [\n      fooModel, // fooModel 定义同上\n      (state, fooState) => {\n        return state + fooState.a;\n      },\n    ],\n  },\n  actions: {\n    setValue(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\nfunction ComponentB() {\n  const [state, actions] = useModel(fooModel);\n  const [{ combineA }] = useModel(barModel);\n  // 省略\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"barModel"})," 的衍生状态 ",(0,t.jsx)(n.code,{children:"combineA"})," 依赖 ",(0,t.jsx)(n.code,{children:"barModel"})," 自身状态 和 ",(0,t.jsx)(n.code,{children:"fooModel"})," 的状态 ",(0,t.jsx)(n.code,{children:"a"}),"，但是即使是 ",(0,t.jsx)(n.code,{children:"fooModel"})," 的状态 ",(0,t.jsx)(n.code,{children:"b"})," 发生了变化，组件重新渲染时， ",(0,t.jsx)(n.code,{children:"combineA"})," （更准确的说法是 ",(0,t.jsx)(n.code,{children:"combineA"})," 的最后一个函数类型的元素 ）依然会被调用执行。"]}),"\n",(0,t.jsxs)(n.p,{children:["一般情况下，",(0,t.jsx)(n.code,{children:"computed"})," 函数中的逻辑都是非常轻量的，但当 ",(0,t.jsx)(n.code,{children:"computed"})," 函数逻辑比较复杂时，我们可以考虑对计算逻辑做缓存。例如，我们使用 ",(0,t.jsx)(n.a,{href:"https://github.com/reduxjs/reselect",target:"_blank",rel:"noopener noreferrer",children:"reselect"})," 对 ",(0,t.jsx)(n.code,{children:"barModel"})," 的 ",(0,t.jsx)(n.code,{children:"combineA"})," 做缓存："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import 'createSelector' from 'reselect';\n\n// 创建缓存函数\nconst selectCombineA = createSelector(\n  (state) => state.bar.value,\n  (state) => state.foo.a,\n  (barState, fooState) => {\n    return barState + fooState;\n  }\n);\n\nconst barModel = model(\"bar\").define({\n  state: {\n    value: \"bar\",\n  },\n  computed: {\n    combineA: [\n      fooModel,\n      (state, fooState) => {\n        return selectCombineA({\n          foo: fooState,\n          bar: state,\n        });\n      },\n    ],\n  },\n  actions: {\n    setValue(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["我们创建缓存函数 ",(0,t.jsx)(n.code,{children:"createSelector"}),"，仅当 ",(0,t.jsx)(n.code,{children:"barModel"})," 的状态发生改变或 ",(0,t.jsx)(n.code,{children:"fooModel"})," 的 ",(0,t.jsx)(n.code,{children:"a"})," 状态发生改变时，才会重新计算 ",(0,t.jsx)(n.code,{children:"combineA"})," 的值。"]}),"\n",(0,t.jsxs)(n.div,{className:"modern-directive info",children:[(0,t.jsx)(n.div,{className:"modern-directive-title",children:"补充信息"}),(0,t.jsxs)(n.div,{className:"modern-directive-content",children:[(0,t.jsxs)(n.p,{children:["本节完整的",(0,t.jsx)(n.a,{href:"https://github.com/web-infra-dev/modern-js-examples/tree/main/series/tutorials/runtime-api/model/performance-optimization",target:"_blank",rel:"noopener noreferrer",children:"示例代码"})]}),"\n"]})]})]})}var l=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Object.assign({},(0,d.useMDXComponents)(),e.components).wrapper;return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(r,e)})):r(e)}}}]);